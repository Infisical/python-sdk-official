# coding: utf-8

"""
    Infisical API

    List of all available APIs that can be consumed

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from datetime import datetime

from pydantic import Field, StrictFloat, StrictInt, StrictStr, confloat, conint, constr

from typing import Any, Dict, List, Optional, Union

from infisicalapi_client.models.api_status_get200_response import ApiStatusGet200Response
from infisicalapi_client.models.api_v1_access_approvals_policies_get200_response import ApiV1AccessApprovalsPoliciesGet200Response
from infisicalapi_client.models.api_v1_access_approvals_policies_policy_id_patch_request import ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest
from infisicalapi_client.models.api_v1_access_approvals_policies_post_request import ApiV1AccessApprovalsPoliciesPostRequest
from infisicalapi_client.models.api_v1_access_approvals_requests_count_get200_response import ApiV1AccessApprovalsRequestsCountGet200Response
from infisicalapi_client.models.api_v1_access_approvals_requests_get200_response import ApiV1AccessApprovalsRequestsGet200Response
from infisicalapi_client.models.api_v1_access_approvals_requests_post200_response import ApiV1AccessApprovalsRequestsPost200Response
from infisicalapi_client.models.api_v1_access_approvals_requests_post_request import ApiV1AccessApprovalsRequestsPostRequest
from infisicalapi_client.models.api_v1_access_approvals_requests_request_id_review_post200_response import ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response
from infisicalapi_client.models.api_v1_additional_privilege_identity_delete_request import ApiV1AdditionalPrivilegeIdentityDeleteRequest
from infisicalapi_client.models.api_v1_additional_privilege_identity_get200_response import ApiV1AdditionalPrivilegeIdentityGet200Response
from infisicalapi_client.models.api_v1_additional_privilege_identity_patch_request import ApiV1AdditionalPrivilegeIdentityPatchRequest
from infisicalapi_client.models.api_v1_additional_privilege_identity_permanent_post200_response import ApiV1AdditionalPrivilegeIdentityPermanentPost200Response
from infisicalapi_client.models.api_v1_additional_privilege_identity_permanent_post_request import ApiV1AdditionalPrivilegeIdentityPermanentPostRequest
from infisicalapi_client.models.api_v1_additional_privilege_identity_temporary_post_request import ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest
from infisicalapi_client.models.api_v1_additional_privilege_users_get200_response import ApiV1AdditionalPrivilegeUsersGet200Response
from infisicalapi_client.models.api_v1_additional_privilege_users_permanent_post200_response import ApiV1AdditionalPrivilegeUsersPermanentPost200Response
from infisicalapi_client.models.api_v1_additional_privilege_users_permanent_post_request import ApiV1AdditionalPrivilegeUsersPermanentPostRequest
from infisicalapi_client.models.api_v1_additional_privilege_users_privilege_id_patch_request import ApiV1AdditionalPrivilegeUsersPrivilegeIdPatchRequest
from infisicalapi_client.models.api_v1_additional_privilege_users_temporary_post_request import ApiV1AdditionalPrivilegeUsersTemporaryPostRequest
from infisicalapi_client.models.api_v1_admin_config_get200_response import ApiV1AdminConfigGet200Response
from infisicalapi_client.models.api_v1_admin_config_patch200_response import ApiV1AdminConfigPatch200Response
from infisicalapi_client.models.api_v1_admin_config_patch_request import ApiV1AdminConfigPatchRequest
from infisicalapi_client.models.api_v1_admin_signup_post200_response import ApiV1AdminSignupPost200Response
from infisicalapi_client.models.api_v1_admin_signup_post_request import ApiV1AdminSignupPostRequest
from infisicalapi_client.models.api_v1_admin_user_management_users_get200_response import ApiV1AdminUserManagementUsersGet200Response
from infisicalapi_client.models.api_v1_admin_user_management_users_user_id_delete200_response import ApiV1AdminUserManagementUsersUserIdDelete200Response
from infisicalapi_client.models.api_v1_audit_log_streams_get200_response import ApiV1AuditLogStreamsGet200Response
from infisicalapi_client.models.api_v1_audit_log_streams_id_get200_response import ApiV1AuditLogStreamsIdGet200Response
from infisicalapi_client.models.api_v1_audit_log_streams_id_patch_request import ApiV1AuditLogStreamsIdPatchRequest
from infisicalapi_client.models.api_v1_audit_log_streams_post200_response import ApiV1AuditLogStreamsPost200Response
from infisicalapi_client.models.api_v1_audit_log_streams_post_request import ApiV1AuditLogStreamsPostRequest
from infisicalapi_client.models.api_v1_auth_aws_auth_identities_identity_id_get200_response import ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_aws_auth_identities_identity_id_patch_request import ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_aws_auth_identities_identity_id_post_request import ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_aws_auth_login_post_request import ApiV1AuthAwsAuthLoginPostRequest
from infisicalapi_client.models.api_v1_auth_azure_auth_identities_identity_id_get200_response import ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_azure_auth_identities_identity_id_patch_request import ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_azure_auth_identities_identity_id_post_request import ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_check_auth_post200_response import ApiV1AuthCheckAuthPost200Response
from infisicalapi_client.models.api_v1_auth_gcp_auth_identities_identity_id_get200_response import ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_gcp_auth_identities_identity_id_patch_request import ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_gcp_auth_identities_identity_id_post_request import ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_kubernetes_auth_identities_identity_id_delete200_response import ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response
from infisicalapi_client.models.api_v1_auth_kubernetes_auth_identities_identity_id_get200_response import ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_kubernetes_auth_identities_identity_id_patch_request import ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_kubernetes_auth_identities_identity_id_post_request import ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_kubernetes_auth_login_post_request import ApiV1AuthKubernetesAuthLoginPostRequest
from infisicalapi_client.models.api_v1_auth_oidc_auth_identities_identity_id_delete200_response import ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response
from infisicalapi_client.models.api_v1_auth_oidc_auth_identities_identity_id_get200_response import ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_oidc_auth_identities_identity_id_patch_request import ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_oidc_auth_identities_identity_id_post_request import ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_token_auth_identities_identity_id_get200_response import ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_token_auth_identities_identity_id_patch_request import ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_token_auth_identities_identity_id_post_request import ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_token_auth_identities_identity_id_tokens_get200_response import ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response
from infisicalapi_client.models.api_v1_auth_token_auth_identities_identity_id_tokens_post200_response import ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
from infisicalapi_client.models.api_v1_auth_token_auth_identities_identity_id_tokens_post_request import ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest
from infisicalapi_client.models.api_v1_auth_token_auth_tokens_token_id_patch200_response import ApiV1AuthTokenAuthTokensTokenIdPatch200Response
from infisicalapi_client.models.api_v1_auth_token_auth_tokens_token_id_patch_request import ApiV1AuthTokenAuthTokensTokenIdPatchRequest
from infisicalapi_client.models.api_v1_auth_token_post200_response import ApiV1AuthTokenPost200Response
from infisicalapi_client.models.api_v1_auth_token_renew_post_request import ApiV1AuthTokenRenewPostRequest
from infisicalapi_client.models.api_v1_auth_token_revoke_post_request import ApiV1AuthTokenRevokePostRequest
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get200_response import ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_client_secrets_get200_response import ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_client_secrets_post200_response import ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request import ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_get200_response import ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_patch_request import ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_auth_universal_auth_identities_identity_id_post_request import ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest
from infisicalapi_client.models.api_v1_auth_universal_auth_login_post_request import ApiV1AuthUniversalAuthLoginPostRequest
from infisicalapi_client.models.api_v1_bot_bot_id_active_patch_request import ApiV1BotBotIdActivePatchRequest
from infisicalapi_client.models.api_v1_bot_project_id_get200_response import ApiV1BotProjectIdGet200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_get200_response import ApiV1DynamicSecretsGet200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_leases_lease_id_delete200_response import ApiV1DynamicSecretsLeasesLeaseIdDelete200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_leases_lease_id_delete_request import ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest
from infisicalapi_client.models.api_v1_dynamic_secrets_leases_lease_id_get200_response import ApiV1DynamicSecretsLeasesLeaseIdGet200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_leases_lease_id_renew_post_request import ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest
from infisicalapi_client.models.api_v1_dynamic_secrets_leases_post200_response import ApiV1DynamicSecretsLeasesPost200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_leases_post_request import ApiV1DynamicSecretsLeasesPostRequest
from infisicalapi_client.models.api_v1_dynamic_secrets_name_delete_request import ApiV1DynamicSecretsNameDeleteRequest
from infisicalapi_client.models.api_v1_dynamic_secrets_name_get200_response import ApiV1DynamicSecretsNameGet200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_name_leases_get200_response import ApiV1DynamicSecretsNameLeasesGet200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_name_patch_request import ApiV1DynamicSecretsNamePatchRequest
from infisicalapi_client.models.api_v1_dynamic_secrets_post200_response import ApiV1DynamicSecretsPost200Response
from infisicalapi_client.models.api_v1_dynamic_secrets_post_request import ApiV1DynamicSecretsPostRequest
from infisicalapi_client.models.api_v1_external_kms_get200_response import ApiV1ExternalKmsGet200Response
from infisicalapi_client.models.api_v1_external_kms_id_get200_response import ApiV1ExternalKmsIdGet200Response
from infisicalapi_client.models.api_v1_external_kms_id_patch_request import ApiV1ExternalKmsIdPatchRequest
from infisicalapi_client.models.api_v1_external_kms_post200_response import ApiV1ExternalKmsPost200Response
from infisicalapi_client.models.api_v1_external_kms_post_request import ApiV1ExternalKmsPostRequest
from infisicalapi_client.models.api_v1_folders_batch_patch_request import ApiV1FoldersBatchPatchRequest
from infisicalapi_client.models.api_v1_folders_folder_id_or_name_delete_request import ApiV1FoldersFolderIdOrNameDeleteRequest
from infisicalapi_client.models.api_v1_folders_folder_id_patch_request import ApiV1FoldersFolderIdPatchRequest
from infisicalapi_client.models.api_v1_folders_get200_response import ApiV1FoldersGet200Response
from infisicalapi_client.models.api_v1_folders_post200_response import ApiV1FoldersPost200Response
from infisicalapi_client.models.api_v1_folders_post_request import ApiV1FoldersPostRequest
from infisicalapi_client.models.api_v1_groups_current_slug_patch_request import ApiV1GroupsCurrentSlugPatchRequest
from infisicalapi_client.models.api_v1_groups_post200_response import ApiV1GroupsPost200Response
from infisicalapi_client.models.api_v1_groups_post_request import ApiV1GroupsPostRequest
from infisicalapi_client.models.api_v1_groups_slug_users_get200_response import ApiV1GroupsSlugUsersGet200Response
from infisicalapi_client.models.api_v1_groups_slug_users_username_post200_response import ApiV1GroupsSlugUsersUsernamePost200Response
from infisicalapi_client.models.api_v1_identities_get200_response import ApiV1IdentitiesGet200Response
from infisicalapi_client.models.api_v1_identities_identity_id_get200_response import ApiV1IdentitiesIdentityIdGet200Response
from infisicalapi_client.models.api_v1_identities_identity_id_identity_memberships_get200_response import ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response
from infisicalapi_client.models.api_v1_identities_identity_id_patch_request import ApiV1IdentitiesIdentityIdPatchRequest
from infisicalapi_client.models.api_v1_identities_post200_response import ApiV1IdentitiesPost200Response
from infisicalapi_client.models.api_v1_identities_post_request import ApiV1IdentitiesPostRequest
from infisicalapi_client.models.api_v1_integration_auth_access_token_post_request import ApiV1IntegrationAuthAccessTokenPostRequest
from infisicalapi_client.models.api_v1_integration_auth_delete200_response import ApiV1IntegrationAuthDelete200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_apps_get200_response import ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get200_response import ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get200_response import ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_checkly_groups_get200_response import ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_get200_response import ApiV1IntegrationAuthIntegrationAuthIdGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_github_envs_get200_response import ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_github_orgs_get200_response import ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_heroku_pipelines_get200_response import ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get200_response import ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_qovery_apps_get200_response import ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_qovery_containers_get200_response import ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_qovery_environments_get200_response import ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_qovery_jobs_get200_response import ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_qovery_projects_get200_response import ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_railway_services_get200_response import ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get200_response import ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_teams_get200_response import ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_auth_id_vercel_branches_get200_response import ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response
from infisicalapi_client.models.api_v1_integration_auth_integration_options_get200_response import ApiV1IntegrationAuthIntegrationOptionsGet200Response
from infisicalapi_client.models.api_v1_integration_auth_oauth_token_post_request import ApiV1IntegrationAuthOauthTokenPostRequest
from infisicalapi_client.models.api_v1_integration_integration_id_patch_request import ApiV1IntegrationIntegrationIdPatchRequest
from infisicalapi_client.models.api_v1_integration_post200_response import ApiV1IntegrationPost200Response
from infisicalapi_client.models.api_v1_integration_post_request import ApiV1IntegrationPostRequest
from infisicalapi_client.models.api_v1_invite_org_signup_post200_response import ApiV1InviteOrgSignupPost200Response
from infisicalapi_client.models.api_v1_invite_org_signup_post_request import ApiV1InviteOrgSignupPostRequest
from infisicalapi_client.models.api_v1_invite_org_verify_post200_response import ApiV1InviteOrgVerifyPost200Response
from infisicalapi_client.models.api_v1_invite_org_verify_post_request import ApiV1InviteOrgVerifyPostRequest
from infisicalapi_client.models.api_v1_ldap_config_config_id_group_maps_get200_response_inner import ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner
from infisicalapi_client.models.api_v1_ldap_config_config_id_group_maps_post200_response import ApiV1LdapConfigConfigIdGroupMapsPost200Response
from infisicalapi_client.models.api_v1_ldap_config_config_id_group_maps_post_request import ApiV1LdapConfigConfigIdGroupMapsPostRequest
from infisicalapi_client.models.api_v1_ldap_config_get200_response import ApiV1LdapConfigGet200Response
from infisicalapi_client.models.api_v1_ldap_config_patch_request import ApiV1LdapConfigPatchRequest
from infisicalapi_client.models.api_v1_ldap_config_post200_response import ApiV1LdapConfigPost200Response
from infisicalapi_client.models.api_v1_ldap_config_post_request import ApiV1LdapConfigPostRequest
from infisicalapi_client.models.api_v1_ldap_login_post_request import ApiV1LdapLoginPostRequest
from infisicalapi_client.models.api_v1_organization_admin_projects_get200_response import ApiV1OrganizationAdminProjectsGet200Response
from infisicalapi_client.models.api_v1_organization_admin_projects_get200_response_projects_inner import ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner
from infisicalapi_client.models.api_v1_organization_admin_projects_project_id_grant_admin_access_post200_response import ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response
from infisicalapi_client.models.api_v1_organization_get200_response import ApiV1OrganizationGet200Response
from infisicalapi_client.models.api_v1_organization_organization_id_get200_response import ApiV1OrganizationOrganizationIdGet200Response
from infisicalapi_client.models.api_v1_organization_organization_id_groups_get200_response import ApiV1OrganizationOrganizationIdGroupsGet200Response
from infisicalapi_client.models.api_v1_organization_organization_id_incident_contact_org_get200_response import ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response
from infisicalapi_client.models.api_v1_organization_organization_id_incident_contact_org_post200_response import ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response
from infisicalapi_client.models.api_v1_organization_organization_id_patch200_response import ApiV1OrganizationOrganizationIdPatch200Response
from infisicalapi_client.models.api_v1_organization_organization_id_patch_request import ApiV1OrganizationOrganizationIdPatchRequest
from infisicalapi_client.models.api_v1_organization_organization_id_permissions_get200_response import ApiV1OrganizationOrganizationIdPermissionsGet200Response
from infisicalapi_client.models.api_v1_organization_organization_id_roles_get200_response import ApiV1OrganizationOrganizationIdRolesGet200Response
from infisicalapi_client.models.api_v1_organization_organization_id_roles_post200_response import ApiV1OrganizationOrganizationIdRolesPost200Response
from infisicalapi_client.models.api_v1_organization_organization_id_roles_post_request import ApiV1OrganizationOrganizationIdRolesPostRequest
from infisicalapi_client.models.api_v1_organization_organization_id_roles_role_id_patch_request import ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest
from infisicalapi_client.models.api_v1_organization_organization_id_users_get200_response import ApiV1OrganizationOrganizationIdUsersGet200Response
from infisicalapi_client.models.api_v1_organizations_organization_id_billing_details_patch_request import ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest
from infisicalapi_client.models.api_v1_organizations_organization_id_billing_details_payment_methods_post_request import ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest
from infisicalapi_client.models.api_v1_organizations_organization_id_billing_details_tax_ids_post_request import ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest
from infisicalapi_client.models.api_v1_organizations_organization_id_plan_get200_response import ApiV1OrganizationsOrganizationIdPlanGet200Response
from infisicalapi_client.models.api_v1_organizations_organization_id_session_trial_post_request import ApiV1OrganizationsOrganizationIdSessionTrialPostRequest
from infisicalapi_client.models.api_v1_password_backup_private_key_get200_response import ApiV1PasswordBackupPrivateKeyGet200Response
from infisicalapi_client.models.api_v1_password_backup_private_key_post_request import ApiV1PasswordBackupPrivateKeyPostRequest
from infisicalapi_client.models.api_v1_password_change_password_post_request import ApiV1PasswordChangePasswordPostRequest
from infisicalapi_client.models.api_v1_password_email_password_reset_post_request import ApiV1PasswordEmailPasswordResetPostRequest
from infisicalapi_client.models.api_v1_password_email_password_reset_verify_post200_response import ApiV1PasswordEmailPasswordResetVerifyPost200Response
from infisicalapi_client.models.api_v1_password_email_password_reset_verify_post_request import ApiV1PasswordEmailPasswordResetVerifyPostRequest
from infisicalapi_client.models.api_v1_password_password_reset_post_request import ApiV1PasswordPasswordResetPostRequest
from infisicalapi_client.models.api_v1_password_srp1_post200_response import ApiV1PasswordSrp1Post200Response
from infisicalapi_client.models.api_v1_password_srp1_post_request import ApiV1PasswordSrp1PostRequest
from infisicalapi_client.models.api_v1_pki_ca_ca_id_certificate_get200_response import ApiV1PkiCaCaIdCertificateGet200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_crl_get200_response import ApiV1PkiCaCaIdCrlGet200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_csr_get200_response import ApiV1PkiCaCaIdCsrGet200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_import_certificate_post200_response import ApiV1PkiCaCaIdImportCertificatePost200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_import_certificate_post_request import ApiV1PkiCaCaIdImportCertificatePostRequest
from infisicalapi_client.models.api_v1_pki_ca_ca_id_issue_certificate_post200_response import ApiV1PkiCaCaIdIssueCertificatePost200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_issue_certificate_post_request import ApiV1PkiCaCaIdIssueCertificatePostRequest
from infisicalapi_client.models.api_v1_pki_ca_ca_id_patch_request import ApiV1PkiCaCaIdPatchRequest
from infisicalapi_client.models.api_v1_pki_ca_ca_id_sign_certificate_post200_response import ApiV1PkiCaCaIdSignCertificatePost200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_sign_certificate_post_request import ApiV1PkiCaCaIdSignCertificatePostRequest
from infisicalapi_client.models.api_v1_pki_ca_ca_id_sign_intermediate_post200_response import ApiV1PkiCaCaIdSignIntermediatePost200Response
from infisicalapi_client.models.api_v1_pki_ca_ca_id_sign_intermediate_post_request import ApiV1PkiCaCaIdSignIntermediatePostRequest
from infisicalapi_client.models.api_v1_pki_ca_post200_response import ApiV1PkiCaPost200Response
from infisicalapi_client.models.api_v1_pki_ca_post_request import ApiV1PkiCaPostRequest
from infisicalapi_client.models.api_v1_pki_certificates_serial_number_certificate_get200_response import ApiV1PkiCertificatesSerialNumberCertificateGet200Response
from infisicalapi_client.models.api_v1_pki_certificates_serial_number_get200_response import ApiV1PkiCertificatesSerialNumberGet200Response
from infisicalapi_client.models.api_v1_pki_certificates_serial_number_revoke_post200_response import ApiV1PkiCertificatesSerialNumberRevokePost200Response
from infisicalapi_client.models.api_v1_pki_certificates_serial_number_revoke_post_request import ApiV1PkiCertificatesSerialNumberRevokePostRequest
from infisicalapi_client.models.api_v1_rate_limit_get200_response import ApiV1RateLimitGet200Response
from infisicalapi_client.models.api_v1_rate_limit_put_request import ApiV1RateLimitPutRequest
from infisicalapi_client.models.api_v1_scim_groups_get200_response import ApiV1ScimGroupsGet200Response
from infisicalapi_client.models.api_v1_scim_groups_get200_response_resources_inner import ApiV1ScimGroupsGet200ResponseResourcesInner
from infisicalapi_client.models.api_v1_scim_groups_group_id_patch_request import ApiV1ScimGroupsGroupIdPatchRequest
from infisicalapi_client.models.api_v1_scim_groups_group_id_put_request import ApiV1ScimGroupsGroupIdPutRequest
from infisicalapi_client.models.api_v1_scim_groups_post200_response import ApiV1ScimGroupsPost200Response
from infisicalapi_client.models.api_v1_scim_groups_post_request import ApiV1ScimGroupsPostRequest
from infisicalapi_client.models.api_v1_scim_scim_tokens_get200_response import ApiV1ScimScimTokensGet200Response
from infisicalapi_client.models.api_v1_scim_scim_tokens_post200_response import ApiV1ScimScimTokensPost200Response
from infisicalapi_client.models.api_v1_scim_scim_tokens_post_request import ApiV1ScimScimTokensPostRequest
from infisicalapi_client.models.api_v1_scim_scim_tokens_scim_token_id_delete200_response import ApiV1ScimScimTokensScimTokenIdDelete200Response
from infisicalapi_client.models.api_v1_scim_users_get200_response import ApiV1ScimUsersGet200Response
from infisicalapi_client.models.api_v1_scim_users_org_membership_id_get201_response import ApiV1ScimUsersOrgMembershipIdGet201Response
from infisicalapi_client.models.api_v1_scim_users_org_membership_id_put200_response import ApiV1ScimUsersOrgMembershipIdPut200Response
from infisicalapi_client.models.api_v1_scim_users_org_membership_id_put_request import ApiV1ScimUsersOrgMembershipIdPutRequest
from infisicalapi_client.models.api_v1_scim_users_post200_response import ApiV1ScimUsersPost200Response
from infisicalapi_client.models.api_v1_scim_users_post_request import ApiV1ScimUsersPostRequest
from infisicalapi_client.models.api_v1_secret_approval_requests_count_get200_response import ApiV1SecretApprovalRequestsCountGet200Response
from infisicalapi_client.models.api_v1_secret_approval_requests_get200_response import ApiV1SecretApprovalRequestsGet200Response
from infisicalapi_client.models.api_v1_secret_approval_requests_id_get200_response import ApiV1SecretApprovalRequestsIdGet200Response
from infisicalapi_client.models.api_v1_secret_approval_requests_id_merge_post200_response import ApiV1SecretApprovalRequestsIdMergePost200Response
from infisicalapi_client.models.api_v1_secret_approval_requests_id_merge_post_request import ApiV1SecretApprovalRequestsIdMergePostRequest
from infisicalapi_client.models.api_v1_secret_approval_requests_id_review_post200_response import ApiV1SecretApprovalRequestsIdReviewPost200Response
from infisicalapi_client.models.api_v1_secret_approval_requests_id_review_post_request import ApiV1SecretApprovalRequestsIdReviewPostRequest
from infisicalapi_client.models.api_v1_secret_approval_requests_id_status_post_request import ApiV1SecretApprovalRequestsIdStatusPostRequest
from infisicalapi_client.models.api_v1_secret_approvals_board_get200_response import ApiV1SecretApprovalsBoardGet200Response
from infisicalapi_client.models.api_v1_secret_approvals_get200_response import ApiV1SecretApprovalsGet200Response
from infisicalapi_client.models.api_v1_secret_approvals_post200_response import ApiV1SecretApprovalsPost200Response
from infisicalapi_client.models.api_v1_secret_approvals_post_request import ApiV1SecretApprovalsPostRequest
from infisicalapi_client.models.api_v1_secret_approvals_sap_id_patch_request import ApiV1SecretApprovalsSapIdPatchRequest
from infisicalapi_client.models.api_v1_secret_imports_get200_response import ApiV1SecretImportsGet200Response
from infisicalapi_client.models.api_v1_secret_imports_post200_response import ApiV1SecretImportsPost200Response
from infisicalapi_client.models.api_v1_secret_imports_post_request import ApiV1SecretImportsPostRequest
from infisicalapi_client.models.api_v1_secret_imports_secret_import_id_delete_request import ApiV1SecretImportsSecretImportIdDeleteRequest
from infisicalapi_client.models.api_v1_secret_imports_secret_import_id_patch_request import ApiV1SecretImportsSecretImportIdPatchRequest
from infisicalapi_client.models.api_v1_secret_imports_secret_import_id_replication_resync_post_request import ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest
from infisicalapi_client.models.api_v1_secret_imports_secrets_get200_response import ApiV1SecretImportsSecretsGet200Response
from infisicalapi_client.models.api_v1_secret_imports_secrets_raw_get200_response import ApiV1SecretImportsSecretsRawGet200Response
from infisicalapi_client.models.api_v1_secret_rotation_providers_workspace_id_get200_response import ApiV1SecretRotationProvidersWorkspaceIdGet200Response
from infisicalapi_client.models.api_v1_secret_rotations_get200_response import ApiV1SecretRotationsGet200Response
from infisicalapi_client.models.api_v1_secret_rotations_post200_response import ApiV1SecretRotationsPost200Response
from infisicalapi_client.models.api_v1_secret_rotations_post_request import ApiV1SecretRotationsPostRequest
from infisicalapi_client.models.api_v1_secret_rotations_restart_post200_response import ApiV1SecretRotationsRestartPost200Response
from infisicalapi_client.models.api_v1_secret_rotations_restart_post_request import ApiV1SecretRotationsRestartPostRequest
from infisicalapi_client.models.api_v1_secret_scanning_create_installation_session_organization_post200_response import ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response
from infisicalapi_client.models.api_v1_secret_scanning_create_installation_session_organization_post_request import ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest
from infisicalapi_client.models.api_v1_secret_scanning_installation_status_organization_organization_id_get200_response import ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response
from infisicalapi_client.models.api_v1_secret_scanning_link_installation_post200_response import ApiV1SecretScanningLinkInstallationPost200Response
from infisicalapi_client.models.api_v1_secret_scanning_link_installation_post_request import ApiV1SecretScanningLinkInstallationPostRequest
from infisicalapi_client.models.api_v1_secret_scanning_organization_organization_id_risks_get200_response import ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response
from infisicalapi_client.models.api_v1_secret_scanning_organization_organization_id_risks_get200_response_risks_inner import ApiV1SecretScanningOrganizationOrganizationIdRisksGet200ResponseRisksInner
from infisicalapi_client.models.api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request import ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest
from infisicalapi_client.models.api_v1_secret_secret_id_secret_versions_get200_response import ApiV1SecretSecretIdSecretVersionsGet200Response
from infisicalapi_client.models.api_v1_secret_sharing_get200_response import ApiV1SecretSharingGet200Response
from infisicalapi_client.models.api_v1_secret_sharing_get200_response_secrets_inner import ApiV1SecretSharingGet200ResponseSecretsInner
from infisicalapi_client.models.api_v1_secret_sharing_post200_response import ApiV1SecretSharingPost200Response
from infisicalapi_client.models.api_v1_secret_sharing_post_request import ApiV1SecretSharingPostRequest
from infisicalapi_client.models.api_v1_secret_sharing_public_id_get200_response import ApiV1SecretSharingPublicIdGet200Response
from infisicalapi_client.models.api_v1_secret_sharing_public_post_request import ApiV1SecretSharingPublicPostRequest
from infisicalapi_client.models.api_v1_secret_snapshot_secret_snapshot_id_get200_response import ApiV1SecretSnapshotSecretSnapshotIdGet200Response
from infisicalapi_client.models.api_v1_secret_snapshot_secret_snapshot_id_rollback_post200_response import ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response
from infisicalapi_client.models.api_v1_sso_config_get200_response import ApiV1SsoConfigGet200Response
from infisicalapi_client.models.api_v1_sso_config_patch_request import ApiV1SsoConfigPatchRequest
from infisicalapi_client.models.api_v1_sso_config_post200_response import ApiV1SsoConfigPost200Response
from infisicalapi_client.models.api_v1_sso_config_post_request import ApiV1SsoConfigPostRequest
from infisicalapi_client.models.api_v1_sso_oidc_config_get200_response import ApiV1SsoOidcConfigGet200Response
from infisicalapi_client.models.api_v1_sso_oidc_config_patch200_response import ApiV1SsoOidcConfigPatch200Response
from infisicalapi_client.models.api_v1_sso_oidc_config_patch_request import ApiV1SsoOidcConfigPatchRequest
from infisicalapi_client.models.api_v1_sso_oidc_config_post200_response import ApiV1SsoOidcConfigPost200Response
from infisicalapi_client.models.api_v1_sso_oidc_config_post_request import ApiV1SsoOidcConfigPostRequest
from infisicalapi_client.models.api_v1_sso_token_exchange_post_request import ApiV1SsoTokenExchangePostRequest
from infisicalapi_client.models.api_v1_user_action_get200_response import ApiV1UserActionGet200Response
from infisicalapi_client.models.api_v1_user_action_post200_response import ApiV1UserActionPost200Response
from infisicalapi_client.models.api_v1_user_action_post_request import ApiV1UserActionPostRequest
from infisicalapi_client.models.api_v1_user_engagement_me_wish_post_request import ApiV1UserEngagementMeWishPostRequest
from infisicalapi_client.models.api_v1_user_get200_response import ApiV1UserGet200Response
from infisicalapi_client.models.api_v1_user_me_project_favorites_get200_response import ApiV1UserMeProjectFavoritesGet200Response
from infisicalapi_client.models.api_v1_user_me_project_favorites_put_request import ApiV1UserMeProjectFavoritesPutRequest
from infisicalapi_client.models.api_v1_user_private_key_get200_response import ApiV1UserPrivateKeyGet200Response
from infisicalapi_client.models.api_v1_webhooks_get200_response import ApiV1WebhooksGet200Response
from infisicalapi_client.models.api_v1_webhooks_post200_response import ApiV1WebhooksPost200Response
from infisicalapi_client.models.api_v1_webhooks_post_request import ApiV1WebhooksPostRequest
from infisicalapi_client.models.api_v1_webhooks_webhook_id_patch_request import ApiV1WebhooksWebhookIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_get200_response import ApiV1WorkspaceGet200Response
from infisicalapi_client.models.api_v1_workspace_get200_response_workspaces_inner import ApiV1WorkspaceGet200ResponseWorkspacesInner
from infisicalapi_client.models.api_v1_workspace_project_id_permissions_get200_response import ApiV1WorkspaceProjectIdPermissionsGet200Response
from infisicalapi_client.models.api_v1_workspace_project_id_tags_get200_response import ApiV1WorkspaceProjectIdTagsGet200Response
from infisicalapi_client.models.api_v1_workspace_project_id_tags_post200_response import ApiV1WorkspaceProjectIdTagsPost200Response
from infisicalapi_client.models.api_v1_workspace_project_id_tags_post_request import ApiV1WorkspaceProjectIdTagsPostRequest
from infisicalapi_client.models.api_v1_workspace_project_id_tags_tag_id_get200_response import ApiV1WorkspaceProjectIdTagsTagIdGet200Response
from infisicalapi_client.models.api_v1_workspace_project_id_tags_tag_id_patch_request import ApiV1WorkspaceProjectIdTagsTagIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_project_slug_roles_get200_response import ApiV1WorkspaceProjectSlugRolesGet200Response
from infisicalapi_client.models.api_v1_workspace_project_slug_roles_post200_response import ApiV1WorkspaceProjectSlugRolesPost200Response
from infisicalapi_client.models.api_v1_workspace_project_slug_roles_post_request import ApiV1WorkspaceProjectSlugRolesPostRequest
from infisicalapi_client.models.api_v1_workspace_project_slug_roles_role_id_patch_request import ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_audit_logs_filters_actors_get200_response import ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_audit_logs_get200_response import ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_authorizations_get200_response import ApiV1WorkspaceWorkspaceIdAuthorizationsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_auto_capitalization_post_request import ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_delete200_response import ApiV1WorkspaceWorkspaceIdDelete200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_environments_env_id_get200_response import ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_environments_id_patch_request import ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_environments_post200_response import ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_environments_post_request import ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_get200_response import ApiV1WorkspaceWorkspaceIdGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_integrations_get200_response import ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_key_post_request import ApiV1WorkspaceWorkspaceIdKeyPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_keys_get200_response import ApiV1WorkspaceWorkspaceIdKeysGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_kms_backup_get200_response import ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_kms_backup_post_request import ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_kms_get200_response import ApiV1WorkspaceWorkspaceIdKmsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_kms_patch_request import ApiV1WorkspaceWorkspaceIdKmsPatchRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_details_post200_response import ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_details_post_request import ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_get200_response import ApiV1WorkspaceWorkspaceIdMembershipsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_membership_id_patch200_response import ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_membership_id_patch_request import ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_post200_response import ApiV1WorkspaceWorkspaceIdMembershipsPost200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_memberships_post_request import ApiV1WorkspaceWorkspaceIdMembershipsPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_migrate_v3_post200_response import ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_name_post200_response import ApiV1WorkspaceWorkspaceIdNamePost200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_name_post_request import ApiV1WorkspaceWorkspaceIdNamePostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_patch200_response import ApiV1WorkspaceWorkspaceIdPatch200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_patch_request import ApiV1WorkspaceWorkspaceIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_secret_snapshots_count_get200_response import ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_secret_snapshots_get200_response import ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_service_token_data_get200_response import ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_trusted_ips_get200_response import ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_trusted_ips_post200_response import ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response
from infisicalapi_client.models.api_v1_workspace_workspace_id_trusted_ips_post_request import ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request import ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest
from infisicalapi_client.models.api_v1_workspace_workspace_id_users_get200_response import ApiV1WorkspaceWorkspaceIdUsersGet200Response
from infisicalapi_client.models.api_v1_workspace_workspace_slug_audit_logs_retention_put_request import ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest
from infisicalapi_client.models.api_v1_workspace_workspace_slug_version_limit_put_request import ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest
from infisicalapi_client.models.api_v2_auth_mfa_verify_post200_response import ApiV2AuthMfaVerifyPost200Response
from infisicalapi_client.models.api_v2_auth_mfa_verify_post_request import ApiV2AuthMfaVerifyPostRequest
from infisicalapi_client.models.api_v2_organizations_org_id_identity_memberships_get200_response import ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response
from infisicalapi_client.models.api_v2_organizations_organization_id_memberships_get200_response import ApiV2OrganizationsOrganizationIdMembershipsGet200Response
from infisicalapi_client.models.api_v2_organizations_organization_id_memberships_membership_id_delete200_response import ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response
from infisicalapi_client.models.api_v2_organizations_organization_id_memberships_membership_id_get200_response import ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response
from infisicalapi_client.models.api_v2_organizations_organization_id_memberships_membership_id_patch_request import ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest
from infisicalapi_client.models.api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get200_response import ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response
from infisicalapi_client.models.api_v2_organizations_organization_id_workspaces_get200_response import ApiV2OrganizationsOrganizationIdWorkspacesGet200Response
from infisicalapi_client.models.api_v2_service_token_get200_response import ApiV2ServiceTokenGet200Response
from infisicalapi_client.models.api_v2_service_token_post200_response import ApiV2ServiceTokenPost200Response
from infisicalapi_client.models.api_v2_service_token_post_request import ApiV2ServiceTokenPostRequest
from infisicalapi_client.models.api_v2_service_token_service_token_id_delete200_response import ApiV2ServiceTokenServiceTokenIdDelete200Response
from infisicalapi_client.models.api_v2_users_me_api_keys_api_key_data_id_delete200_response import ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response
from infisicalapi_client.models.api_v2_users_me_api_keys_get200_response_inner import ApiV2UsersMeApiKeysGet200ResponseInner
from infisicalapi_client.models.api_v2_users_me_api_keys_post200_response import ApiV2UsersMeApiKeysPost200Response
from infisicalapi_client.models.api_v2_users_me_api_keys_post_request import ApiV2UsersMeApiKeysPostRequest
from infisicalapi_client.models.api_v2_users_me_auth_methods_put_request import ApiV2UsersMeAuthMethodsPutRequest
from infisicalapi_client.models.api_v2_users_me_emails_code_post_request import ApiV2UsersMeEmailsCodePostRequest
from infisicalapi_client.models.api_v2_users_me_emails_verify_post_request import ApiV2UsersMeEmailsVerifyPostRequest
from infisicalapi_client.models.api_v2_users_me_mfa_patch200_response import ApiV2UsersMeMfaPatch200Response
from infisicalapi_client.models.api_v2_users_me_mfa_patch_request import ApiV2UsersMeMfaPatchRequest
from infisicalapi_client.models.api_v2_users_me_name_patch_request import ApiV2UsersMeNamePatchRequest
from infisicalapi_client.models.api_v2_users_me_sessions_get200_response_inner import ApiV2UsersMeSessionsGet200ResponseInner
from infisicalapi_client.models.api_v2_workspace_post200_response import ApiV2WorkspacePost200Response
from infisicalapi_client.models.api_v2_workspace_post_request import ApiV2WorkspacePostRequest
from infisicalapi_client.models.api_v2_workspace_project_id_identity_memberships_identity_id_get200_response import ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response
from infisicalapi_client.models.api_v2_workspace_project_id_identity_memberships_identity_id_patch_request import ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest
from infisicalapi_client.models.api_v2_workspace_project_id_identity_memberships_identity_id_post200_response import ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response
from infisicalapi_client.models.api_v2_workspace_project_id_identity_memberships_identity_id_post_request import ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest
from infisicalapi_client.models.api_v2_workspace_project_id_memberships_delete_request import ApiV2WorkspaceProjectIdMembershipsDeleteRequest
from infisicalapi_client.models.api_v2_workspace_project_id_memberships_post200_response import ApiV2WorkspaceProjectIdMembershipsPost200Response
from infisicalapi_client.models.api_v2_workspace_project_id_memberships_post_request import ApiV2WorkspaceProjectIdMembershipsPostRequest
from infisicalapi_client.models.api_v2_workspace_project_id_upgrade_post_request import ApiV2WorkspaceProjectIdUpgradePostRequest
from infisicalapi_client.models.api_v2_workspace_project_id_upgrade_status_get200_response import ApiV2WorkspaceProjectIdUpgradeStatusGet200Response
from infisicalapi_client.models.api_v2_workspace_project_slug_groups_get200_response import ApiV2WorkspaceProjectSlugGroupsGet200Response
from infisicalapi_client.models.api_v2_workspace_project_slug_groups_group_slug_patch_request import ApiV2WorkspaceProjectSlugGroupsGroupSlugPatchRequest
from infisicalapi_client.models.api_v2_workspace_project_slug_groups_group_slug_post200_response import ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response
from infisicalapi_client.models.api_v2_workspace_project_slug_groups_group_slug_post_request import ApiV2WorkspaceProjectSlugGroupsGroupSlugPostRequest
from infisicalapi_client.models.api_v2_workspace_slug_cas_get200_response import ApiV2WorkspaceSlugCasGet200Response
from infisicalapi_client.models.api_v2_workspace_slug_certificates_get200_response import ApiV2WorkspaceSlugCertificatesGet200Response
from infisicalapi_client.models.api_v2_workspace_slug_patch_request import ApiV2WorkspaceSlugPatchRequest
from infisicalapi_client.models.api_v2_workspace_workspace_id_encrypted_key_get200_response import ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response
from infisicalapi_client.models.api_v3_auth_login1_post_request import ApiV3AuthLogin1PostRequest
from infisicalapi_client.models.api_v3_auth_login2_post200_response import ApiV3AuthLogin2Post200Response
from infisicalapi_client.models.api_v3_auth_login2_post_request import ApiV3AuthLogin2PostRequest
from infisicalapi_client.models.api_v3_secrets_backfill_secret_references_post_request import ApiV3SecretsBackfillSecretReferencesPostRequest
from infisicalapi_client.models.api_v3_secrets_batch_delete_request import ApiV3SecretsBatchDeleteRequest
from infisicalapi_client.models.api_v3_secrets_batch_patch_request import ApiV3SecretsBatchPatchRequest
from infisicalapi_client.models.api_v3_secrets_batch_post200_response import ApiV3SecretsBatchPost200Response
from infisicalapi_client.models.api_v3_secrets_batch_post_request import ApiV3SecretsBatchPostRequest
from infisicalapi_client.models.api_v3_secrets_batch_raw_delete_request import ApiV3SecretsBatchRawDeleteRequest
from infisicalapi_client.models.api_v3_secrets_batch_raw_patch_request import ApiV3SecretsBatchRawPatchRequest
from infisicalapi_client.models.api_v3_secrets_batch_raw_post200_response import ApiV3SecretsBatchRawPost200Response
from infisicalapi_client.models.api_v3_secrets_batch_raw_post_request import ApiV3SecretsBatchRawPostRequest
from infisicalapi_client.models.api_v3_secrets_get200_response import ApiV3SecretsGet200Response
from infisicalapi_client.models.api_v3_secrets_move_post200_response import ApiV3SecretsMovePost200Response
from infisicalapi_client.models.api_v3_secrets_move_post_request import ApiV3SecretsMovePostRequest
from infisicalapi_client.models.api_v3_secrets_raw_get200_response import ApiV3SecretsRawGet200Response
from infisicalapi_client.models.api_v3_secrets_raw_secret_name_delete_request import ApiV3SecretsRawSecretNameDeleteRequest
from infisicalapi_client.models.api_v3_secrets_raw_secret_name_get200_response import ApiV3SecretsRawSecretNameGet200Response
from infisicalapi_client.models.api_v3_secrets_raw_secret_name_patch_request import ApiV3SecretsRawSecretNamePatchRequest
from infisicalapi_client.models.api_v3_secrets_raw_secret_name_post200_response import ApiV3SecretsRawSecretNamePost200Response
from infisicalapi_client.models.api_v3_secrets_raw_secret_name_post_request import ApiV3SecretsRawSecretNamePostRequest
from infisicalapi_client.models.api_v3_secrets_secret_name_delete_request import ApiV3SecretsSecretNameDeleteRequest
from infisicalapi_client.models.api_v3_secrets_secret_name_get200_response import ApiV3SecretsSecretNameGet200Response
from infisicalapi_client.models.api_v3_secrets_secret_name_patch_request import ApiV3SecretsSecretNamePatchRequest
from infisicalapi_client.models.api_v3_secrets_secret_name_post200_response import ApiV3SecretsSecretNamePost200Response
from infisicalapi_client.models.api_v3_secrets_secret_name_post_request import ApiV3SecretsSecretNamePostRequest
from infisicalapi_client.models.api_v3_secrets_tags_secret_name_delete_request import ApiV3SecretsTagsSecretNameDeleteRequest
from infisicalapi_client.models.api_v3_secrets_tags_secret_name_post200_response import ApiV3SecretsTagsSecretNamePost200Response
from infisicalapi_client.models.api_v3_secrets_tags_secret_name_post_request import ApiV3SecretsTagsSecretNamePostRequest
from infisicalapi_client.models.api_v3_signup_complete_account_signup_post200_response import ApiV3SignupCompleteAccountSignupPost200Response
from infisicalapi_client.models.api_v3_signup_complete_account_signup_post_request import ApiV3SignupCompleteAccountSignupPostRequest
from infisicalapi_client.models.api_v3_signup_email_verify_post200_response import ApiV3SignupEmailVerifyPost200Response
from infisicalapi_client.models.api_v3_users_me_api_keys_get200_response import ApiV3UsersMeApiKeysGet200Response
from infisicalapi_client.models.api_v3_workspaces_project_id_secrets_get200_response import ApiV3WorkspacesProjectIdSecretsGet200Response
from infisicalapi_client.models.api_v3_workspaces_project_id_secrets_names_post_request import ApiV3WorkspacesProjectIdSecretsNamesPostRequest

from infisicalapi_client.api_client import ApiClient
from infisicalapi_client.api_response import ApiResponse
from infisicalapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def api_status_get(self, **kwargs) -> ApiStatusGet200Response:  # noqa: E501
        """api_status_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_status_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiStatusGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_status_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_status_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_status_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_status_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_status_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiStatusGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_status_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiStatusGet200Response",
        }

        return self.api_client.call_api(
            '/api/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_policies_count_get(self, project_slug : StrictStr, env_slug : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response:  # noqa: E501
        """api_v1_access_approvals_policies_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_count_get(project_slug, env_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param env_slug: (required)
        :type env_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_policies_count_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_policies_count_get_with_http_info(project_slug, env_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_policies_count_get_with_http_info(self, project_slug : StrictStr, env_slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_policies_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_count_get_with_http_info(project_slug, env_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param env_slug: (required)
        :type env_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'env_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_policies_count_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        if _params.get('env_slug') is not None:  # noqa: E501
            _query_params.append(('envSlug', _params['env_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/policies/count', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_policies_get(self, project_slug : StrictStr, **kwargs) -> ApiV1AccessApprovalsPoliciesGet200Response:  # noqa: E501
        """api_v1_access_approvals_policies_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_get(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AccessApprovalsPoliciesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_policies_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_policies_get_with_http_info(project_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_policies_get_with_http_info(self, project_slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_policies_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_get_with_http_info(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AccessApprovalsPoliciesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_policies_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AccessApprovalsPoliciesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/policies', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_policies_policy_id_delete(self, policy_id : StrictStr, **kwargs) -> ApiV1SecretApprovalsPost200Response:  # noqa: E501
        """api_v1_access_approvals_policies_policy_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_policy_id_delete(policy_id, async_req=True)
        >>> result = thread.get()

        :param policy_id: (required)
        :type policy_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_policies_policy_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_policies_policy_id_delete_with_http_info(policy_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_policies_policy_id_delete_with_http_info(self, policy_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_policies_policy_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_policy_id_delete_with_http_info(policy_id, async_req=True)
        >>> result = thread.get()

        :param policy_id: (required)
        :type policy_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'policy_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_policies_policy_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['policy_id'] is not None:
            _path_params['policyId'] = _params['policy_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/policies/{policyId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_policies_policy_id_patch(self, policy_id : StrictStr, api_v1_access_approvals_policies_policy_id_patch_request : ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest, **kwargs) -> ApiV1SecretApprovalsPost200Response:  # noqa: E501
        """api_v1_access_approvals_policies_policy_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_policy_id_patch(policy_id, api_v1_access_approvals_policies_policy_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param policy_id: (required)
        :type policy_id: str
        :param api_v1_access_approvals_policies_policy_id_patch_request: (required)
        :type api_v1_access_approvals_policies_policy_id_patch_request: ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_policies_policy_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_policies_policy_id_patch_with_http_info(policy_id, api_v1_access_approvals_policies_policy_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_policies_policy_id_patch_with_http_info(self, policy_id : StrictStr, api_v1_access_approvals_policies_policy_id_patch_request : ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_policies_policy_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_policy_id_patch_with_http_info(policy_id, api_v1_access_approvals_policies_policy_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param policy_id: (required)
        :type policy_id: str
        :param api_v1_access_approvals_policies_policy_id_patch_request: (required)
        :type api_v1_access_approvals_policies_policy_id_patch_request: ApiV1AccessApprovalsPoliciesPolicyIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'policy_id',
            'api_v1_access_approvals_policies_policy_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_policies_policy_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['policy_id'] is not None:
            _path_params['policyId'] = _params['policy_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_access_approvals_policies_policy_id_patch_request'] is not None:
            _body_params = _params['api_v1_access_approvals_policies_policy_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/policies/{policyId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_policies_post(self, api_v1_access_approvals_policies_post_request : ApiV1AccessApprovalsPoliciesPostRequest, **kwargs) -> ApiV1SecretApprovalsPost200Response:  # noqa: E501
        """api_v1_access_approvals_policies_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_post(api_v1_access_approvals_policies_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_access_approvals_policies_post_request: (required)
        :type api_v1_access_approvals_policies_post_request: ApiV1AccessApprovalsPoliciesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_policies_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_policies_post_with_http_info(api_v1_access_approvals_policies_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_policies_post_with_http_info(self, api_v1_access_approvals_policies_post_request : ApiV1AccessApprovalsPoliciesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_policies_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_policies_post_with_http_info(api_v1_access_approvals_policies_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_access_approvals_policies_post_request: (required)
        :type api_v1_access_approvals_policies_post_request: ApiV1AccessApprovalsPoliciesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_access_approvals_policies_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_policies_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_access_approvals_policies_post_request'] is not None:
            _body_params = _params['api_v1_access_approvals_policies_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/policies', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_requests_count_get(self, project_slug : StrictStr, **kwargs) -> ApiV1AccessApprovalsRequestsCountGet200Response:  # noqa: E501
        """api_v1_access_approvals_requests_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_count_get(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AccessApprovalsRequestsCountGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_requests_count_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_requests_count_get_with_http_info(project_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_requests_count_get_with_http_info(self, project_slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_requests_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_count_get_with_http_info(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AccessApprovalsRequestsCountGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_requests_count_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AccessApprovalsRequestsCountGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/requests/count', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_requests_get(self, project_slug : StrictStr, author_project_membership_id : Optional[StrictStr] = None, env_slug : Optional[StrictStr] = None, **kwargs) -> ApiV1AccessApprovalsRequestsGet200Response:  # noqa: E501
        """api_v1_access_approvals_requests_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_get(project_slug, author_project_membership_id, env_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param author_project_membership_id:
        :type author_project_membership_id: str
        :param env_slug:
        :type env_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AccessApprovalsRequestsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_requests_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_requests_get_with_http_info(project_slug, author_project_membership_id, env_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_requests_get_with_http_info(self, project_slug : StrictStr, author_project_membership_id : Optional[StrictStr] = None, env_slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_requests_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_get_with_http_info(project_slug, author_project_membership_id, env_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param author_project_membership_id:
        :type author_project_membership_id: str
        :param env_slug:
        :type env_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AccessApprovalsRequestsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'author_project_membership_id',
            'env_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_requests_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        if _params.get('author_project_membership_id') is not None:  # noqa: E501
            _query_params.append(('authorProjectMembershipId', _params['author_project_membership_id']))

        if _params.get('env_slug') is not None:  # noqa: E501
            _query_params.append(('envSlug', _params['env_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AccessApprovalsRequestsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/requests', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_requests_post(self, project_slug : StrictStr, api_v1_access_approvals_requests_post_request : ApiV1AccessApprovalsRequestsPostRequest, **kwargs) -> ApiV1AccessApprovalsRequestsPost200Response:  # noqa: E501
        """api_v1_access_approvals_requests_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_post(project_slug, api_v1_access_approvals_requests_post_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param api_v1_access_approvals_requests_post_request: (required)
        :type api_v1_access_approvals_requests_post_request: ApiV1AccessApprovalsRequestsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AccessApprovalsRequestsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_requests_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_requests_post_with_http_info(project_slug, api_v1_access_approvals_requests_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_requests_post_with_http_info(self, project_slug : StrictStr, api_v1_access_approvals_requests_post_request : ApiV1AccessApprovalsRequestsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_requests_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_post_with_http_info(project_slug, api_v1_access_approvals_requests_post_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: (required)
        :type project_slug: str
        :param api_v1_access_approvals_requests_post_request: (required)
        :type api_v1_access_approvals_requests_post_request: ApiV1AccessApprovalsRequestsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AccessApprovalsRequestsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'api_v1_access_approvals_requests_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_requests_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_access_approvals_requests_post_request'] is not None:
            _body_params = _params['api_v1_access_approvals_requests_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AccessApprovalsRequestsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/requests', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_access_approvals_requests_request_id_review_post(self, request_id : StrictStr, api_v1_secret_approval_requests_id_review_post_request : ApiV1SecretApprovalRequestsIdReviewPostRequest, **kwargs) -> ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response:  # noqa: E501
        """api_v1_access_approvals_requests_request_id_review_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_request_id_review_post(request_id, api_v1_secret_approval_requests_id_review_post_request, async_req=True)
        >>> result = thread.get()

        :param request_id: (required)
        :type request_id: str
        :param api_v1_secret_approval_requests_id_review_post_request: (required)
        :type api_v1_secret_approval_requests_id_review_post_request: ApiV1SecretApprovalRequestsIdReviewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_access_approvals_requests_request_id_review_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_access_approvals_requests_request_id_review_post_with_http_info(request_id, api_v1_secret_approval_requests_id_review_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_access_approvals_requests_request_id_review_post_with_http_info(self, request_id : StrictStr, api_v1_secret_approval_requests_id_review_post_request : ApiV1SecretApprovalRequestsIdReviewPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_access_approvals_requests_request_id_review_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_access_approvals_requests_request_id_review_post_with_http_info(request_id, api_v1_secret_approval_requests_id_review_post_request, async_req=True)
        >>> result = thread.get()

        :param request_id: (required)
        :type request_id: str
        :param api_v1_secret_approval_requests_id_review_post_request: (required)
        :type api_v1_secret_approval_requests_id_review_post_request: ApiV1SecretApprovalRequestsIdReviewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'request_id',
            'api_v1_secret_approval_requests_id_review_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_access_approvals_requests_request_id_review_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['request_id'] is not None:
            _path_params['requestId'] = _params['request_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_approval_requests_id_review_post_request'] is not None:
            _body_params = _params['api_v1_secret_approval_requests_id_review_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AccessApprovalsRequestsRequestIdReviewPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/access-approvals/requests/{requestId}/review', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_identity_delete(self, api_v1_additional_privilege_identity_delete_request : ApiV1AdditionalPrivilegeIdentityDeleteRequest, **kwargs) -> ApiV1AdditionalPrivilegeIdentityPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_identity_delete  # noqa: E501

        Delete a specific privilege of an identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_delete(api_v1_additional_privilege_identity_delete_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_delete_request: (required)
        :type api_v1_additional_privilege_identity_delete_request: ApiV1AdditionalPrivilegeIdentityDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeIdentityPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_identity_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_identity_delete_with_http_info(api_v1_additional_privilege_identity_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_identity_delete_with_http_info(self, api_v1_additional_privilege_identity_delete_request : ApiV1AdditionalPrivilegeIdentityDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_identity_delete  # noqa: E501

        Delete a specific privilege of an identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_delete_with_http_info(api_v1_additional_privilege_identity_delete_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_delete_request: (required)
        :type api_v1_additional_privilege_identity_delete_request: ApiV1AdditionalPrivilegeIdentityDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeIdentityPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_additional_privilege_identity_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_identity_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_identity_delete_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_identity_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeIdentityPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/identity', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_identity_get(self, identity_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the identity to list.")], project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project of the identity in.")], **kwargs) -> ApiV1AdditionalPrivilegeIdentityGet200Response:  # noqa: E501
        """api_v1_additional_privilege_identity_get  # noqa: E501

        List of a specific privilege of an identity in a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_get(identity_id, project_slug, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list. (required)
        :type identity_id: str
        :param project_slug: The slug of the project of the identity in. (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeIdentityGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_identity_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_identity_get_with_http_info(identity_id, project_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_identity_get_with_http_info(self, identity_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the identity to list.")], project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project of the identity in.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_identity_get  # noqa: E501

        List of a specific privilege of an identity in a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_get_with_http_info(identity_id, project_slug, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list. (required)
        :type identity_id: str
        :param project_slug: The slug of the project of the identity in. (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeIdentityGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'project_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_identity_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('identity_id') is not None:  # noqa: E501
            _query_params.append(('identityId', _params['identity_id']))

        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeIdentityGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/identity', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_identity_patch(self, api_v1_additional_privilege_identity_patch_request : ApiV1AdditionalPrivilegeIdentityPatchRequest, **kwargs) -> ApiV1AdditionalPrivilegeIdentityPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_identity_patch  # noqa: E501

        Update a specific privilege of an identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_patch(api_v1_additional_privilege_identity_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_patch_request: (required)
        :type api_v1_additional_privilege_identity_patch_request: ApiV1AdditionalPrivilegeIdentityPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeIdentityPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_identity_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_identity_patch_with_http_info(api_v1_additional_privilege_identity_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_identity_patch_with_http_info(self, api_v1_additional_privilege_identity_patch_request : ApiV1AdditionalPrivilegeIdentityPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_identity_patch  # noqa: E501

        Update a specific privilege of an identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_patch_with_http_info(api_v1_additional_privilege_identity_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_patch_request: (required)
        :type api_v1_additional_privilege_identity_patch_request: ApiV1AdditionalPrivilegeIdentityPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeIdentityPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_additional_privilege_identity_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_identity_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_identity_patch_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_identity_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeIdentityPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/identity', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_identity_permanent_post(self, api_v1_additional_privilege_identity_permanent_post_request : ApiV1AdditionalPrivilegeIdentityPermanentPostRequest, **kwargs) -> ApiV1AdditionalPrivilegeIdentityPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_identity_permanent_post  # noqa: E501

        Create a permanent or a non expiry specific privilege for identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_permanent_post(api_v1_additional_privilege_identity_permanent_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_permanent_post_request: (required)
        :type api_v1_additional_privilege_identity_permanent_post_request: ApiV1AdditionalPrivilegeIdentityPermanentPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeIdentityPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_identity_permanent_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_identity_permanent_post_with_http_info(api_v1_additional_privilege_identity_permanent_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_identity_permanent_post_with_http_info(self, api_v1_additional_privilege_identity_permanent_post_request : ApiV1AdditionalPrivilegeIdentityPermanentPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_identity_permanent_post  # noqa: E501

        Create a permanent or a non expiry specific privilege for identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_permanent_post_with_http_info(api_v1_additional_privilege_identity_permanent_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_permanent_post_request: (required)
        :type api_v1_additional_privilege_identity_permanent_post_request: ApiV1AdditionalPrivilegeIdentityPermanentPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeIdentityPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_additional_privilege_identity_permanent_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_identity_permanent_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_identity_permanent_post_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_identity_permanent_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeIdentityPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/identity/permanent', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_identity_privilege_slug_get(self, identity_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the identity to list.")], project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project of the identity in.")], privilege_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the privilege.")], **kwargs) -> ApiV1AdditionalPrivilegeIdentityPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_identity_privilege_slug_get  # noqa: E501

        Retrieve details of a specific privilege by privilege slug.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_privilege_slug_get(identity_id, project_slug, privilege_slug, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list. (required)
        :type identity_id: str
        :param project_slug: The slug of the project of the identity in. (required)
        :type project_slug: str
        :param privilege_slug: The slug of the privilege. (required)
        :type privilege_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeIdentityPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_identity_privilege_slug_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_identity_privilege_slug_get_with_http_info(identity_id, project_slug, privilege_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_identity_privilege_slug_get_with_http_info(self, identity_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the identity to list.")], project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project of the identity in.")], privilege_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the privilege.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_identity_privilege_slug_get  # noqa: E501

        Retrieve details of a specific privilege by privilege slug.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_privilege_slug_get_with_http_info(identity_id, project_slug, privilege_slug, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list. (required)
        :type identity_id: str
        :param project_slug: The slug of the project of the identity in. (required)
        :type project_slug: str
        :param privilege_slug: The slug of the privilege. (required)
        :type privilege_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeIdentityPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'project_slug',
            'privilege_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_identity_privilege_slug_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['privilege_slug'] is not None:
            _path_params['privilegeSlug'] = _params['privilege_slug']


        # process the query parameters
        _query_params = []
        if _params.get('identity_id') is not None:  # noqa: E501
            _query_params.append(('identityId', _params['identity_id']))

        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeIdentityPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/identity/{privilegeSlug}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_identity_temporary_post(self, api_v1_additional_privilege_identity_temporary_post_request : ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest, **kwargs) -> ApiV1AdditionalPrivilegeIdentityPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_identity_temporary_post  # noqa: E501

        Create a temporary or a expiring specific privilege for identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_temporary_post(api_v1_additional_privilege_identity_temporary_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_temporary_post_request: (required)
        :type api_v1_additional_privilege_identity_temporary_post_request: ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeIdentityPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_identity_temporary_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_identity_temporary_post_with_http_info(api_v1_additional_privilege_identity_temporary_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_identity_temporary_post_with_http_info(self, api_v1_additional_privilege_identity_temporary_post_request : ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_identity_temporary_post  # noqa: E501

        Create a temporary or a expiring specific privilege for identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_identity_temporary_post_with_http_info(api_v1_additional_privilege_identity_temporary_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_identity_temporary_post_request: (required)
        :type api_v1_additional_privilege_identity_temporary_post_request: ApiV1AdditionalPrivilegeIdentityTemporaryPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeIdentityPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_additional_privilege_identity_temporary_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_identity_temporary_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_identity_temporary_post_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_identity_temporary_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeIdentityPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/identity/temporary', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_users_get(self, project_membership_id : Annotated[StrictStr, Field(..., description="Project membership id of user")], **kwargs) -> ApiV1AdditionalPrivilegeUsersGet200Response:  # noqa: E501
        """api_v1_additional_privilege_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_get(project_membership_id, async_req=True)
        >>> result = thread.get()

        :param project_membership_id: Project membership id of user (required)
        :type project_membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeUsersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_users_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_users_get_with_http_info(project_membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_users_get_with_http_info(self, project_membership_id : Annotated[StrictStr, Field(..., description="Project membership id of user")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_get_with_http_info(project_membership_id, async_req=True)
        >>> result = thread.get()

        :param project_membership_id: Project membership id of user (required)
        :type project_membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeUsersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_membership_id') is not None:  # noqa: E501
            _query_params.append(('projectMembershipId', _params['project_membership_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeUsersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_users_permanent_post(self, api_v1_additional_privilege_users_permanent_post_request : ApiV1AdditionalPrivilegeUsersPermanentPostRequest, **kwargs) -> ApiV1AdditionalPrivilegeUsersPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_users_permanent_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_permanent_post(api_v1_additional_privilege_users_permanent_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_users_permanent_post_request: (required)
        :type api_v1_additional_privilege_users_permanent_post_request: ApiV1AdditionalPrivilegeUsersPermanentPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeUsersPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_users_permanent_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_users_permanent_post_with_http_info(api_v1_additional_privilege_users_permanent_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_users_permanent_post_with_http_info(self, api_v1_additional_privilege_users_permanent_post_request : ApiV1AdditionalPrivilegeUsersPermanentPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_users_permanent_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_permanent_post_with_http_info(api_v1_additional_privilege_users_permanent_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_users_permanent_post_request: (required)
        :type api_v1_additional_privilege_users_permanent_post_request: ApiV1AdditionalPrivilegeUsersPermanentPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeUsersPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_additional_privilege_users_permanent_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_users_permanent_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_users_permanent_post_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_users_permanent_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeUsersPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/users/permanent', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_users_privilege_id_delete(self, privilege_id : Annotated[StrictStr, Field(..., description="The id of privilege object")], **kwargs) -> ApiV1AdditionalPrivilegeUsersPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_users_privilege_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_privilege_id_delete(privilege_id, async_req=True)
        >>> result = thread.get()

        :param privilege_id: The id of privilege object (required)
        :type privilege_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeUsersPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_users_privilege_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_users_privilege_id_delete_with_http_info(privilege_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_users_privilege_id_delete_with_http_info(self, privilege_id : Annotated[StrictStr, Field(..., description="The id of privilege object")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_users_privilege_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_privilege_id_delete_with_http_info(privilege_id, async_req=True)
        >>> result = thread.get()

        :param privilege_id: The id of privilege object (required)
        :type privilege_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeUsersPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'privilege_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_users_privilege_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['privilege_id'] is not None:
            _path_params['privilegeId'] = _params['privilege_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeUsersPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/users/{privilegeId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_users_privilege_id_get(self, privilege_id : Annotated[StrictStr, Field(..., description="The id of privilege object")], **kwargs) -> ApiV1AdditionalPrivilegeUsersPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_users_privilege_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_privilege_id_get(privilege_id, async_req=True)
        >>> result = thread.get()

        :param privilege_id: The id of privilege object (required)
        :type privilege_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeUsersPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_users_privilege_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_users_privilege_id_get_with_http_info(privilege_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_users_privilege_id_get_with_http_info(self, privilege_id : Annotated[StrictStr, Field(..., description="The id of privilege object")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_users_privilege_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_privilege_id_get_with_http_info(privilege_id, async_req=True)
        >>> result = thread.get()

        :param privilege_id: The id of privilege object (required)
        :type privilege_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeUsersPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'privilege_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_users_privilege_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['privilege_id'] is not None:
            _path_params['privilegeId'] = _params['privilege_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeUsersPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/users/{privilegeId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_users_privilege_id_patch(self, privilege_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The id of privilege object")], api_v1_additional_privilege_users_privilege_id_patch_request : Optional[ApiV1AdditionalPrivilegeUsersPrivilegeIdPatchRequest] = None, **kwargs) -> ApiV1AdditionalPrivilegeUsersPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_users_privilege_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_privilege_id_patch(privilege_id, api_v1_additional_privilege_users_privilege_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param privilege_id: The id of privilege object (required)
        :type privilege_id: str
        :param api_v1_additional_privilege_users_privilege_id_patch_request:
        :type api_v1_additional_privilege_users_privilege_id_patch_request: ApiV1AdditionalPrivilegeUsersPrivilegeIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeUsersPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_users_privilege_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_users_privilege_id_patch_with_http_info(privilege_id, api_v1_additional_privilege_users_privilege_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_users_privilege_id_patch_with_http_info(self, privilege_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The id of privilege object")], api_v1_additional_privilege_users_privilege_id_patch_request : Optional[ApiV1AdditionalPrivilegeUsersPrivilegeIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_users_privilege_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_privilege_id_patch_with_http_info(privilege_id, api_v1_additional_privilege_users_privilege_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param privilege_id: The id of privilege object (required)
        :type privilege_id: str
        :param api_v1_additional_privilege_users_privilege_id_patch_request:
        :type api_v1_additional_privilege_users_privilege_id_patch_request: ApiV1AdditionalPrivilegeUsersPrivilegeIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeUsersPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'privilege_id',
            'api_v1_additional_privilege_users_privilege_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_users_privilege_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['privilege_id'] is not None:
            _path_params['privilegeId'] = _params['privilege_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_users_privilege_id_patch_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_users_privilege_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeUsersPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/users/{privilegeId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_additional_privilege_users_temporary_post(self, api_v1_additional_privilege_users_temporary_post_request : ApiV1AdditionalPrivilegeUsersTemporaryPostRequest, **kwargs) -> ApiV1AdditionalPrivilegeUsersPermanentPost200Response:  # noqa: E501
        """api_v1_additional_privilege_users_temporary_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_temporary_post(api_v1_additional_privilege_users_temporary_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_users_temporary_post_request: (required)
        :type api_v1_additional_privilege_users_temporary_post_request: ApiV1AdditionalPrivilegeUsersTemporaryPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdditionalPrivilegeUsersPermanentPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_additional_privilege_users_temporary_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_additional_privilege_users_temporary_post_with_http_info(api_v1_additional_privilege_users_temporary_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_additional_privilege_users_temporary_post_with_http_info(self, api_v1_additional_privilege_users_temporary_post_request : ApiV1AdditionalPrivilegeUsersTemporaryPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_additional_privilege_users_temporary_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_additional_privilege_users_temporary_post_with_http_info(api_v1_additional_privilege_users_temporary_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_additional_privilege_users_temporary_post_request: (required)
        :type api_v1_additional_privilege_users_temporary_post_request: ApiV1AdditionalPrivilegeUsersTemporaryPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdditionalPrivilegeUsersPermanentPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_additional_privilege_users_temporary_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_additional_privilege_users_temporary_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_additional_privilege_users_temporary_post_request'] is not None:
            _body_params = _params['api_v1_additional_privilege_users_temporary_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdditionalPrivilegeUsersPermanentPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/additional-privilege/users/temporary', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_admin_config_get(self, **kwargs) -> ApiV1AdminConfigGet200Response:  # noqa: E501
        """api_v1_admin_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_config_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdminConfigGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_admin_config_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_admin_config_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_admin_config_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_admin_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_config_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdminConfigGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_admin_config_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdminConfigGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/admin/config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_admin_config_patch(self, api_v1_admin_config_patch_request : Optional[ApiV1AdminConfigPatchRequest] = None, **kwargs) -> ApiV1AdminConfigPatch200Response:  # noqa: E501
        """api_v1_admin_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_config_patch(api_v1_admin_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_admin_config_patch_request:
        :type api_v1_admin_config_patch_request: ApiV1AdminConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdminConfigPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_admin_config_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_admin_config_patch_with_http_info(api_v1_admin_config_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_admin_config_patch_with_http_info(self, api_v1_admin_config_patch_request : Optional[ApiV1AdminConfigPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_admin_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_config_patch_with_http_info(api_v1_admin_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_admin_config_patch_request:
        :type api_v1_admin_config_patch_request: ApiV1AdminConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdminConfigPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_admin_config_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_admin_config_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_admin_config_patch_request'] is not None:
            _body_params = _params['api_v1_admin_config_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdminConfigPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v1/admin/config', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_admin_signup_post(self, api_v1_admin_signup_post_request : ApiV1AdminSignupPostRequest, **kwargs) -> ApiV1AdminSignupPost200Response:  # noqa: E501
        """api_v1_admin_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_signup_post(api_v1_admin_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_admin_signup_post_request: (required)
        :type api_v1_admin_signup_post_request: ApiV1AdminSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdminSignupPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_admin_signup_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_admin_signup_post_with_http_info(api_v1_admin_signup_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_admin_signup_post_with_http_info(self, api_v1_admin_signup_post_request : ApiV1AdminSignupPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_admin_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_signup_post_with_http_info(api_v1_admin_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_admin_signup_post_request: (required)
        :type api_v1_admin_signup_post_request: ApiV1AdminSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdminSignupPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_admin_signup_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_admin_signup_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_admin_signup_post_request'] is not None:
            _body_params = _params['api_v1_admin_signup_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdminSignupPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/admin/signup', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_admin_user_management_users_get(self, search_term : Optional[StrictStr] = None, offset : Optional[Union[StrictFloat, StrictInt]] = None, limit : Optional[Union[confloat(le=100, strict=True), conint(le=100.0, strict=True)]] = None, **kwargs) -> ApiV1AdminUserManagementUsersGet200Response:  # noqa: E501
        """api_v1_admin_user_management_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_user_management_users_get(search_term, offset, limit, async_req=True)
        >>> result = thread.get()

        :param search_term:
        :type search_term: str
        :param offset:
        :type offset: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdminUserManagementUsersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_admin_user_management_users_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_admin_user_management_users_get_with_http_info(search_term, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_admin_user_management_users_get_with_http_info(self, search_term : Optional[StrictStr] = None, offset : Optional[Union[StrictFloat, StrictInt]] = None, limit : Optional[Union[confloat(le=100, strict=True), conint(le=100.0, strict=True)]] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_admin_user_management_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_user_management_users_get_with_http_info(search_term, offset, limit, async_req=True)
        >>> result = thread.get()

        :param search_term:
        :type search_term: str
        :param offset:
        :type offset: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdminUserManagementUsersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'search_term',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_admin_user_management_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('search_term') is not None:  # noqa: E501
            _query_params.append(('searchTerm', _params['search_term']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdminUserManagementUsersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/admin/user-management/users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_admin_user_management_users_user_id_delete(self, user_id : StrictStr, **kwargs) -> ApiV1AdminUserManagementUsersUserIdDelete200Response:  # noqa: E501
        """api_v1_admin_user_management_users_user_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_user_management_users_user_id_delete(user_id, async_req=True)
        >>> result = thread.get()

        :param user_id: (required)
        :type user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AdminUserManagementUsersUserIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_admin_user_management_users_user_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_admin_user_management_users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_admin_user_management_users_user_id_delete_with_http_info(self, user_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_admin_user_management_users_user_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_admin_user_management_users_user_id_delete_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param user_id: (required)
        :type user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AdminUserManagementUsersUserIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'user_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_admin_user_management_users_user_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['user_id'] is not None:
            _path_params['userId'] = _params['user_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AdminUserManagementUsersUserIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/admin/user-management/users/{userId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_audit_log_streams_get(self, **kwargs) -> ApiV1AuditLogStreamsGet200Response:  # noqa: E501
        """api_v1_audit_log_streams_get  # noqa: E501

        List Audit Log Streams.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuditLogStreamsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_audit_log_streams_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_audit_log_streams_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_audit_log_streams_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_audit_log_streams_get  # noqa: E501

        List Audit Log Streams.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuditLogStreamsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audit_log_streams_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuditLogStreamsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/audit-log-streams', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_audit_log_streams_id_delete(self, id : Annotated[StrictStr, Field(..., description="The ID of the audit log stream to delete.")], **kwargs) -> ApiV1AuditLogStreamsPost200Response:  # noqa: E501
        """api_v1_audit_log_streams_id_delete  # noqa: E501

        Delete an Audit Log Stream by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the audit log stream to delete. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuditLogStreamsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_audit_log_streams_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_audit_log_streams_id_delete_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_audit_log_streams_id_delete_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the audit log stream to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_audit_log_streams_id_delete  # noqa: E501

        Delete an Audit Log Stream by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the audit log stream to delete. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuditLogStreamsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audit_log_streams_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuditLogStreamsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/audit-log-streams/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_audit_log_streams_id_get(self, id : Annotated[StrictStr, Field(..., description="The ID of the audit log stream to get details.")], **kwargs) -> ApiV1AuditLogStreamsIdGet200Response:  # noqa: E501
        """api_v1_audit_log_streams_id_get  # noqa: E501

        Get an Audit Log Stream by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the audit log stream to get details. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuditLogStreamsIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_audit_log_streams_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_audit_log_streams_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_audit_log_streams_id_get_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the audit log stream to get details.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_audit_log_streams_id_get  # noqa: E501

        Get an Audit Log Stream by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the audit log stream to get details. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuditLogStreamsIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audit_log_streams_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuditLogStreamsIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/audit-log-streams/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_audit_log_streams_id_patch(self, id : Annotated[StrictStr, Field(..., description="The ID of the audit log stream to update.")], api_v1_audit_log_streams_id_patch_request : Optional[ApiV1AuditLogStreamsIdPatchRequest] = None, **kwargs) -> ApiV1AuditLogStreamsPost200Response:  # noqa: E501
        """api_v1_audit_log_streams_id_patch  # noqa: E501

        Update an Audit Log Stream by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_id_patch(id, api_v1_audit_log_streams_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the audit log stream to update. (required)
        :type id: str
        :param api_v1_audit_log_streams_id_patch_request:
        :type api_v1_audit_log_streams_id_patch_request: ApiV1AuditLogStreamsIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuditLogStreamsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_audit_log_streams_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_audit_log_streams_id_patch_with_http_info(id, api_v1_audit_log_streams_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_audit_log_streams_id_patch_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The ID of the audit log stream to update.")], api_v1_audit_log_streams_id_patch_request : Optional[ApiV1AuditLogStreamsIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_audit_log_streams_id_patch  # noqa: E501

        Update an Audit Log Stream by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_id_patch_with_http_info(id, api_v1_audit_log_streams_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the audit log stream to update. (required)
        :type id: str
        :param api_v1_audit_log_streams_id_patch_request:
        :type api_v1_audit_log_streams_id_patch_request: ApiV1AuditLogStreamsIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuditLogStreamsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'api_v1_audit_log_streams_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audit_log_streams_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_audit_log_streams_id_patch_request'] is not None:
            _body_params = _params['api_v1_audit_log_streams_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuditLogStreamsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/audit-log-streams/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_audit_log_streams_post(self, api_v1_audit_log_streams_post_request : ApiV1AuditLogStreamsPostRequest, **kwargs) -> ApiV1AuditLogStreamsPost200Response:  # noqa: E501
        """api_v1_audit_log_streams_post  # noqa: E501

        Create an Audit Log Stream.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_post(api_v1_audit_log_streams_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_audit_log_streams_post_request: (required)
        :type api_v1_audit_log_streams_post_request: ApiV1AuditLogStreamsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuditLogStreamsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_audit_log_streams_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_audit_log_streams_post_with_http_info(api_v1_audit_log_streams_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_audit_log_streams_post_with_http_info(self, api_v1_audit_log_streams_post_request : ApiV1AuditLogStreamsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_audit_log_streams_post  # noqa: E501

        Create an Audit Log Stream.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_audit_log_streams_post_with_http_info(api_v1_audit_log_streams_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_audit_log_streams_post_request: (required)
        :type api_v1_audit_log_streams_post_request: ApiV1AuditLogStreamsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuditLogStreamsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_audit_log_streams_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_audit_log_streams_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_audit_log_streams_post_request'] is not None:
            _body_params = _params['api_v1_audit_log_streams_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuditLogStreamsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/audit-log-streams', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_delete  # noqa: E501

        Delete AWS Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_aws_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_aws_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_delete  # noqa: E501

        Delete AWS Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_aws_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/aws-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_get  # noqa: E501

        Retrieve AWS Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_aws_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_aws_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_get  # noqa: E501

        Retrieve AWS Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_aws_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/aws-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_aws_auth_identities_identity_id_patch_request : Optional[ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_patch  # noqa: E501

        Update AWS Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_patch(identity_id, api_v1_auth_aws_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_aws_auth_identities_identity_id_patch_request:
        :type api_v1_auth_aws_auth_identities_identity_id_patch_request: ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_aws_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_aws_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_aws_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_aws_auth_identities_identity_id_patch_request : Optional[ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_patch  # noqa: E501

        Update AWS Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_aws_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_aws_auth_identities_identity_id_patch_request:
        :type api_v1_auth_aws_auth_identities_identity_id_patch_request: ApiV1AuthAwsAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_aws_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_aws_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_aws_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_aws_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/aws-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_aws_auth_identities_identity_id_post_request : Optional[ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest] = None, **kwargs) -> ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_post  # noqa: E501

        Attach AWS Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_post(identity_id, api_v1_auth_aws_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_aws_auth_identities_identity_id_post_request:
        :type api_v1_auth_aws_auth_identities_identity_id_post_request: ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_aws_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_aws_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_aws_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_aws_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_aws_auth_identities_identity_id_post_request : Optional[ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_aws_auth_identities_identity_id_post  # noqa: E501

        Attach AWS Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_aws_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_aws_auth_identities_identity_id_post_request:
        :type api_v1_auth_aws_auth_identities_identity_id_post_request: ApiV1AuthAwsAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_aws_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_aws_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_aws_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_aws_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAwsAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/aws-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_aws_auth_login_post(self, api_v1_auth_aws_auth_login_post_request : ApiV1AuthAwsAuthLoginPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_aws_auth_login_post  # noqa: E501

        Login with AWS Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_login_post(api_v1_auth_aws_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_aws_auth_login_post_request: (required)
        :type api_v1_auth_aws_auth_login_post_request: ApiV1AuthAwsAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_aws_auth_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_aws_auth_login_post_with_http_info(api_v1_auth_aws_auth_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_aws_auth_login_post_with_http_info(self, api_v1_auth_aws_auth_login_post_request : ApiV1AuthAwsAuthLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_aws_auth_login_post  # noqa: E501

        Login with AWS Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_aws_auth_login_post_with_http_info(api_v1_auth_aws_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_aws_auth_login_post_request: (required)
        :type api_v1_auth_aws_auth_login_post_request: ApiV1AuthAwsAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_aws_auth_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_aws_auth_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_aws_auth_login_post_request'] is not None:
            _body_params = _params['api_v1_auth_aws_auth_login_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/aws-auth/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_delete  # noqa: E501

        Delete Azure Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_azure_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_azure_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_delete  # noqa: E501

        Delete Azure Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_azure_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/azure-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_get  # noqa: E501

        Retrieve Azure Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_azure_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_azure_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_get  # noqa: E501

        Retrieve Azure Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_azure_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/azure-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_azure_auth_identities_identity_id_patch_request : Optional[ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_patch  # noqa: E501

        Update Azure Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_patch(identity_id, api_v1_auth_azure_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_azure_auth_identities_identity_id_patch_request:
        :type api_v1_auth_azure_auth_identities_identity_id_patch_request: ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_azure_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_azure_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_azure_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_azure_auth_identities_identity_id_patch_request : Optional[ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_patch  # noqa: E501

        Update Azure Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_azure_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_azure_auth_identities_identity_id_patch_request:
        :type api_v1_auth_azure_auth_identities_identity_id_patch_request: ApiV1AuthAzureAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_azure_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_azure_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_azure_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_azure_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/azure-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to login.")], api_v1_auth_azure_auth_identities_identity_id_post_request : ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_post  # noqa: E501

        Attach Azure Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_post(identity_id, api_v1_auth_azure_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to login. (required)
        :type identity_id: str
        :param api_v1_auth_azure_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_azure_auth_identities_identity_id_post_request: ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_azure_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_azure_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_azure_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_azure_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to login.")], api_v1_auth_azure_auth_identities_identity_id_post_request : ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_azure_auth_identities_identity_id_post  # noqa: E501

        Attach Azure Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_azure_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to login. (required)
        :type identity_id: str
        :param api_v1_auth_azure_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_azure_auth_identities_identity_id_post_request: ApiV1AuthAzureAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_azure_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_azure_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_azure_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_azure_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthAzureAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/azure-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_azure_auth_login_post(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_azure_auth_login_post  # noqa: E501

        Login with Azure Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_login_post(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_azure_auth_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_azure_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_azure_auth_login_post_with_http_info(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_azure_auth_login_post  # noqa: E501

        Login with Azure Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_azure_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_kubernetes_auth_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_azure_auth_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_kubernetes_auth_login_post_request'] is not None:
            _body_params = _params['api_v1_auth_kubernetes_auth_login_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/azure-auth/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_check_auth_post(self, **kwargs) -> ApiV1AuthCheckAuthPost200Response:  # noqa: E501
        """api_v1_auth_check_auth_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_check_auth_post(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthCheckAuthPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_check_auth_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_check_auth_post_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_check_auth_post_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_check_auth_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_check_auth_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthCheckAuthPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_check_auth_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthCheckAuthPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/checkAuth', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_delete  # noqa: E501

        Delete GCP Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_gcp_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_gcp_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_delete  # noqa: E501

        Delete GCP Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_gcp_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/gcp-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_get  # noqa: E501

        Retrieve GCP Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_gcp_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_gcp_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_get  # noqa: E501

        Retrieve GCP Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_gcp_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/gcp-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_gcp_auth_identities_identity_id_patch_request : Optional[ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_patch  # noqa: E501

        Update GCP Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_patch(identity_id, api_v1_auth_gcp_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_gcp_auth_identities_identity_id_patch_request:
        :type api_v1_auth_gcp_auth_identities_identity_id_patch_request: ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_gcp_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_gcp_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_gcp_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_gcp_auth_identities_identity_id_patch_request : Optional[ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_patch  # noqa: E501

        Update GCP Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_gcp_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_gcp_auth_identities_identity_id_patch_request:
        :type api_v1_auth_gcp_auth_identities_identity_id_patch_request: ApiV1AuthGcpAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_gcp_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_gcp_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_gcp_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_gcp_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/gcp-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_gcp_auth_identities_identity_id_post_request : ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_post  # noqa: E501

        Attach GCP Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_post(identity_id, api_v1_auth_gcp_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_gcp_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_gcp_auth_identities_identity_id_post_request: ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_gcp_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_gcp_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_gcp_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_gcp_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_gcp_auth_identities_identity_id_post_request : ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_gcp_auth_identities_identity_id_post  # noqa: E501

        Attach GCP Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_gcp_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_gcp_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_gcp_auth_identities_identity_id_post_request: ApiV1AuthGcpAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_gcp_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_gcp_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_gcp_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_gcp_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthGcpAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/gcp-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_gcp_auth_login_post(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_gcp_auth_login_post  # noqa: E501

        Login with GCP Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_login_post(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_gcp_auth_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_gcp_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_gcp_auth_login_post_with_http_info(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_gcp_auth_login_post  # noqa: E501

        Login with GCP Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_gcp_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_kubernetes_auth_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_gcp_auth_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_kubernetes_auth_login_post_request'] is not None:
            _body_params = _params['api_v1_auth_kubernetes_auth_login_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/gcp-auth/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_delete  # noqa: E501

        Delete Kubernetes Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_kubernetes_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_kubernetes_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_delete  # noqa: E501

        Delete Kubernetes Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_kubernetes_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthKubernetesAuthIdentitiesIdentityIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/kubernetes-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_get  # noqa: E501

        Retrieve Kubernetes Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_kubernetes_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_kubernetes_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_get  # noqa: E501

        Retrieve Kubernetes Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_kubernetes_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/kubernetes-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_kubernetes_auth_identities_identity_id_patch_request : Optional[ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_patch  # noqa: E501

        Update Kubernetes Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_patch(identity_id, api_v1_auth_kubernetes_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_kubernetes_auth_identities_identity_id_patch_request:
        :type api_v1_auth_kubernetes_auth_identities_identity_id_patch_request: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_kubernetes_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_kubernetes_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_kubernetes_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_kubernetes_auth_identities_identity_id_patch_request : Optional[ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_patch  # noqa: E501

        Update Kubernetes Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_kubernetes_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_kubernetes_auth_identities_identity_id_patch_request:
        :type api_v1_auth_kubernetes_auth_identities_identity_id_patch_request: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_kubernetes_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_kubernetes_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_kubernetes_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_kubernetes_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/kubernetes-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_kubernetes_auth_identities_identity_id_post_request : ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_post  # noqa: E501

        Attach Kubernetes Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_post(identity_id, api_v1_auth_kubernetes_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_kubernetes_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_kubernetes_auth_identities_identity_id_post_request: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_kubernetes_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_kubernetes_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_kubernetes_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_kubernetes_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_kubernetes_auth_identities_identity_id_post_request : ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_kubernetes_auth_identities_identity_id_post  # noqa: E501

        Attach Kubernetes Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_kubernetes_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_kubernetes_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_kubernetes_auth_identities_identity_id_post_request: ApiV1AuthKubernetesAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_kubernetes_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_kubernetes_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_kubernetes_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_kubernetes_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthKubernetesAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/kubernetes-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_kubernetes_auth_login_post(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_kubernetes_auth_login_post  # noqa: E501

        Login with Kubernetes Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_login_post(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_kubernetes_auth_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_kubernetes_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_kubernetes_auth_login_post_with_http_info(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_kubernetes_auth_login_post  # noqa: E501

        Login with Kubernetes Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_kubernetes_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_kubernetes_auth_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_kubernetes_auth_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_kubernetes_auth_login_post_request'] is not None:
            _body_params = _params['api_v1_auth_kubernetes_auth_login_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/kubernetes-auth/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_logout_post(self, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_auth_logout_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_logout_post(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_logout_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_logout_post_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_logout_post_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_logout_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_logout_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_logout_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/logout', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_delete  # noqa: E501

        Delete OIDC Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_oidc_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_oidc_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_delete  # noqa: E501

        Delete OIDC Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_oidc_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthOidcAuthIdentitiesIdentityIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/oidc-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_get  # noqa: E501

        Retrieve OIDC Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_oidc_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_oidc_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_get  # noqa: E501

        Retrieve OIDC Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_oidc_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/oidc-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_oidc_auth_identities_identity_id_patch_request : Optional[ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_patch  # noqa: E501

        Update OIDC Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_patch(identity_id, api_v1_auth_oidc_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_oidc_auth_identities_identity_id_patch_request:
        :type api_v1_auth_oidc_auth_identities_identity_id_patch_request: ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_oidc_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_oidc_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_oidc_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_oidc_auth_identities_identity_id_patch_request : Optional[ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_patch  # noqa: E501

        Update OIDC Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_oidc_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_oidc_auth_identities_identity_id_patch_request:
        :type api_v1_auth_oidc_auth_identities_identity_id_patch_request: ApiV1AuthOidcAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_oidc_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_oidc_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_oidc_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_oidc_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/oidc-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_oidc_auth_identities_identity_id_post_request : ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_post  # noqa: E501

        Attach OIDC Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_post(identity_id, api_v1_auth_oidc_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_oidc_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_oidc_auth_identities_identity_id_post_request: ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_oidc_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_oidc_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_oidc_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_oidc_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_oidc_auth_identities_identity_id_post_request : ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_oidc_auth_identities_identity_id_post  # noqa: E501

        Attach OIDC Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_oidc_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_oidc_auth_identities_identity_id_post_request: (required)
        :type api_v1_auth_oidc_auth_identities_identity_id_post_request: ApiV1AuthOidcAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_oidc_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_oidc_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_oidc_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_oidc_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthOidcAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/oidc-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_oidc_auth_login_post(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_oidc_auth_login_post  # noqa: E501

        Login with OIDC Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_login_post(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_oidc_auth_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_oidc_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_oidc_auth_login_post_with_http_info(self, api_v1_auth_kubernetes_auth_login_post_request : ApiV1AuthKubernetesAuthLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_oidc_auth_login_post  # noqa: E501

        Login with OIDC Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_oidc_auth_login_post_with_http_info(api_v1_auth_kubernetes_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_kubernetes_auth_login_post_request: (required)
        :type api_v1_auth_kubernetes_auth_login_post_request: ApiV1AuthKubernetesAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_kubernetes_auth_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_oidc_auth_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_kubernetes_auth_login_post_request'] is not None:
            _body_params = _params['api_v1_auth_kubernetes_auth_login_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/oidc-auth/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_delete  # noqa: E501

        Delete Token Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_delete  # noqa: E501

        Delete Token Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_get  # noqa: E501

        Retrieve Token Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_get  # noqa: E501

        Retrieve Token Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_token_auth_identities_identity_id_patch_request : Optional[ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_patch  # noqa: E501

        Update Token Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_patch(identity_id, api_v1_auth_token_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_token_auth_identities_identity_id_patch_request:
        :type api_v1_auth_token_auth_identities_identity_id_patch_request: ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_token_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_token_auth_identities_identity_id_patch_request : Optional[ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_patch  # noqa: E501

        Update Token Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_token_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_token_auth_identities_identity_id_patch_request:
        :type api_v1_auth_token_auth_identities_identity_id_patch_request: ApiV1AuthTokenAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_token_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_token_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_token_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_token_auth_identities_identity_id_post_request : Optional[ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest] = None, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_post  # noqa: E501

        Attach Token Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_post(identity_id, api_v1_auth_token_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_token_auth_identities_identity_id_post_request:
        :type api_v1_auth_token_auth_identities_identity_id_post_request: ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_token_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_token_auth_identities_identity_id_post_request : Optional[ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_post  # noqa: E501

        Attach Token Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_token_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_token_auth_identities_identity_id_post_request:
        :type api_v1_auth_token_auth_identities_identity_id_post_request: ApiV1AuthTokenAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_token_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_token_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_token_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_tokens_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to list token metadata for.")], offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th token.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of tokens to return")] = None, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_tokens_get  # noqa: E501

        Get tokens for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_tokens_get(identity_id, offset, limit, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list token metadata for. (required)
        :type identity_id: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th token.
        :type offset: float
        :param limit: The number of tokens to return
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_identities_identity_id_tokens_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_identities_identity_id_tokens_get_with_http_info(identity_id, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_tokens_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to list token metadata for.")], offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th token.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of tokens to return")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_tokens_get  # noqa: E501

        Get tokens for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_tokens_get_with_http_info(identity_id, offset, limit, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list token metadata for. (required)
        :type identity_id: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th token.
        :type offset: float
        :param limit: The number of tokens to return
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_identities_identity_id_tokens_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/identities/{identityId}/tokens', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_tokens_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to create the token for.")], api_v1_auth_token_auth_identities_identity_id_tokens_post_request : Optional[ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest] = None, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_tokens_post  # noqa: E501

        Create token for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_tokens_post(identity_id, api_v1_auth_token_auth_identities_identity_id_tokens_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to create the token for. (required)
        :type identity_id: str
        :param api_v1_auth_token_auth_identities_identity_id_tokens_post_request:
        :type api_v1_auth_token_auth_identities_identity_id_tokens_post_request: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_identities_identity_id_tokens_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_identities_identity_id_tokens_post_with_http_info(identity_id, api_v1_auth_token_auth_identities_identity_id_tokens_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_identities_identity_id_tokens_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to create the token for.")], api_v1_auth_token_auth_identities_identity_id_tokens_post_request : Optional[ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_identities_identity_id_tokens_post  # noqa: E501

        Create token for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_identities_identity_id_tokens_post_with_http_info(identity_id, api_v1_auth_token_auth_identities_identity_id_tokens_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to create the token for. (required)
        :type identity_id: str
        :param api_v1_auth_token_auth_identities_identity_id_tokens_post_request:
        :type api_v1_auth_token_auth_identities_identity_id_tokens_post_request: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_token_auth_identities_identity_id_tokens_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_identities_identity_id_tokens_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_token_auth_identities_identity_id_tokens_post_request'] is not None:
            _body_params = _params['api_v1_auth_token_auth_identities_identity_id_tokens_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/identities/{identityId}/tokens', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_tokens_token_id_patch(self, token_id : Annotated[StrictStr, Field(..., description="The ID of the token to update metadata for")], api_v1_auth_token_auth_tokens_token_id_patch_request : Optional[ApiV1AuthTokenAuthTokensTokenIdPatchRequest] = None, **kwargs) -> ApiV1AuthTokenAuthTokensTokenIdPatch200Response:  # noqa: E501
        """api_v1_auth_token_auth_tokens_token_id_patch  # noqa: E501

        Update token for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_tokens_token_id_patch(token_id, api_v1_auth_token_auth_tokens_token_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param token_id: The ID of the token to update metadata for (required)
        :type token_id: str
        :param api_v1_auth_token_auth_tokens_token_id_patch_request:
        :type api_v1_auth_token_auth_tokens_token_id_patch_request: ApiV1AuthTokenAuthTokensTokenIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthTokensTokenIdPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_tokens_token_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_tokens_token_id_patch_with_http_info(token_id, api_v1_auth_token_auth_tokens_token_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_tokens_token_id_patch_with_http_info(self, token_id : Annotated[StrictStr, Field(..., description="The ID of the token to update metadata for")], api_v1_auth_token_auth_tokens_token_id_patch_request : Optional[ApiV1AuthTokenAuthTokensTokenIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_tokens_token_id_patch  # noqa: E501

        Update token for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_tokens_token_id_patch_with_http_info(token_id, api_v1_auth_token_auth_tokens_token_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param token_id: The ID of the token to update metadata for (required)
        :type token_id: str
        :param api_v1_auth_token_auth_tokens_token_id_patch_request:
        :type api_v1_auth_token_auth_tokens_token_id_patch_request: ApiV1AuthTokenAuthTokensTokenIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthTokensTokenIdPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token_id',
            'api_v1_auth_token_auth_tokens_token_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_tokens_token_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['token_id'] is not None:
            _path_params['tokenId'] = _params['token_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_token_auth_tokens_token_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_token_auth_tokens_token_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthTokensTokenIdPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/tokens/{tokenId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_auth_tokens_token_id_revoke_post(self, token_id : Annotated[StrictStr, Field(..., description="The ID of the token to revoke")], **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_auth_token_auth_tokens_token_id_revoke_post  # noqa: E501

        Revoke token for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_tokens_token_id_revoke_post(token_id, async_req=True)
        >>> result = thread.get()

        :param token_id: The ID of the token to revoke (required)
        :type token_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_auth_tokens_token_id_revoke_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_auth_tokens_token_id_revoke_post_with_http_info(token_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_auth_tokens_token_id_revoke_post_with_http_info(self, token_id : Annotated[StrictStr, Field(..., description="The ID of the token to revoke")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_auth_tokens_token_id_revoke_post  # noqa: E501

        Revoke token for identity with Token Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_auth_tokens_token_id_revoke_post_with_http_info(token_id, async_req=True)
        >>> result = thread.get()

        :param token_id: The ID of the token to revoke (required)
        :type token_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'token_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_auth_tokens_token_id_revoke_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['token_id'] is not None:
            _path_params['tokenId'] = _params['token_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token-auth/tokens/{tokenId}/revoke', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_post(self, **kwargs) -> ApiV1AuthTokenPost200Response:  # noqa: E501
        """api_v1_auth_token_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_post(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_post_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_post_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_renew_post(self, api_v1_auth_token_renew_post_request : ApiV1AuthTokenRenewPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_token_renew_post  # noqa: E501

        Renew access token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_renew_post(api_v1_auth_token_renew_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_token_renew_post_request: (required)
        :type api_v1_auth_token_renew_post_request: ApiV1AuthTokenRenewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_renew_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_renew_post_with_http_info(api_v1_auth_token_renew_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_renew_post_with_http_info(self, api_v1_auth_token_renew_post_request : ApiV1AuthTokenRenewPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_renew_post  # noqa: E501

        Renew access token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_renew_post_with_http_info(api_v1_auth_token_renew_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_token_renew_post_request: (required)
        :type api_v1_auth_token_renew_post_request: ApiV1AuthTokenRenewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_token_renew_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_renew_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_token_renew_post_request'] is not None:
            _body_params = _params['api_v1_auth_token_renew_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token/renew', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_token_revoke_post(self, api_v1_auth_token_revoke_post_request : ApiV1AuthTokenRevokePostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_auth_token_revoke_post  # noqa: E501

        Revoke access token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_revoke_post(api_v1_auth_token_revoke_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_token_revoke_post_request: (required)
        :type api_v1_auth_token_revoke_post_request: ApiV1AuthTokenRevokePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_token_revoke_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_token_revoke_post_with_http_info(api_v1_auth_token_revoke_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_token_revoke_post_with_http_info(self, api_v1_auth_token_revoke_post_request : ApiV1AuthTokenRevokePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_token_revoke_post  # noqa: E501

        Revoke access token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_token_revoke_post_with_http_info(api_v1_auth_token_revoke_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_token_revoke_post_request: (required)
        :type api_v1_auth_token_revoke_post_request: ApiV1AuthTokenRevokePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_token_revoke_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_token_revoke_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_token_revoke_post_request'] is not None:
            _body_params = _params['api_v1_auth_token_revoke_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/token/revoke', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get the client secret from.")], client_secret_id : Annotated[StrictStr, Field(..., description="The ID of the client secret to get details.")], **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get  # noqa: E501

        Get Universal Auth Client Secret for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get(identity_id, client_secret_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to get the client secret from. (required)
        :type identity_id: str
        :param client_secret_id: The ID of the client secret to get details. (required)
        :type client_secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get_with_http_info(identity_id, client_secret_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get the client secret from.")], client_secret_id : Annotated[StrictStr, Field(..., description="The ID of the client secret to get details.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get  # noqa: E501

        Get Universal Auth Client Secret for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get_with_http_info(identity_id, client_secret_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to get the client secret from. (required)
        :type identity_id: str
        :param client_secret_id: The ID of the client secret to get details. (required)
        :type client_secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'client_secret_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']

        if _params['client_secret_id'] is not None:
            _path_params['clientSecretId'] = _params['client_secret_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}/client-secrets/{clientSecretId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the client secret from.")], client_secret_id : Annotated[StrictStr, Field(..., description="The ID of the client secret to revoke.")], **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post  # noqa: E501

        Revoke Universal Auth Client Secrets for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post(identity_id, client_secret_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the client secret from. (required)
        :type identity_id: str
        :param client_secret_id: The ID of the client secret to revoke. (required)
        :type client_secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post_with_http_info(identity_id, client_secret_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the client secret from.")], client_secret_id : Annotated[StrictStr, Field(..., description="The ID of the client secret to revoke.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post  # noqa: E501

        Revoke Universal Auth Client Secrets for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post_with_http_info(identity_id, client_secret_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the client secret from. (required)
        :type identity_id: str
        :param client_secret_id: The ID of the client secret to revoke. (required)
        :type client_secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'client_secret_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_client_secrets_client_secret_id_revoke_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']

        if _params['client_secret_id'] is not None:
            _path_params['clientSecretId'] = _params['client_secret_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsClientSecretIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}/client-secrets/{clientSecretId}/revoke', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to list client secrets for.")], **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_get  # noqa: E501

        List Universal Auth Client Secrets for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list client secrets for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_client_secrets_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_client_secrets_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to list client secrets for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_get  # noqa: E501

        List Universal Auth Client Secrets for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to list client secrets for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_client_secrets_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}/client-secrets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to create a client secret for.")], api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request : Optional[ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest] = None, **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_post  # noqa: E501

        Create Universal Auth Client Secret for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_post(identity_id, api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to create a client secret for. (required)
        :type identity_id: str
        :param api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request:
        :type api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_with_http_info(identity_id, api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to create a client secret for.")], api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request : Optional[ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_client_secrets_post  # noqa: E501

        Create Universal Auth Client Secret for identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_with_http_info(identity_id, api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to create a client secret for. (required)
        :type identity_id: str
        :param api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request:
        :type api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request: ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_client_secrets_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request'] is not None:
            _body_params = _params['api_v1_auth_universal_auth_identities_identity_id_client_secrets_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdClientSecretsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}/client-secrets', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_delete  # noqa: E501

        Delete Universal Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to revoke the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_delete  # noqa: E501

        Delete Universal Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to revoke the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_get  # noqa: E501

        Retrieve Universal Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to retrieve the auth method for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_get  # noqa: E501

        Retrieve Universal Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to retrieve the auth method for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_universal_auth_identities_identity_id_patch_request : Optional[ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_patch  # noqa: E501

        Update Universal Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_patch(identity_id, api_v1_auth_universal_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_universal_auth_identities_identity_id_patch_request:
        :type api_v1_auth_universal_auth_identities_identity_id_patch_request: ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_universal_auth_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the auth method for.")], api_v1_auth_universal_auth_identities_identity_id_patch_request : Optional[ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_patch  # noqa: E501

        Update Universal Auth configuration on identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_patch_with_http_info(identity_id, api_v1_auth_universal_auth_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update the auth method for. (required)
        :type identity_id: str
        :param api_v1_auth_universal_auth_identities_identity_id_patch_request:
        :type api_v1_auth_universal_auth_identities_identity_id_patch_request: ApiV1AuthUniversalAuthIdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_universal_auth_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_universal_auth_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_auth_universal_auth_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_post(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_universal_auth_identities_identity_id_post_request : Optional[ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest] = None, **kwargs) -> ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_post  # noqa: E501

        Attach Universal Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_post(identity_id, api_v1_auth_universal_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_universal_auth_identities_identity_id_post_request:
        :type api_v1_auth_universal_auth_identities_identity_id_post_request: ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_identities_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_universal_auth_identities_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_identities_identity_id_post_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to attach the configuration onto.")], api_v1_auth_universal_auth_identities_identity_id_post_request : Optional[ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_identities_identity_id_post  # noqa: E501

        Attach Universal Auth configuration onto identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_identities_identity_id_post_with_http_info(identity_id, api_v1_auth_universal_auth_identities_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to attach the configuration onto. (required)
        :type identity_id: str
        :param api_v1_auth_universal_auth_identities_identity_id_post_request:
        :type api_v1_auth_universal_auth_identities_identity_id_post_request: ApiV1AuthUniversalAuthIdentitiesIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_auth_universal_auth_identities_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_identities_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_universal_auth_identities_identity_id_post_request'] is not None:
            _body_params = _params['api_v1_auth_universal_auth_identities_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthUniversalAuthIdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/identities/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_auth_universal_auth_login_post(self, api_v1_auth_universal_auth_login_post_request : ApiV1AuthUniversalAuthLoginPostRequest, **kwargs) -> ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response:  # noqa: E501
        """api_v1_auth_universal_auth_login_post  # noqa: E501

        Login with Universal Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_login_post(api_v1_auth_universal_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_universal_auth_login_post_request: (required)
        :type api_v1_auth_universal_auth_login_post_request: ApiV1AuthUniversalAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_auth_universal_auth_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_auth_universal_auth_login_post_with_http_info(api_v1_auth_universal_auth_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_auth_universal_auth_login_post_with_http_info(self, api_v1_auth_universal_auth_login_post_request : ApiV1AuthUniversalAuthLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_auth_universal_auth_login_post  # noqa: E501

        Login with Universal Auth  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_auth_universal_auth_login_post_with_http_info(api_v1_auth_universal_auth_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_auth_universal_auth_login_post_request: (required)
        :type api_v1_auth_universal_auth_login_post_request: ApiV1AuthUniversalAuthLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_auth_universal_auth_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_auth_universal_auth_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_auth_universal_auth_login_post_request'] is not None:
            _body_params = _params['api_v1_auth_universal_auth_login_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenAuthIdentitiesIdentityIdTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/auth/universal-auth/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_bot_bot_id_active_patch(self, bot_id : StrictStr, api_v1_bot_bot_id_active_patch_request : ApiV1BotBotIdActivePatchRequest, **kwargs) -> ApiV1BotProjectIdGet200Response:  # noqa: E501
        """api_v1_bot_bot_id_active_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_bot_bot_id_active_patch(bot_id, api_v1_bot_bot_id_active_patch_request, async_req=True)
        >>> result = thread.get()

        :param bot_id: (required)
        :type bot_id: str
        :param api_v1_bot_bot_id_active_patch_request: (required)
        :type api_v1_bot_bot_id_active_patch_request: ApiV1BotBotIdActivePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1BotProjectIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_bot_bot_id_active_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_bot_bot_id_active_patch_with_http_info(bot_id, api_v1_bot_bot_id_active_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_bot_bot_id_active_patch_with_http_info(self, bot_id : StrictStr, api_v1_bot_bot_id_active_patch_request : ApiV1BotBotIdActivePatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_bot_bot_id_active_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_bot_bot_id_active_patch_with_http_info(bot_id, api_v1_bot_bot_id_active_patch_request, async_req=True)
        >>> result = thread.get()

        :param bot_id: (required)
        :type bot_id: str
        :param api_v1_bot_bot_id_active_patch_request: (required)
        :type api_v1_bot_bot_id_active_patch_request: ApiV1BotBotIdActivePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1BotProjectIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bot_id',
            'api_v1_bot_bot_id_active_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_bot_bot_id_active_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['bot_id'] is not None:
            _path_params['botId'] = _params['bot_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_bot_bot_id_active_patch_request'] is not None:
            _body_params = _params['api_v1_bot_bot_id_active_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1BotProjectIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/bot/{botId}/active', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_bot_project_id_get(self, project_id : StrictStr, **kwargs) -> ApiV1BotProjectIdGet200Response:  # noqa: E501
        """api_v1_bot_project_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_bot_project_id_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1BotProjectIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_bot_project_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_bot_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_bot_project_id_get_with_http_info(self, project_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_bot_project_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_bot_project_id_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1BotProjectIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_bot_project_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1BotProjectIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/bot/{projectId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_get(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiV1DynamicSecretsGet200Response:  # noqa: E501
        """api_v1_dynamic_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_get(project_slug, environment_slug, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_get_with_http_info(project_slug, environment_slug, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_get_with_http_info(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_get_with_http_info(project_slug, environment_slug, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'environment_slug',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('environment_slug') is not None:  # noqa: E501
            _query_params.append(('environmentSlug', _params['environment_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_leases_lease_id_delete(self, lease_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the dynamic secret lease.")], api_v1_dynamic_secrets_leases_lease_id_delete_request : ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest, **kwargs) -> ApiV1DynamicSecretsLeasesLeaseIdDelete200Response:  # noqa: E501
        """api_v1_dynamic_secrets_leases_lease_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_lease_id_delete(lease_id, api_v1_dynamic_secrets_leases_lease_id_delete_request, async_req=True)
        >>> result = thread.get()

        :param lease_id: The ID of the dynamic secret lease. (required)
        :type lease_id: str
        :param api_v1_dynamic_secrets_leases_lease_id_delete_request: (required)
        :type api_v1_dynamic_secrets_leases_lease_id_delete_request: ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsLeasesLeaseIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_leases_lease_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_leases_lease_id_delete_with_http_info(lease_id, api_v1_dynamic_secrets_leases_lease_id_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_leases_lease_id_delete_with_http_info(self, lease_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the dynamic secret lease.")], api_v1_dynamic_secrets_leases_lease_id_delete_request : ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_leases_lease_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_lease_id_delete_with_http_info(lease_id, api_v1_dynamic_secrets_leases_lease_id_delete_request, async_req=True)
        >>> result = thread.get()

        :param lease_id: The ID of the dynamic secret lease. (required)
        :type lease_id: str
        :param api_v1_dynamic_secrets_leases_lease_id_delete_request: (required)
        :type api_v1_dynamic_secrets_leases_lease_id_delete_request: ApiV1DynamicSecretsLeasesLeaseIdDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsLeasesLeaseIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'lease_id',
            'api_v1_dynamic_secrets_leases_lease_id_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_leases_lease_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['lease_id'] is not None:
            _path_params['leaseId'] = _params['lease_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_dynamic_secrets_leases_lease_id_delete_request'] is not None:
            _body_params = _params['api_v1_dynamic_secrets_leases_lease_id_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsLeasesLeaseIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/leases/{leaseId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_leases_lease_id_get(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], lease_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the dynamic secret lease.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiV1DynamicSecretsLeasesLeaseIdGet200Response:  # noqa: E501
        """api_v1_dynamic_secrets_leases_lease_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_lease_id_get(project_slug, environment_slug, lease_id, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param lease_id: The ID of the dynamic secret lease. (required)
        :type lease_id: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsLeasesLeaseIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_leases_lease_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_leases_lease_id_get_with_http_info(project_slug, environment_slug, lease_id, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_leases_lease_id_get_with_http_info(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], lease_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the dynamic secret lease.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_leases_lease_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_lease_id_get_with_http_info(project_slug, environment_slug, lease_id, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param lease_id: The ID of the dynamic secret lease. (required)
        :type lease_id: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsLeasesLeaseIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'environment_slug',
            'lease_id',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_leases_lease_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['lease_id'] is not None:
            _path_params['leaseId'] = _params['lease_id']


        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('environment_slug') is not None:  # noqa: E501
            _query_params.append(('environmentSlug', _params['environment_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsLeasesLeaseIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/leases/{leaseId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_leases_lease_id_renew_post(self, lease_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the dynamic secret lease.")], api_v1_dynamic_secrets_leases_lease_id_renew_post_request : ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, **kwargs) -> ApiV1DynamicSecretsLeasesLeaseIdDelete200Response:  # noqa: E501
        """api_v1_dynamic_secrets_leases_lease_id_renew_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_lease_id_renew_post(lease_id, api_v1_dynamic_secrets_leases_lease_id_renew_post_request, async_req=True)
        >>> result = thread.get()

        :param lease_id: The ID of the dynamic secret lease. (required)
        :type lease_id: str
        :param api_v1_dynamic_secrets_leases_lease_id_renew_post_request: (required)
        :type api_v1_dynamic_secrets_leases_lease_id_renew_post_request: ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsLeasesLeaseIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_leases_lease_id_renew_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_leases_lease_id_renew_post_with_http_info(lease_id, api_v1_dynamic_secrets_leases_lease_id_renew_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_leases_lease_id_renew_post_with_http_info(self, lease_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the dynamic secret lease.")], api_v1_dynamic_secrets_leases_lease_id_renew_post_request : ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_leases_lease_id_renew_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_lease_id_renew_post_with_http_info(lease_id, api_v1_dynamic_secrets_leases_lease_id_renew_post_request, async_req=True)
        >>> result = thread.get()

        :param lease_id: The ID of the dynamic secret lease. (required)
        :type lease_id: str
        :param api_v1_dynamic_secrets_leases_lease_id_renew_post_request: (required)
        :type api_v1_dynamic_secrets_leases_lease_id_renew_post_request: ApiV1DynamicSecretsLeasesLeaseIdRenewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsLeasesLeaseIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'lease_id',
            'api_v1_dynamic_secrets_leases_lease_id_renew_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_leases_lease_id_renew_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['lease_id'] is not None:
            _path_params['leaseId'] = _params['lease_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_dynamic_secrets_leases_lease_id_renew_post_request'] is not None:
            _body_params = _params['api_v1_dynamic_secrets_leases_lease_id_renew_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsLeasesLeaseIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/leases/{leaseId}/renew', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_leases_post(self, api_v1_dynamic_secrets_leases_post_request : ApiV1DynamicSecretsLeasesPostRequest, **kwargs) -> ApiV1DynamicSecretsLeasesPost200Response:  # noqa: E501
        """api_v1_dynamic_secrets_leases_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_post(api_v1_dynamic_secrets_leases_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_dynamic_secrets_leases_post_request: (required)
        :type api_v1_dynamic_secrets_leases_post_request: ApiV1DynamicSecretsLeasesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsLeasesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_leases_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_leases_post_with_http_info(api_v1_dynamic_secrets_leases_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_leases_post_with_http_info(self, api_v1_dynamic_secrets_leases_post_request : ApiV1DynamicSecretsLeasesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_leases_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_leases_post_with_http_info(api_v1_dynamic_secrets_leases_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_dynamic_secrets_leases_post_request: (required)
        :type api_v1_dynamic_secrets_leases_post_request: ApiV1DynamicSecretsLeasesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsLeasesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_dynamic_secrets_leases_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_leases_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_dynamic_secrets_leases_post_request'] is not None:
            _body_params = _params['api_v1_dynamic_secrets_leases_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsLeasesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/leases', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_name_delete(self, name : Annotated[StrictStr, Field(..., description="The name of the dynamic secret.")], api_v1_dynamic_secrets_name_delete_request : ApiV1DynamicSecretsNameDeleteRequest, **kwargs) -> ApiV1DynamicSecretsPost200Response:  # noqa: E501
        """api_v1_dynamic_secrets_name_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_delete(name, api_v1_dynamic_secrets_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param api_v1_dynamic_secrets_name_delete_request: (required)
        :type api_v1_dynamic_secrets_name_delete_request: ApiV1DynamicSecretsNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_name_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_name_delete_with_http_info(name, api_v1_dynamic_secrets_name_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_name_delete_with_http_info(self, name : Annotated[StrictStr, Field(..., description="The name of the dynamic secret.")], api_v1_dynamic_secrets_name_delete_request : ApiV1DynamicSecretsNameDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_name_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_delete_with_http_info(name, api_v1_dynamic_secrets_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param api_v1_dynamic_secrets_name_delete_request: (required)
        :type api_v1_dynamic_secrets_name_delete_request: ApiV1DynamicSecretsNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'api_v1_dynamic_secrets_name_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_name_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_dynamic_secrets_name_delete_request'] is not None:
            _body_params = _params['api_v1_dynamic_secrets_name_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/{name}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_name_get(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], name : Annotated[constr(strict=True, min_length=1), Field(..., description="The name of the dynamic secret.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiV1DynamicSecretsNameGet200Response:  # noqa: E501
        """api_v1_dynamic_secrets_name_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_get(project_slug, environment_slug, name, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsNameGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_name_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_name_get_with_http_info(project_slug, environment_slug, name, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_name_get_with_http_info(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], name : Annotated[constr(strict=True, min_length=1), Field(..., description="The name of the dynamic secret.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_name_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_get_with_http_info(project_slug, environment_slug, name, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsNameGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'environment_slug',
            'name',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_name_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('environment_slug') is not None:  # noqa: E501
            _query_params.append(('environmentSlug', _params['environment_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsNameGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/{name}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_name_leases_get(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], name : Annotated[constr(strict=True, min_length=1), Field(..., description="The name of the dynamic secret.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiV1DynamicSecretsNameLeasesGet200Response:  # noqa: E501
        """api_v1_dynamic_secrets_name_leases_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_leases_get(project_slug, environment_slug, name, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsNameLeasesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_name_leases_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_name_leases_get_with_http_info(project_slug, environment_slug, name, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_name_leases_get_with_http_info(self, project_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the project to create dynamic secret in.")], environment_slug : Annotated[constr(strict=True, min_length=1), Field(..., description="The slug of the environment to list folders from.")], name : Annotated[constr(strict=True, min_length=1), Field(..., description="The name of the dynamic secret.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_name_leases_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_leases_get_with_http_info(project_slug, environment_slug, name, path, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to create dynamic secret in. (required)
        :type project_slug: str
        :param environment_slug: The slug of the environment to list folders from. (required)
        :type environment_slug: str
        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param path: The path to list folders from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsNameLeasesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'environment_slug',
            'name',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_name_leases_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        if _params.get('project_slug') is not None:  # noqa: E501
            _query_params.append(('projectSlug', _params['project_slug']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('environment_slug') is not None:  # noqa: E501
            _query_params.append(('environmentSlug', _params['environment_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsNameLeasesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/{name}/leases', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_name_patch(self, name : Annotated[StrictStr, Field(..., description="The name of the dynamic secret.")], api_v1_dynamic_secrets_name_patch_request : ApiV1DynamicSecretsNamePatchRequest, **kwargs) -> ApiV1DynamicSecretsPost200Response:  # noqa: E501
        """api_v1_dynamic_secrets_name_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_patch(name, api_v1_dynamic_secrets_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param api_v1_dynamic_secrets_name_patch_request: (required)
        :type api_v1_dynamic_secrets_name_patch_request: ApiV1DynamicSecretsNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_name_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_name_patch_with_http_info(name, api_v1_dynamic_secrets_name_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_name_patch_with_http_info(self, name : Annotated[StrictStr, Field(..., description="The name of the dynamic secret.")], api_v1_dynamic_secrets_name_patch_request : ApiV1DynamicSecretsNamePatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_name_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_name_patch_with_http_info(name, api_v1_dynamic_secrets_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param name: The name of the dynamic secret. (required)
        :type name: str
        :param api_v1_dynamic_secrets_name_patch_request: (required)
        :type api_v1_dynamic_secrets_name_patch_request: ApiV1DynamicSecretsNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name',
            'api_v1_dynamic_secrets_name_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_name_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['name'] is not None:
            _path_params['name'] = _params['name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_dynamic_secrets_name_patch_request'] is not None:
            _body_params = _params['api_v1_dynamic_secrets_name_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets/{name}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_dynamic_secrets_post(self, api_v1_dynamic_secrets_post_request : ApiV1DynamicSecretsPostRequest, **kwargs) -> ApiV1DynamicSecretsPost200Response:  # noqa: E501
        """api_v1_dynamic_secrets_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_post(api_v1_dynamic_secrets_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_dynamic_secrets_post_request: (required)
        :type api_v1_dynamic_secrets_post_request: ApiV1DynamicSecretsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1DynamicSecretsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_dynamic_secrets_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_dynamic_secrets_post_with_http_info(api_v1_dynamic_secrets_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_dynamic_secrets_post_with_http_info(self, api_v1_dynamic_secrets_post_request : ApiV1DynamicSecretsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_dynamic_secrets_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_dynamic_secrets_post_with_http_info(api_v1_dynamic_secrets_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_dynamic_secrets_post_request: (required)
        :type api_v1_dynamic_secrets_post_request: ApiV1DynamicSecretsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1DynamicSecretsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_dynamic_secrets_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_dynamic_secrets_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_dynamic_secrets_post_request'] is not None:
            _body_params = _params['api_v1_dynamic_secrets_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1DynamicSecretsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/dynamic-secrets', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_external_kms_get(self, **kwargs) -> ApiV1ExternalKmsGet200Response:  # noqa: E501
        """api_v1_external_kms_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ExternalKmsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_external_kms_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_external_kms_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_external_kms_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_external_kms_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ExternalKmsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_external_kms_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ExternalKmsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/external-kms', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_external_kms_id_delete(self, id : constr(strict=True, min_length=1), **kwargs) -> ApiV1ExternalKmsPost200Response:  # noqa: E501
        """api_v1_external_kms_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ExternalKmsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_external_kms_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_external_kms_id_delete_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_external_kms_id_delete_with_http_info(self, id : constr(strict=True, min_length=1), **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_external_kms_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ExternalKmsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_external_kms_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ExternalKmsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/external-kms/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_external_kms_id_get(self, id : constr(strict=True, min_length=1), **kwargs) -> ApiV1ExternalKmsIdGet200Response:  # noqa: E501
        """api_v1_external_kms_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ExternalKmsIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_external_kms_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_external_kms_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_external_kms_id_get_with_http_info(self, id : constr(strict=True, min_length=1), **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_external_kms_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ExternalKmsIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_external_kms_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ExternalKmsIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/external-kms/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_external_kms_id_patch(self, id : constr(strict=True, min_length=1), api_v1_external_kms_id_patch_request : ApiV1ExternalKmsIdPatchRequest, **kwargs) -> ApiV1ExternalKmsPost200Response:  # noqa: E501
        """api_v1_external_kms_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_id_patch(id, api_v1_external_kms_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_external_kms_id_patch_request: (required)
        :type api_v1_external_kms_id_patch_request: ApiV1ExternalKmsIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ExternalKmsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_external_kms_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_external_kms_id_patch_with_http_info(id, api_v1_external_kms_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_external_kms_id_patch_with_http_info(self, id : constr(strict=True, min_length=1), api_v1_external_kms_id_patch_request : ApiV1ExternalKmsIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_external_kms_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_id_patch_with_http_info(id, api_v1_external_kms_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_external_kms_id_patch_request: (required)
        :type api_v1_external_kms_id_patch_request: ApiV1ExternalKmsIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ExternalKmsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'api_v1_external_kms_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_external_kms_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_external_kms_id_patch_request'] is not None:
            _body_params = _params['api_v1_external_kms_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ExternalKmsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/external-kms/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_external_kms_post(self, api_v1_external_kms_post_request : ApiV1ExternalKmsPostRequest, **kwargs) -> ApiV1ExternalKmsPost200Response:  # noqa: E501
        """api_v1_external_kms_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_post(api_v1_external_kms_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_external_kms_post_request: (required)
        :type api_v1_external_kms_post_request: ApiV1ExternalKmsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ExternalKmsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_external_kms_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_external_kms_post_with_http_info(api_v1_external_kms_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_external_kms_post_with_http_info(self, api_v1_external_kms_post_request : ApiV1ExternalKmsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_external_kms_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_post_with_http_info(api_v1_external_kms_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_external_kms_post_request: (required)
        :type api_v1_external_kms_post_request: ApiV1ExternalKmsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ExternalKmsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_external_kms_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_external_kms_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_external_kms_post_request'] is not None:
            _body_params = _params['api_v1_external_kms_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ExternalKmsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/external-kms', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_external_kms_slug_slug_get(self, slug : constr(strict=True, min_length=1), **kwargs) -> ApiV1ExternalKmsIdGet200Response:  # noqa: E501
        """api_v1_external_kms_slug_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_slug_slug_get(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ExternalKmsIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_external_kms_slug_slug_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_external_kms_slug_slug_get_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_external_kms_slug_slug_get_with_http_info(self, slug : constr(strict=True, min_length=1), **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_external_kms_slug_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_external_kms_slug_slug_get_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ExternalKmsIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_external_kms_slug_slug_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ExternalKmsIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/external-kms/slug/{slug}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_folders_batch_patch(self, api_v1_folders_batch_patch_request : ApiV1FoldersBatchPatchRequest, **kwargs) -> ApiV1FoldersGet200Response:  # noqa: E501
        """api_v1_folders_batch_patch  # noqa: E501

        Update folders by batch  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_batch_patch(api_v1_folders_batch_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_folders_batch_patch_request: (required)
        :type api_v1_folders_batch_patch_request: ApiV1FoldersBatchPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1FoldersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_folders_batch_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_folders_batch_patch_with_http_info(api_v1_folders_batch_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_folders_batch_patch_with_http_info(self, api_v1_folders_batch_patch_request : ApiV1FoldersBatchPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_folders_batch_patch  # noqa: E501

        Update folders by batch  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_batch_patch_with_http_info(api_v1_folders_batch_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_folders_batch_patch_request: (required)
        :type api_v1_folders_batch_patch_request: ApiV1FoldersBatchPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1FoldersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_folders_batch_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_folders_batch_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_folders_batch_patch_request'] is not None:
            _body_params = _params['api_v1_folders_batch_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1FoldersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/folders/batch', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_folders_folder_id_or_name_delete(self, folder_id_or_name : Annotated[StrictStr, Field(..., description="The ID or name of the folder to delete.")], api_v1_folders_folder_id_or_name_delete_request : ApiV1FoldersFolderIdOrNameDeleteRequest, **kwargs) -> ApiV1FoldersPost200Response:  # noqa: E501
        """api_v1_folders_folder_id_or_name_delete  # noqa: E501

        Delete a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_folder_id_or_name_delete(folder_id_or_name, api_v1_folders_folder_id_or_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param folder_id_or_name: The ID or name of the folder to delete. (required)
        :type folder_id_or_name: str
        :param api_v1_folders_folder_id_or_name_delete_request: (required)
        :type api_v1_folders_folder_id_or_name_delete_request: ApiV1FoldersFolderIdOrNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1FoldersPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_folders_folder_id_or_name_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_folders_folder_id_or_name_delete_with_http_info(folder_id_or_name, api_v1_folders_folder_id_or_name_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_folders_folder_id_or_name_delete_with_http_info(self, folder_id_or_name : Annotated[StrictStr, Field(..., description="The ID or name of the folder to delete.")], api_v1_folders_folder_id_or_name_delete_request : ApiV1FoldersFolderIdOrNameDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_folders_folder_id_or_name_delete  # noqa: E501

        Delete a folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_folder_id_or_name_delete_with_http_info(folder_id_or_name, api_v1_folders_folder_id_or_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param folder_id_or_name: The ID or name of the folder to delete. (required)
        :type folder_id_or_name: str
        :param api_v1_folders_folder_id_or_name_delete_request: (required)
        :type api_v1_folders_folder_id_or_name_delete_request: ApiV1FoldersFolderIdOrNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1FoldersPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'folder_id_or_name',
            'api_v1_folders_folder_id_or_name_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_folders_folder_id_or_name_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['folder_id_or_name'] is not None:
            _path_params['folderIdOrName'] = _params['folder_id_or_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_folders_folder_id_or_name_delete_request'] is not None:
            _body_params = _params['api_v1_folders_folder_id_or_name_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1FoldersPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/folders/{folderIdOrName}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_folders_folder_id_patch(self, folder_id : Annotated[StrictStr, Field(..., description="The ID of the folder to update.")], api_v1_folders_folder_id_patch_request : ApiV1FoldersFolderIdPatchRequest, **kwargs) -> ApiV1FoldersPost200Response:  # noqa: E501
        """api_v1_folders_folder_id_patch  # noqa: E501

        Update folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_folder_id_patch(folder_id, api_v1_folders_folder_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param folder_id: The ID of the folder to update. (required)
        :type folder_id: str
        :param api_v1_folders_folder_id_patch_request: (required)
        :type api_v1_folders_folder_id_patch_request: ApiV1FoldersFolderIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1FoldersPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_folders_folder_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_folders_folder_id_patch_with_http_info(folder_id, api_v1_folders_folder_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_folders_folder_id_patch_with_http_info(self, folder_id : Annotated[StrictStr, Field(..., description="The ID of the folder to update.")], api_v1_folders_folder_id_patch_request : ApiV1FoldersFolderIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_folders_folder_id_patch  # noqa: E501

        Update folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_folder_id_patch_with_http_info(folder_id, api_v1_folders_folder_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param folder_id: The ID of the folder to update. (required)
        :type folder_id: str
        :param api_v1_folders_folder_id_patch_request: (required)
        :type api_v1_folders_folder_id_patch_request: ApiV1FoldersFolderIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1FoldersPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'folder_id',
            'api_v1_folders_folder_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_folders_folder_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['folder_id'] is not None:
            _path_params['folderId'] = _params['folder_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_folders_folder_id_patch_request'] is not None:
            _body_params = _params['api_v1_folders_folder_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1FoldersPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/folders/{folderId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_folders_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list folders from.")], environment : Annotated[StrictStr, Field(..., description="The slug of the environment to list folders from.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, directory : Annotated[Optional[StrictStr], Field(description="The directory to list folders from. (Deprecated in favor of path)")] = None, **kwargs) -> ApiV1FoldersGet200Response:  # noqa: E501
        """api_v1_folders_get  # noqa: E501

        Get folders  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_get(workspace_id, environment, path, directory, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list folders from. (required)
        :type workspace_id: str
        :param environment: The slug of the environment to list folders from. (required)
        :type environment: str
        :param path: The path to list folders from.
        :type path: str
        :param directory: The directory to list folders from. (Deprecated in favor of path)
        :type directory: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1FoldersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_folders_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_folders_get_with_http_info(workspace_id, environment, path, directory, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_folders_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list folders from.")], environment : Annotated[StrictStr, Field(..., description="The slug of the environment to list folders from.")], path : Annotated[Optional[StrictStr], Field(description="The path to list folders from.")] = None, directory : Annotated[Optional[StrictStr], Field(description="The directory to list folders from. (Deprecated in favor of path)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_folders_get  # noqa: E501

        Get folders  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_get_with_http_info(workspace_id, environment, path, directory, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list folders from. (required)
        :type workspace_id: str
        :param environment: The slug of the environment to list folders from. (required)
        :type environment: str
        :param path: The path to list folders from.
        :type path: str
        :param directory: The directory to list folders from. (Deprecated in favor of path)
        :type directory: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1FoldersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'path',
            'directory'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_folders_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('directory') is not None:  # noqa: E501
            _query_params.append(('directory', _params['directory']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1FoldersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/folders', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_folders_id_get(self, id : Annotated[StrictStr, Field(..., description="The id of the folder to get details.")], **kwargs) -> ApiV1FoldersPost200Response:  # noqa: E501
        """api_v1_folders_id_get  # noqa: E501

        Get folder by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder to get details. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1FoldersPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_folders_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_folders_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_folders_id_get_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The id of the folder to get details.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_folders_id_get  # noqa: E501

        Get folder by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The id of the folder to get details. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1FoldersPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_folders_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1FoldersPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/folders/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_folders_post(self, api_v1_folders_post_request : ApiV1FoldersPostRequest, **kwargs) -> ApiV1FoldersPost200Response:  # noqa: E501
        """api_v1_folders_post  # noqa: E501

        Create folders  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_post(api_v1_folders_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_folders_post_request: (required)
        :type api_v1_folders_post_request: ApiV1FoldersPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1FoldersPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_folders_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_folders_post_with_http_info(api_v1_folders_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_folders_post_with_http_info(self, api_v1_folders_post_request : ApiV1FoldersPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_folders_post  # noqa: E501

        Create folders  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_folders_post_with_http_info(api_v1_folders_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_folders_post_request: (required)
        :type api_v1_folders_post_request: ApiV1FoldersPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1FoldersPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_folders_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_folders_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_folders_post_request'] is not None:
            _body_params = _params['api_v1_folders_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1FoldersPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/folders', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_groups_current_slug_patch(self, current_slug : Annotated[StrictStr, Field(..., description="The current slug of the group to update.")], api_v1_groups_current_slug_patch_request : Optional[ApiV1GroupsCurrentSlugPatchRequest] = None, **kwargs) -> ApiV1GroupsPost200Response:  # noqa: E501
        """api_v1_groups_current_slug_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_current_slug_patch(current_slug, api_v1_groups_current_slug_patch_request, async_req=True)
        >>> result = thread.get()

        :param current_slug: The current slug of the group to update. (required)
        :type current_slug: str
        :param api_v1_groups_current_slug_patch_request:
        :type api_v1_groups_current_slug_patch_request: ApiV1GroupsCurrentSlugPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1GroupsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_groups_current_slug_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_groups_current_slug_patch_with_http_info(current_slug, api_v1_groups_current_slug_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_groups_current_slug_patch_with_http_info(self, current_slug : Annotated[StrictStr, Field(..., description="The current slug of the group to update.")], api_v1_groups_current_slug_patch_request : Optional[ApiV1GroupsCurrentSlugPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_groups_current_slug_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_current_slug_patch_with_http_info(current_slug, api_v1_groups_current_slug_patch_request, async_req=True)
        >>> result = thread.get()

        :param current_slug: The current slug of the group to update. (required)
        :type current_slug: str
        :param api_v1_groups_current_slug_patch_request:
        :type api_v1_groups_current_slug_patch_request: ApiV1GroupsCurrentSlugPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1GroupsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'current_slug',
            'api_v1_groups_current_slug_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_groups_current_slug_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['current_slug'] is not None:
            _path_params['currentSlug'] = _params['current_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_groups_current_slug_patch_request'] is not None:
            _body_params = _params['api_v1_groups_current_slug_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1GroupsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/groups/{currentSlug}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_groups_post(self, api_v1_groups_post_request : ApiV1GroupsPostRequest, **kwargs) -> ApiV1GroupsPost200Response:  # noqa: E501
        """api_v1_groups_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_post(api_v1_groups_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_groups_post_request: (required)
        :type api_v1_groups_post_request: ApiV1GroupsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1GroupsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_groups_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_groups_post_with_http_info(api_v1_groups_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_groups_post_with_http_info(self, api_v1_groups_post_request : ApiV1GroupsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_groups_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_post_with_http_info(api_v1_groups_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_groups_post_request: (required)
        :type api_v1_groups_post_request: ApiV1GroupsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1GroupsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_groups_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_groups_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_groups_post_request'] is not None:
            _body_params = _params['api_v1_groups_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1GroupsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/groups', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_groups_slug_delete(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to delete")], **kwargs) -> ApiV1GroupsPost200Response:  # noqa: E501
        """api_v1_groups_slug_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_delete(slug, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to delete (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1GroupsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_groups_slug_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_groups_slug_delete_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_groups_slug_delete_with_http_info(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_groups_slug_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_delete_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to delete (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1GroupsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_groups_slug_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1GroupsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/groups/{slug}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_groups_slug_users_get(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to list users for")], offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th user.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of users to return.")] = None, username : Annotated[Optional[StrictStr], Field(description="The username to search for.")] = None, **kwargs) -> ApiV1GroupsSlugUsersGet200Response:  # noqa: E501
        """api_v1_groups_slug_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_users_get(slug, offset, limit, username, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to list users for (required)
        :type slug: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th user.
        :type offset: float
        :param limit: The number of users to return.
        :type limit: float
        :param username: The username to search for.
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1GroupsSlugUsersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_groups_slug_users_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_groups_slug_users_get_with_http_info(slug, offset, limit, username, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_groups_slug_users_get_with_http_info(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to list users for")], offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th user.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of users to return.")] = None, username : Annotated[Optional[StrictStr], Field(description="The username to search for.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_groups_slug_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_users_get_with_http_info(slug, offset, limit, username, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to list users for (required)
        :type slug: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th user.
        :type offset: float
        :param limit: The number of users to return.
        :type limit: float
        :param username: The username to search for.
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1GroupsSlugUsersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'offset',
            'limit',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_groups_slug_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1GroupsSlugUsersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/groups/{slug}/users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_groups_slug_users_username_delete(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to remove the user from.")], username : Annotated[StrictStr, Field(..., description="The username of the user to remove from the group.")], **kwargs) -> ApiV1GroupsSlugUsersUsernamePost200Response:  # noqa: E501
        """api_v1_groups_slug_users_username_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_users_username_delete(slug, username, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to remove the user from. (required)
        :type slug: str
        :param username: The username of the user to remove from the group. (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1GroupsSlugUsersUsernamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_groups_slug_users_username_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_groups_slug_users_username_delete_with_http_info(slug, username, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_groups_slug_users_username_delete_with_http_info(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to remove the user from.")], username : Annotated[StrictStr, Field(..., description="The username of the user to remove from the group.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_groups_slug_users_username_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_users_username_delete_with_http_info(slug, username, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to remove the user from. (required)
        :type slug: str
        :param username: The username of the user to remove from the group. (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1GroupsSlugUsersUsernamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_groups_slug_users_username_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['username'] is not None:
            _path_params['username'] = _params['username']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1GroupsSlugUsersUsernamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/groups/{slug}/users/{username}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_groups_slug_users_username_post(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to add the user to.")], username : Annotated[StrictStr, Field(..., description="The username of the user to add to the group.")], **kwargs) -> ApiV1GroupsSlugUsersUsernamePost200Response:  # noqa: E501
        """api_v1_groups_slug_users_username_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_users_username_post(slug, username, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to add the user to. (required)
        :type slug: str
        :param username: The username of the user to add to the group. (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1GroupsSlugUsersUsernamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_groups_slug_users_username_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_groups_slug_users_username_post_with_http_info(slug, username, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_groups_slug_users_username_post_with_http_info(self, slug : Annotated[StrictStr, Field(..., description="The slug of the group to add the user to.")], username : Annotated[StrictStr, Field(..., description="The username of the user to add to the group.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_groups_slug_users_username_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_groups_slug_users_username_post_with_http_info(slug, username, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the group to add the user to. (required)
        :type slug: str
        :param username: The username of the user to add to the group. (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1GroupsSlugUsersUsernamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_groups_slug_users_username_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']

        if _params['username'] is not None:
            _path_params['username'] = _params['username']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1GroupsSlugUsersUsernamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/groups/{slug}/users/{username}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_identities_get(self, org_id : Annotated[StrictStr, Field(..., description="The ID of the organization to list identities.")], **kwargs) -> ApiV1IdentitiesGet200Response:  # noqa: E501
        """api_v1_identities_get  # noqa: E501

        List identities  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_get(org_id, async_req=True)
        >>> result = thread.get()

        :param org_id: The ID of the organization to list identities. (required)
        :type org_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_identities_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_identities_get_with_http_info(org_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_identities_get_with_http_info(self, org_id : Annotated[StrictStr, Field(..., description="The ID of the organization to list identities.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_identities_get  # noqa: E501

        List identities  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_get_with_http_info(org_id, async_req=True)
        >>> result = thread.get()

        :param org_id: The ID of the organization to list identities. (required)
        :type org_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_identities_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('org_id') is not None:  # noqa: E501
            _query_params.append(('orgId', _params['org_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/identities', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_identities_identity_id_delete(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to delete.")], **kwargs) -> ApiV1IdentitiesPost200Response:  # noqa: E501
        """api_v1_identities_identity_id_delete  # noqa: E501

        Delete identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_delete(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to delete. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_identities_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_identities_identity_id_delete_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_identities_identity_id_delete_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_identities_identity_id_delete  # noqa: E501

        Delete identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_delete_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to delete. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_identities_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/identities/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_identities_identity_id_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get details.")], **kwargs) -> ApiV1IdentitiesIdentityIdGet200Response:  # noqa: E501
        """api_v1_identities_identity_id_get  # noqa: E501

        Get an identity by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to get details. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_identities_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_identities_identity_id_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_identities_identity_id_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get details.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_identities_identity_id_get  # noqa: E501

        Get an identity by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to get details. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_identities_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/identities/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_identities_identity_id_identity_memberships_get(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get details.")], **kwargs) -> ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response:  # noqa: E501
        """api_v1_identities_identity_id_identity_memberships_get  # noqa: E501

        List project memberships that identity with id is part of  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_identity_memberships_get(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to get details. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_identities_identity_id_identity_memberships_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_identities_identity_id_identity_memberships_get_with_http_info(identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_identities_identity_id_identity_memberships_get_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get details.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_identities_identity_id_identity_memberships_get  # noqa: E501

        List project memberships that identity with id is part of  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_identity_memberships_get_with_http_info(identity_id, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to get details. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_identities_identity_id_identity_memberships_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/identities/{identityId}/identity-memberships', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_identities_identity_id_patch(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update.")], api_v1_identities_identity_id_patch_request : Optional[ApiV1IdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiV1IdentitiesPost200Response:  # noqa: E501
        """api_v1_identities_identity_id_patch  # noqa: E501

        Update identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_patch(identity_id, api_v1_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update. (required)
        :type identity_id: str
        :param api_v1_identities_identity_id_patch_request:
        :type api_v1_identities_identity_id_patch_request: ApiV1IdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_identities_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_identities_identity_id_patch_with_http_info(identity_id, api_v1_identities_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_identities_identity_id_patch_with_http_info(self, identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update.")], api_v1_identities_identity_id_patch_request : Optional[ApiV1IdentitiesIdentityIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_identities_identity_id_patch  # noqa: E501

        Update identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_identity_id_patch_with_http_info(identity_id, api_v1_identities_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param identity_id: The ID of the identity to update. (required)
        :type identity_id: str
        :param api_v1_identities_identity_id_patch_request:
        :type api_v1_identities_identity_id_patch_request: ApiV1IdentitiesIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identity_id',
            'api_v1_identities_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_identities_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_identities_identity_id_patch_request'] is not None:
            _body_params = _params['api_v1_identities_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/identities/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_identities_post(self, api_v1_identities_post_request : ApiV1IdentitiesPostRequest, **kwargs) -> ApiV1IdentitiesPost200Response:  # noqa: E501
        """api_v1_identities_post  # noqa: E501

        Create identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_post(api_v1_identities_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_identities_post_request: (required)
        :type api_v1_identities_post_request: ApiV1IdentitiesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_identities_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_identities_post_with_http_info(api_v1_identities_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_identities_post_with_http_info(self, api_v1_identities_post_request : ApiV1IdentitiesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_identities_post  # noqa: E501

        Create identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_identities_post_with_http_info(api_v1_identities_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_identities_post_request: (required)
        :type api_v1_identities_post_request: ApiV1IdentitiesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_identities_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_identities_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_identities_post_request'] is not None:
            _body_params = _params['api_v1_identities_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/identities', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_access_token_post(self, api_v1_integration_auth_access_token_post_request : ApiV1IntegrationAuthAccessTokenPostRequest, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGet200Response:  # noqa: E501
        """api_v1_integration_auth_access_token_post  # noqa: E501

        Create the integration authentication object required for syncing secrets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_access_token_post(api_v1_integration_auth_access_token_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_integration_auth_access_token_post_request: (required)
        :type api_v1_integration_auth_access_token_post_request: ApiV1IntegrationAuthAccessTokenPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_access_token_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_access_token_post_with_http_info(api_v1_integration_auth_access_token_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_access_token_post_with_http_info(self, api_v1_integration_auth_access_token_post_request : ApiV1IntegrationAuthAccessTokenPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_access_token_post  # noqa: E501

        Create the integration authentication object required for syncing secrets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_access_token_post_with_http_info(api_v1_integration_auth_access_token_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_integration_auth_access_token_post_request: (required)
        :type api_v1_integration_auth_access_token_post_request: ApiV1IntegrationAuthAccessTokenPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_integration_auth_access_token_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_access_token_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_integration_auth_access_token_post_request'] is not None:
            _body_params = _params['api_v1_integration_auth_access_token_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/access-token', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_delete(self, integration : Annotated[StrictStr, Field(..., description="The slug of the integration to be unauthorized.")], project_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the integration auth from.")], **kwargs) -> ApiV1IntegrationAuthDelete200Response:  # noqa: E501
        """api_v1_integration_auth_delete  # noqa: E501

        Remove all integration's auth object from the project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_delete(integration, project_id, async_req=True)
        >>> result = thread.get()

        :param integration: The slug of the integration to be unauthorized. (required)
        :type integration: str
        :param project_id: The ID of the project to delete the integration auth from. (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_delete_with_http_info(integration, project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_delete_with_http_info(self, integration : Annotated[StrictStr, Field(..., description="The slug of the integration to be unauthorized.")], project_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the integration auth from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_delete  # noqa: E501

        Remove all integration's auth object from the project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_delete_with_http_info(integration, project_id, async_req=True)
        >>> result = thread.get()

        :param integration: The slug of the integration to be unauthorized. (required)
        :type integration: str
        :param project_id: The ID of the project to delete the integration auth from. (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration',
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('integration') is not None:  # noqa: E501
            _query_params.append(('integration', _params['integration']))

        if _params.get('project_id') is not None:  # noqa: E501
            _query_params.append(('projectId', _params['project_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_apps_get(self, integration_auth_id : StrictStr, team_id : Optional[StrictStr] = None, workspace_slug : Optional[StrictStr] = None, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_apps_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_apps_get(integration_auth_id, team_id, workspace_slug, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param team_id:
        :type team_id: str
        :param workspace_slug:
        :type workspace_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_apps_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_apps_get_with_http_info(integration_auth_id, team_id, workspace_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_apps_get_with_http_info(self, integration_auth_id : StrictStr, team_id : Optional[StrictStr] = None, workspace_slug : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_apps_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_apps_get_with_http_info(integration_auth_id, team_id, workspace_slug, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param team_id:
        :type team_id: str
        :param workspace_slug:
        :type workspace_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id',
            'team_id',
            'workspace_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_apps_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('team_id') is not None:  # noqa: E501
            _query_params.append(('teamId', _params['team_id']))

        if _params.get('workspace_slug') is not None:  # noqa: E501
            _query_params.append(('workspaceSlug', _params['workspace_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdAppsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/apps', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get(self, region : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get(region, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param region: (required)
        :type region: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get_with_http_info(region, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get_with_http_info(self, region : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get_with_http_info(region, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param region: (required)
        :type region: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'region',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_aws_secrets_manager_kms_keys_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('region') is not None:  # noqa: E501
            _query_params.append(('region', _params['region']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdAwsSecretsManagerKmsKeysGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/aws-secrets-manager/kms-keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get(self, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get_with_http_info(self, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_bitbucket_workspaces_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdBitbucketWorkspacesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/bitbucket/workspaces', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_checkly_groups_get(self, account_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_checkly_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_checkly_groups_get(account_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param account_id: (required)
        :type account_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_checkly_groups_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_checkly_groups_get_with_http_info(account_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_checkly_groups_get_with_http_info(self, account_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_checkly_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_checkly_groups_get_with_http_info(account_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param account_id: (required)
        :type account_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_checkly_groups_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('account_id') is not None:  # noqa: E501
            _query_params.append(('accountId', _params['account_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdChecklyGroupsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/checkly/groups', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_delete(self, integration_auth_id : Annotated[StrictStr, Field(..., description="The id of integration authentication object to delete.")], **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_delete  # noqa: E501

        Remove an integration auth object by object id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_delete(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: The id of integration authentication object to delete. (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_delete_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_delete_with_http_info(self, integration_auth_id : Annotated[StrictStr, Field(..., description="The id of integration authentication object to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_delete  # noqa: E501

        Remove an integration auth object by object id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_delete_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: The id of integration authentication object to delete. (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_get(self, integration_auth_id : Annotated[StrictStr, Field(..., description="The id of integration authentication object.")], **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_get  # noqa: E501

        Get details of an integration authorization by auth object id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_get(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: The id of integration authentication object. (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_get_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_get_with_http_info(self, integration_auth_id : Annotated[StrictStr, Field(..., description="The id of integration authentication object.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_get  # noqa: E501

        Get details of an integration authorization by auth object id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_get_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: The id of integration authentication object. (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_github_envs_get(self, repo_owner : StrictStr, repo_name : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_github_envs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_github_envs_get(repo_owner, repo_name, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param repo_owner: (required)
        :type repo_owner: str
        :param repo_name: (required)
        :type repo_name: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_github_envs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_github_envs_get_with_http_info(repo_owner, repo_name, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_github_envs_get_with_http_info(self, repo_owner : StrictStr, repo_name : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_github_envs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_github_envs_get_with_http_info(repo_owner, repo_name, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param repo_owner: (required)
        :type repo_owner: str
        :param repo_name: (required)
        :type repo_name: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'repo_owner',
            'repo_name',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_github_envs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('repo_owner') is not None:  # noqa: E501
            _query_params.append(('repoOwner', _params['repo_owner']))

        if _params.get('repo_name') is not None:  # noqa: E501
            _query_params.append(('repoName', _params['repo_name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGithubEnvsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/github/envs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_github_orgs_get(self, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_github_orgs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_github_orgs_get(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_github_orgs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_github_orgs_get_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_github_orgs_get_with_http_info(self, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_github_orgs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_github_orgs_get_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_github_orgs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/github/orgs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_heroku_pipelines_get(self, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_heroku_pipelines_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_heroku_pipelines_get(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_heroku_pipelines_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_heroku_pipelines_get_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_heroku_pipelines_get_with_http_info(self, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_heroku_pipelines_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_heroku_pipelines_get_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_heroku_pipelines_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdHerokuPipelinesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/heroku/pipelines', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get_with_http_info(app_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get_with_http_info(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get_with_http_info(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'app_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_northflank_secret_groups_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('app_id') is not None:  # noqa: E501
            _query_params.append(('appId', _params['app_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdNorthflankSecretGroupsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/northflank/secret-groups', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_apps_get(self, environment_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_apps_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_apps_get(environment_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param environment_id: (required)
        :type environment_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_qovery_apps_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_qovery_apps_get_with_http_info(environment_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_apps_get_with_http_info(self, environment_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_apps_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_apps_get_with_http_info(environment_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param environment_id: (required)
        :type environment_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'environment_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_qovery_apps_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('environment_id') is not None:  # noqa: E501
            _query_params.append(('environmentId', _params['environment_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdQoveryAppsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/qovery/apps', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_containers_get(self, environment_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_containers_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_containers_get(environment_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param environment_id: (required)
        :type environment_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_qovery_containers_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_qovery_containers_get_with_http_info(environment_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_containers_get_with_http_info(self, environment_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_containers_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_containers_get_with_http_info(environment_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param environment_id: (required)
        :type environment_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'environment_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_qovery_containers_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('environment_id') is not None:  # noqa: E501
            _query_params.append(('environmentId', _params['environment_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdQoveryContainersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/qovery/containers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_environments_get(self, project_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_environments_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_environments_get(project_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_qovery_environments_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_qovery_environments_get_with_http_info(project_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_environments_get_with_http_info(self, project_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_environments_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_environments_get_with_http_info(project_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_qovery_environments_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('project_id') is not None:  # noqa: E501
            _query_params.append(('projectId', _params['project_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/qovery/environments', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_jobs_get(self, environment_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_jobs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_jobs_get(environment_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param environment_id: (required)
        :type environment_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_qovery_jobs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_qovery_jobs_get_with_http_info(environment_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_jobs_get_with_http_info(self, environment_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_jobs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_jobs_get_with_http_info(environment_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param environment_id: (required)
        :type environment_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'environment_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_qovery_jobs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('environment_id') is not None:  # noqa: E501
            _query_params.append(('environmentId', _params['environment_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdQoveryJobsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/qovery/jobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_orgs_get(self, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_orgs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_orgs_get(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_qovery_orgs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_qovery_orgs_get_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_orgs_get_with_http_info(self, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_orgs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_orgs_get_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_qovery_orgs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGithubOrgsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/qovery/orgs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_projects_get(self, org_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_projects_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_projects_get(org_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param org_id: (required)
        :type org_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_qovery_projects_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_qovery_projects_get_with_http_info(org_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_qovery_projects_get_with_http_info(self, org_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_qovery_projects_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_qovery_projects_get_with_http_info(org_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param org_id: (required)
        :type org_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_qovery_projects_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('org_id') is not None:  # noqa: E501
            _query_params.append(('orgId', _params['org_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdQoveryProjectsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/qovery/projects', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_railway_environments_get(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_railway_environments_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_railway_environments_get(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_railway_environments_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_railway_environments_get_with_http_info(app_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_railway_environments_get_with_http_info(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_railway_environments_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_railway_environments_get_with_http_info(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'app_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_railway_environments_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('app_id') is not None:  # noqa: E501
            _query_params.append(('appId', _params['app_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdQoveryEnvironmentsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/railway/environments', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_railway_services_get(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_railway_services_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_railway_services_get(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_railway_services_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_railway_services_get_with_http_info(app_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_railway_services_get_with_http_info(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_railway_services_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_railway_services_get_with_http_info(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'app_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_railway_services_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('app_id') is not None:  # noqa: E501
            _query_params.append(('appId', _params['app_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdRailwayServicesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/railway/services', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get_with_http_info(app_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get_with_http_info(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get_with_http_info(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'app_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_teamcity_build_configs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('app_id') is not None:  # noqa: E501
            _query_params.append(('appId', _params['app_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdTeamcityBuildConfigsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/teamcity/build-configs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_teams_get(self, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_teams_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_teams_get(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_teams_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_teams_get_with_http_info(integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_teams_get_with_http_info(self, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_teams_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_teams_get_with_http_info(integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_teams_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdTeamsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/teams', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_vercel_branches_get(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_vercel_branches_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_vercel_branches_get(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_auth_id_vercel_branches_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_auth_id_vercel_branches_get_with_http_info(app_id, integration_auth_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_auth_id_vercel_branches_get_with_http_info(self, app_id : StrictStr, integration_auth_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_auth_id_vercel_branches_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_auth_id_vercel_branches_get_with_http_info(app_id, integration_auth_id, async_req=True)
        >>> result = thread.get()

        :param app_id: (required)
        :type app_id: str
        :param integration_auth_id: (required)
        :type integration_auth_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'app_id',
            'integration_auth_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_auth_id_vercel_branches_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_auth_id'] is not None:
            _path_params['integrationAuthId'] = _params['integration_auth_id']


        # process the query parameters
        _query_params = []
        if _params.get('app_id') is not None:  # noqa: E501
            _query_params.append(('appId', _params['app_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdVercelBranchesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/{integrationAuthId}/vercel/branches', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_integration_options_get(self, **kwargs) -> ApiV1IntegrationAuthIntegrationOptionsGet200Response:  # noqa: E501
        """api_v1_integration_auth_integration_options_get  # noqa: E501

        List of integrations available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_options_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationOptionsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_integration_options_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_integration_options_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_integration_options_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_integration_options_get  # noqa: E501

        List of integrations available.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_integration_options_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationOptionsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_integration_options_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationOptionsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/integration-options', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_auth_oauth_token_post(self, api_v1_integration_auth_oauth_token_post_request : ApiV1IntegrationAuthOauthTokenPostRequest, **kwargs) -> ApiV1IntegrationAuthIntegrationAuthIdGet200Response:  # noqa: E501
        """api_v1_integration_auth_oauth_token_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_oauth_token_post(api_v1_integration_auth_oauth_token_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_integration_auth_oauth_token_post_request: (required)
        :type api_v1_integration_auth_oauth_token_post_request: ApiV1IntegrationAuthOauthTokenPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationAuthIntegrationAuthIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_auth_oauth_token_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_auth_oauth_token_post_with_http_info(api_v1_integration_auth_oauth_token_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_auth_oauth_token_post_with_http_info(self, api_v1_integration_auth_oauth_token_post_request : ApiV1IntegrationAuthOauthTokenPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_auth_oauth_token_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_auth_oauth_token_post_with_http_info(api_v1_integration_auth_oauth_token_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_integration_auth_oauth_token_post_request: (required)
        :type api_v1_integration_auth_oauth_token_post_request: ApiV1IntegrationAuthOauthTokenPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationAuthIntegrationAuthIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_integration_auth_oauth_token_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_auth_oauth_token_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_integration_auth_oauth_token_post_request'] is not None:
            _body_params = _params['api_v1_integration_auth_oauth_token_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationAuthIntegrationAuthIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration-auth/oauth-token', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_integration_id_delete(self, integration_id : Annotated[StrictStr, Field(..., description="The ID of the integration object.")], should_delete_integration_secrets : Optional[StrictStr] = None, **kwargs) -> ApiV1IntegrationPost200Response:  # noqa: E501
        """api_v1_integration_integration_id_delete  # noqa: E501

        Remove an integration using the integration object ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_integration_id_delete(integration_id, should_delete_integration_secrets, async_req=True)
        >>> result = thread.get()

        :param integration_id: The ID of the integration object. (required)
        :type integration_id: str
        :param should_delete_integration_secrets:
        :type should_delete_integration_secrets: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_integration_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_integration_id_delete_with_http_info(integration_id, should_delete_integration_secrets, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_integration_id_delete_with_http_info(self, integration_id : Annotated[StrictStr, Field(..., description="The ID of the integration object.")], should_delete_integration_secrets : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_integration_id_delete  # noqa: E501

        Remove an integration using the integration object ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_integration_id_delete_with_http_info(integration_id, should_delete_integration_secrets, async_req=True)
        >>> result = thread.get()

        :param integration_id: The ID of the integration object. (required)
        :type integration_id: str
        :param should_delete_integration_secrets:
        :type should_delete_integration_secrets: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_id',
            'should_delete_integration_secrets'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_integration_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_id'] is not None:
            _path_params['integrationId'] = _params['integration_id']


        # process the query parameters
        _query_params = []
        if _params.get('should_delete_integration_secrets') is not None:  # noqa: E501
            _query_params.append(('shouldDeleteIntegrationSecrets', _params['should_delete_integration_secrets']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration/{integrationId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_integration_id_patch(self, integration_id : Annotated[StrictStr, Field(..., description="The ID of the integration object.")], api_v1_integration_integration_id_patch_request : ApiV1IntegrationIntegrationIdPatchRequest, **kwargs) -> ApiV1IntegrationPost200Response:  # noqa: E501
        """api_v1_integration_integration_id_patch  # noqa: E501

        Update an integration by integration id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_integration_id_patch(integration_id, api_v1_integration_integration_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param integration_id: The ID of the integration object. (required)
        :type integration_id: str
        :param api_v1_integration_integration_id_patch_request: (required)
        :type api_v1_integration_integration_id_patch_request: ApiV1IntegrationIntegrationIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_integration_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_integration_id_patch_with_http_info(integration_id, api_v1_integration_integration_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_integration_id_patch_with_http_info(self, integration_id : Annotated[StrictStr, Field(..., description="The ID of the integration object.")], api_v1_integration_integration_id_patch_request : ApiV1IntegrationIntegrationIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_integration_id_patch  # noqa: E501

        Update an integration by integration id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_integration_id_patch_with_http_info(integration_id, api_v1_integration_integration_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param integration_id: The ID of the integration object. (required)
        :type integration_id: str
        :param api_v1_integration_integration_id_patch_request: (required)
        :type api_v1_integration_integration_id_patch_request: ApiV1IntegrationIntegrationIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_id',
            'api_v1_integration_integration_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_integration_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_id'] is not None:
            _path_params['integrationId'] = _params['integration_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_integration_integration_id_patch_request'] is not None:
            _body_params = _params['api_v1_integration_integration_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration/{integrationId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_integration_id_sync_post(self, integration_id : Annotated[StrictStr, Field(..., description="The ID of the integration object to manually sync")], **kwargs) -> ApiV1IntegrationPost200Response:  # noqa: E501
        """api_v1_integration_integration_id_sync_post  # noqa: E501

        Manually trigger sync of an integration by integration id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_integration_id_sync_post(integration_id, async_req=True)
        >>> result = thread.get()

        :param integration_id: The ID of the integration object to manually sync (required)
        :type integration_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_integration_id_sync_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_integration_id_sync_post_with_http_info(integration_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_integration_id_sync_post_with_http_info(self, integration_id : Annotated[StrictStr, Field(..., description="The ID of the integration object to manually sync")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_integration_id_sync_post  # noqa: E501

        Manually trigger sync of an integration by integration id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_integration_id_sync_post_with_http_info(integration_id, async_req=True)
        >>> result = thread.get()

        :param integration_id: The ID of the integration object to manually sync (required)
        :type integration_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'integration_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_integration_id_sync_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['integration_id'] is not None:
            _path_params['integrationId'] = _params['integration_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration/{integrationId}/sync', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_integration_post(self, api_v1_integration_post_request : ApiV1IntegrationPostRequest, **kwargs) -> ApiV1IntegrationPost200Response:  # noqa: E501
        """api_v1_integration_post  # noqa: E501

        Create an integration to sync secrets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_post(api_v1_integration_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_integration_post_request: (required)
        :type api_v1_integration_post_request: ApiV1IntegrationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IntegrationPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_integration_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_integration_post_with_http_info(api_v1_integration_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_integration_post_with_http_info(self, api_v1_integration_post_request : ApiV1IntegrationPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_integration_post  # noqa: E501

        Create an integration to sync secrets.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_integration_post_with_http_info(api_v1_integration_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_integration_post_request: (required)
        :type api_v1_integration_post_request: ApiV1IntegrationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IntegrationPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_integration_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_integration_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_integration_post_request'] is not None:
            _body_params = _params['api_v1_integration_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IntegrationPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/integration', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_invite_org_signup_post(self, api_v1_invite_org_signup_post_request : ApiV1InviteOrgSignupPostRequest, **kwargs) -> ApiV1InviteOrgSignupPost200Response:  # noqa: E501
        """api_v1_invite_org_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_invite_org_signup_post(api_v1_invite_org_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_invite_org_signup_post_request: (required)
        :type api_v1_invite_org_signup_post_request: ApiV1InviteOrgSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1InviteOrgSignupPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_invite_org_signup_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_invite_org_signup_post_with_http_info(api_v1_invite_org_signup_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_invite_org_signup_post_with_http_info(self, api_v1_invite_org_signup_post_request : ApiV1InviteOrgSignupPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_invite_org_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_invite_org_signup_post_with_http_info(api_v1_invite_org_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_invite_org_signup_post_request: (required)
        :type api_v1_invite_org_signup_post_request: ApiV1InviteOrgSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1InviteOrgSignupPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_invite_org_signup_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_invite_org_signup_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_invite_org_signup_post_request'] is not None:
            _body_params = _params['api_v1_invite_org_signup_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1InviteOrgSignupPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/invite-org/signup', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_invite_org_verify_post(self, api_v1_invite_org_verify_post_request : ApiV1InviteOrgVerifyPostRequest, **kwargs) -> ApiV1InviteOrgVerifyPost200Response:  # noqa: E501
        """api_v1_invite_org_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_invite_org_verify_post(api_v1_invite_org_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_invite_org_verify_post_request: (required)
        :type api_v1_invite_org_verify_post_request: ApiV1InviteOrgVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1InviteOrgVerifyPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_invite_org_verify_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_invite_org_verify_post_with_http_info(api_v1_invite_org_verify_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_invite_org_verify_post_with_http_info(self, api_v1_invite_org_verify_post_request : ApiV1InviteOrgVerifyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_invite_org_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_invite_org_verify_post_with_http_info(api_v1_invite_org_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_invite_org_verify_post_request: (required)
        :type api_v1_invite_org_verify_post_request: ApiV1InviteOrgVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1InviteOrgVerifyPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_invite_org_verify_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_invite_org_verify_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_invite_org_verify_post_request'] is not None:
            _body_params = _params['api_v1_invite_org_verify_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1InviteOrgVerifyPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/invite-org/verify', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_config_id_group_maps_get(self, config_id : StrictStr, **kwargs) -> List[ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner]:  # noqa: E501
        """api_v1_ldap_config_config_id_group_maps_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_group_maps_get(config_id, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_config_id_group_maps_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_config_id_group_maps_get_with_http_info(config_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_config_id_group_maps_get_with_http_info(self, config_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_config_id_group_maps_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_group_maps_get_with_http_info(config_id, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'config_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_config_id_group_maps_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['config_id'] is not None:
            _path_params['configId'] = _params['config_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[ApiV1LdapConfigConfigIdGroupMapsGet200ResponseInner]",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config/{configId}/group-maps', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_config_id_group_maps_group_map_id_delete(self, config_id : StrictStr, group_map_id : StrictStr, **kwargs) -> ApiV1LdapConfigConfigIdGroupMapsPost200Response:  # noqa: E501
        """api_v1_ldap_config_config_id_group_maps_group_map_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_group_maps_group_map_id_delete(config_id, group_map_id, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param group_map_id: (required)
        :type group_map_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1LdapConfigConfigIdGroupMapsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_config_id_group_maps_group_map_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_config_id_group_maps_group_map_id_delete_with_http_info(config_id, group_map_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_config_id_group_maps_group_map_id_delete_with_http_info(self, config_id : StrictStr, group_map_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_config_id_group_maps_group_map_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_group_maps_group_map_id_delete_with_http_info(config_id, group_map_id, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param group_map_id: (required)
        :type group_map_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1LdapConfigConfigIdGroupMapsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'config_id',
            'group_map_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_config_id_group_maps_group_map_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['config_id'] is not None:
            _path_params['configId'] = _params['config_id']

        if _params['group_map_id'] is not None:
            _path_params['groupMapId'] = _params['group_map_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1LdapConfigConfigIdGroupMapsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config/{configId}/group-maps/{groupMapId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_config_id_group_maps_post(self, config_id : StrictStr, api_v1_ldap_config_config_id_group_maps_post_request : ApiV1LdapConfigConfigIdGroupMapsPostRequest, **kwargs) -> ApiV1LdapConfigConfigIdGroupMapsPost200Response:  # noqa: E501
        """api_v1_ldap_config_config_id_group_maps_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_group_maps_post(config_id, api_v1_ldap_config_config_id_group_maps_post_request, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param api_v1_ldap_config_config_id_group_maps_post_request: (required)
        :type api_v1_ldap_config_config_id_group_maps_post_request: ApiV1LdapConfigConfigIdGroupMapsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1LdapConfigConfigIdGroupMapsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_config_id_group_maps_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_config_id_group_maps_post_with_http_info(config_id, api_v1_ldap_config_config_id_group_maps_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_config_id_group_maps_post_with_http_info(self, config_id : StrictStr, api_v1_ldap_config_config_id_group_maps_post_request : ApiV1LdapConfigConfigIdGroupMapsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_config_id_group_maps_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_group_maps_post_with_http_info(config_id, api_v1_ldap_config_config_id_group_maps_post_request, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param api_v1_ldap_config_config_id_group_maps_post_request: (required)
        :type api_v1_ldap_config_config_id_group_maps_post_request: ApiV1LdapConfigConfigIdGroupMapsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1LdapConfigConfigIdGroupMapsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'config_id',
            'api_v1_ldap_config_config_id_group_maps_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_config_id_group_maps_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['config_id'] is not None:
            _path_params['configId'] = _params['config_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_ldap_config_config_id_group_maps_post_request'] is not None:
            _body_params = _params['api_v1_ldap_config_config_id_group_maps_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1LdapConfigConfigIdGroupMapsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config/{configId}/group-maps', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_config_id_test_connection_post(self, config_id : StrictStr, **kwargs) -> bool:  # noqa: E501
        """api_v1_ldap_config_config_id_test_connection_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_test_connection_post(config_id, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bool
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_config_id_test_connection_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_config_id_test_connection_post_with_http_info(config_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_config_id_test_connection_post_with_http_info(self, config_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_config_id_test_connection_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_config_id_test_connection_post_with_http_info(config_id, async_req=True)
        >>> result = thread.get()

        :param config_id: (required)
        :type config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bool, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'config_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_config_id_test_connection_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['config_id'] is not None:
            _path_params['configId'] = _params['config_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "bool",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config/{configId}/test-connection', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_get(self, organization_id : StrictStr, **kwargs) -> ApiV1LdapConfigGet200Response:  # noqa: E501
        """api_v1_ldap_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1LdapConfigGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1LdapConfigGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('organization_id') is not None:  # noqa: E501
            _query_params.append(('organizationId', _params['organization_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1LdapConfigGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_patch(self, api_v1_ldap_config_patch_request : ApiV1LdapConfigPatchRequest, **kwargs) -> ApiV1LdapConfigPost200Response:  # noqa: E501
        """api_v1_ldap_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_patch(api_v1_ldap_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_ldap_config_patch_request: (required)
        :type api_v1_ldap_config_patch_request: ApiV1LdapConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1LdapConfigPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_patch_with_http_info(api_v1_ldap_config_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_patch_with_http_info(self, api_v1_ldap_config_patch_request : ApiV1LdapConfigPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_patch_with_http_info(api_v1_ldap_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_ldap_config_patch_request: (required)
        :type api_v1_ldap_config_patch_request: ApiV1LdapConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1LdapConfigPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_ldap_config_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_ldap_config_patch_request'] is not None:
            _body_params = _params['api_v1_ldap_config_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1LdapConfigPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_config_post(self, api_v1_ldap_config_post_request : ApiV1LdapConfigPostRequest, **kwargs) -> ApiV1LdapConfigPost200Response:  # noqa: E501
        """api_v1_ldap_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_post(api_v1_ldap_config_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_ldap_config_post_request: (required)
        :type api_v1_ldap_config_post_request: ApiV1LdapConfigPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1LdapConfigPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_config_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_config_post_with_http_info(api_v1_ldap_config_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_config_post_with_http_info(self, api_v1_ldap_config_post_request : ApiV1LdapConfigPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_config_post_with_http_info(api_v1_ldap_config_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_ldap_config_post_request: (required)
        :type api_v1_ldap_config_post_request: ApiV1LdapConfigPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1LdapConfigPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_ldap_config_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_config_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_ldap_config_post_request'] is not None:
            _body_params = _params['api_v1_ldap_config_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1LdapConfigPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/ldap/config', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_ldap_login_post(self, api_v1_ldap_login_post_request : ApiV1LdapLoginPostRequest, **kwargs) -> None:  # noqa: E501
        """api_v1_ldap_login_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_login_post(api_v1_ldap_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_ldap_login_post_request: (required)
        :type api_v1_ldap_login_post_request: ApiV1LdapLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_ldap_login_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_ldap_login_post_with_http_info(api_v1_ldap_login_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_ldap_login_post_with_http_info(self, api_v1_ldap_login_post_request : ApiV1LdapLoginPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_ldap_login_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_ldap_login_post_with_http_info(api_v1_ldap_login_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_ldap_login_post_request: (required)
        :type api_v1_ldap_login_post_request: ApiV1LdapLoginPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'api_v1_ldap_login_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_ldap_login_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_ldap_login_post_request'] is not None:
            _body_params = _params['api_v1_ldap_login_post_request']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/ldap/login', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_admin_projects_get(self, search : Optional[StrictStr] = None, offset : Optional[Union[StrictFloat, StrictInt]] = None, limit : Optional[Union[confloat(le=100, strict=True), conint(le=100.0, strict=True)]] = None, **kwargs) -> ApiV1OrganizationAdminProjectsGet200Response:  # noqa: E501
        """api_v1_organization_admin_projects_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_admin_projects_get(search, offset, limit, async_req=True)
        >>> result = thread.get()

        :param search:
        :type search: str
        :param offset:
        :type offset: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationAdminProjectsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_admin_projects_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_admin_projects_get_with_http_info(search, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_admin_projects_get_with_http_info(self, search : Optional[StrictStr] = None, offset : Optional[Union[StrictFloat, StrictInt]] = None, limit : Optional[Union[confloat(le=100, strict=True), conint(le=100.0, strict=True)]] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_admin_projects_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_admin_projects_get_with_http_info(search, offset, limit, async_req=True)
        >>> result = thread.get()

        :param search:
        :type search: str
        :param offset:
        :type offset: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationAdminProjectsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'search',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_admin_projects_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('search') is not None:  # noqa: E501
            _query_params.append(('search', _params['search']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationAdminProjectsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization-admin/projects', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_admin_projects_project_id_grant_admin_access_post(self, project_id : StrictStr, **kwargs) -> ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response:  # noqa: E501
        """api_v1_organization_admin_projects_project_id_grant_admin_access_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_admin_projects_project_id_grant_admin_access_post(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_admin_projects_project_id_grant_admin_access_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_admin_projects_project_id_grant_admin_access_post_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_admin_projects_project_id_grant_admin_access_post_with_http_info(self, project_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_admin_projects_project_id_grant_admin_access_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_admin_projects_project_id_grant_admin_access_post_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_admin_projects_project_id_grant_admin_access_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization-admin/projects/{projectId}/grant-admin-access', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_get(self, **kwargs) -> ApiV1OrganizationGet200Response:  # noqa: E501
        """api_v1_organization_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_get(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdGet200Response:  # noqa: E501
        """api_v1_organization_organization_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_groups_get(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to list groups for.")], **kwargs) -> ApiV1OrganizationOrganizationIdGroupsGet200Response:  # noqa: E501
        """api_v1_organization_organization_id_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_groups_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to list groups for. (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdGroupsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_groups_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_groups_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_groups_get_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to list groups for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_groups_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to list groups for. (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdGroupsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_groups_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdGroupsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/groups', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_incident_contact_org_get(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response:  # noqa: E501
        """api_v1_organization_organization_id_incident_contact_org_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_incident_contact_org_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_incident_contact_org_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_incident_contact_org_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_incident_contact_org_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_incident_contact_org_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_incident_contact_org_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_incident_contact_org_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdIncidentContactOrgGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/incidentContactOrg', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete(self, organization_id : StrictStr, incident_contact_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response:  # noqa: E501
        """api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete(organization_id, incident_contact_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param incident_contact_id: (required)
        :type incident_contact_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete_with_http_info(organization_id, incident_contact_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete_with_http_info(self, organization_id : StrictStr, incident_contact_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete_with_http_info(organization_id, incident_contact_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param incident_contact_id: (required)
        :type incident_contact_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'incident_contact_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_incident_contact_org_incident_contact_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['incident_contact_id'] is not None:
            _path_params['incidentContactId'] = _params['incident_contact_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/incidentContactOrg/{incidentContactId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_incident_contact_org_post(self, organization_id : StrictStr, api_v1_password_email_password_reset_post_request : ApiV1PasswordEmailPasswordResetPostRequest, **kwargs) -> ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response:  # noqa: E501
        """api_v1_organization_organization_id_incident_contact_org_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_incident_contact_org_post(organization_id, api_v1_password_email_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_password_email_password_reset_post_request: (required)
        :type api_v1_password_email_password_reset_post_request: ApiV1PasswordEmailPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_incident_contact_org_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_incident_contact_org_post_with_http_info(organization_id, api_v1_password_email_password_reset_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_incident_contact_org_post_with_http_info(self, organization_id : StrictStr, api_v1_password_email_password_reset_post_request : ApiV1PasswordEmailPasswordResetPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_incident_contact_org_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_incident_contact_org_post_with_http_info(organization_id, api_v1_password_email_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_password_email_password_reset_post_request: (required)
        :type api_v1_password_email_password_reset_post_request: ApiV1PasswordEmailPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_password_email_password_reset_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_incident_contact_org_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_email_password_reset_post_request'] is not None:
            _body_params = _params['api_v1_password_email_password_reset_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdIncidentContactOrgPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/incidentContactOrg', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_patch(self, organization_id : StrictStr, api_v1_organization_organization_id_patch_request : Optional[ApiV1OrganizationOrganizationIdPatchRequest] = None, **kwargs) -> ApiV1OrganizationOrganizationIdPatch200Response:  # noqa: E501
        """api_v1_organization_organization_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_patch(organization_id, api_v1_organization_organization_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organization_organization_id_patch_request:
        :type api_v1_organization_organization_id_patch_request: ApiV1OrganizationOrganizationIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_patch_with_http_info(organization_id, api_v1_organization_organization_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_patch_with_http_info(self, organization_id : StrictStr, api_v1_organization_organization_id_patch_request : Optional[ApiV1OrganizationOrganizationIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_patch_with_http_info(organization_id, api_v1_organization_organization_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organization_organization_id_patch_request:
        :type api_v1_organization_organization_id_patch_request: ApiV1OrganizationOrganizationIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_organization_organization_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organization_organization_id_patch_request'] is not None:
            _body_params = _params['api_v1_organization_organization_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_permissions_get(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdPermissionsGet200Response:  # noqa: E501
        """api_v1_organization_organization_id_permissions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_permissions_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdPermissionsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_permissions_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_permissions_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_permissions_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_permissions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_permissions_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdPermissionsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_permissions_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdPermissionsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/permissions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_roles_get(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdRolesGet200Response:  # noqa: E501
        """api_v1_organization_organization_id_roles_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdRolesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_roles_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_roles_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_roles_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_roles_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdRolesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_roles_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdRolesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/roles', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_roles_post(self, organization_id : StrictStr, api_v1_organization_organization_id_roles_post_request : ApiV1OrganizationOrganizationIdRolesPostRequest, **kwargs) -> ApiV1OrganizationOrganizationIdRolesPost200Response:  # noqa: E501
        """api_v1_organization_organization_id_roles_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_post(organization_id, api_v1_organization_organization_id_roles_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organization_organization_id_roles_post_request: (required)
        :type api_v1_organization_organization_id_roles_post_request: ApiV1OrganizationOrganizationIdRolesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_roles_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_roles_post_with_http_info(organization_id, api_v1_organization_organization_id_roles_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_roles_post_with_http_info(self, organization_id : StrictStr, api_v1_organization_organization_id_roles_post_request : ApiV1OrganizationOrganizationIdRolesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_roles_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_post_with_http_info(organization_id, api_v1_organization_organization_id_roles_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organization_organization_id_roles_post_request: (required)
        :type api_v1_organization_organization_id_roles_post_request: ApiV1OrganizationOrganizationIdRolesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_organization_organization_id_roles_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_roles_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organization_organization_id_roles_post_request'] is not None:
            _body_params = _params['api_v1_organization_organization_id_roles_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/roles', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_roles_role_id_delete(self, organization_id : StrictStr, role_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdRolesPost200Response:  # noqa: E501
        """api_v1_organization_organization_id_roles_role_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_role_id_delete(organization_id, role_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param role_id: (required)
        :type role_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_roles_role_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_roles_role_id_delete_with_http_info(organization_id, role_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_roles_role_id_delete_with_http_info(self, organization_id : StrictStr, role_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_roles_role_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_role_id_delete_with_http_info(organization_id, role_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param role_id: (required)
        :type role_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'role_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_roles_role_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['role_id'] is not None:
            _path_params['roleId'] = _params['role_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/roles/{roleId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_roles_role_id_get(self, organization_id : StrictStr, role_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdRolesPost200Response:  # noqa: E501
        """api_v1_organization_organization_id_roles_role_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_role_id_get(organization_id, role_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param role_id: (required)
        :type role_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_roles_role_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_roles_role_id_get_with_http_info(organization_id, role_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_roles_role_id_get_with_http_info(self, organization_id : StrictStr, role_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_roles_role_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_role_id_get_with_http_info(organization_id, role_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param role_id: (required)
        :type role_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'role_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_roles_role_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['role_id'] is not None:
            _path_params['roleId'] = _params['role_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/roles/{roleId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_roles_role_id_patch(self, organization_id : StrictStr, role_id : StrictStr, api_v1_organization_organization_id_roles_role_id_patch_request : ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, **kwargs) -> ApiV1OrganizationOrganizationIdRolesPost200Response:  # noqa: E501
        """api_v1_organization_organization_id_roles_role_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_role_id_patch(organization_id, role_id, api_v1_organization_organization_id_roles_role_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param role_id: (required)
        :type role_id: str
        :param api_v1_organization_organization_id_roles_role_id_patch_request: (required)
        :type api_v1_organization_organization_id_roles_role_id_patch_request: ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_roles_role_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_roles_role_id_patch_with_http_info(organization_id, role_id, api_v1_organization_organization_id_roles_role_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_roles_role_id_patch_with_http_info(self, organization_id : StrictStr, role_id : StrictStr, api_v1_organization_organization_id_roles_role_id_patch_request : ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_roles_role_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_roles_role_id_patch_with_http_info(organization_id, role_id, api_v1_organization_organization_id_roles_role_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param role_id: (required)
        :type role_id: str
        :param api_v1_organization_organization_id_roles_role_id_patch_request: (required)
        :type api_v1_organization_organization_id_roles_role_id_patch_request: ApiV1OrganizationOrganizationIdRolesRoleIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'role_id',
            'api_v1_organization_organization_id_roles_role_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_roles_role_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['role_id'] is not None:
            _path_params['roleId'] = _params['role_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organization_organization_id_roles_role_id_patch_request'] is not None:
            _body_params = _params['api_v1_organization_organization_id_roles_role_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/roles/{roleId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organization_organization_id_users_get(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdUsersGet200Response:  # noqa: E501
        """api_v1_organization_organization_id_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_users_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdUsersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organization_organization_id_users_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organization_organization_id_users_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organization_organization_id_users_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organization_organization_id_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organization_organization_id_users_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdUsersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organization_organization_id_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdUsersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organization/{organizationId}/users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_patch(self, organization_id : StrictStr, api_v1_organizations_organization_id_billing_details_patch_request : Optional[ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest] = None, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_patch(organization_id, api_v1_organizations_organization_id_billing_details_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_billing_details_patch_request:
        :type api_v1_organizations_organization_id_billing_details_patch_request: ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_patch_with_http_info(organization_id, api_v1_organizations_organization_id_billing_details_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_patch_with_http_info(self, organization_id : StrictStr, api_v1_organizations_organization_id_billing_details_patch_request : Optional[ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_patch_with_http_info(organization_id, api_v1_organizations_organization_id_billing_details_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_billing_details_patch_request:
        :type api_v1_organizations_organization_id_billing_details_patch_request: ApiV1OrganizationsOrganizationIdBillingDetailsPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_organizations_organization_id_billing_details_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organizations_organization_id_billing_details_patch_request'] is not None:
            _body_params = _params['api_v1_organizations_organization_id_billing_details_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_payment_methods_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_payment_methods_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_payment_methods_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_payment_methods_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_payment_methods_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_payment_methods_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_payment_methods_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_payment_methods_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_payment_methods_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details/payment-methods', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete(self, organization_id : StrictStr, pmt_method_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete(organization_id, pmt_method_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param pmt_method_id: (required)
        :type pmt_method_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete_with_http_info(organization_id, pmt_method_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete_with_http_info(self, organization_id : StrictStr, pmt_method_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete_with_http_info(organization_id, pmt_method_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param pmt_method_id: (required)
        :type pmt_method_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'pmt_method_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_payment_methods_pmt_method_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['pmt_method_id'] is not None:
            _path_params['pmtMethodId'] = _params['pmt_method_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details/payment-methods/{pmtMethodId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_payment_methods_post(self, organization_id : StrictStr, api_v1_organizations_organization_id_billing_details_payment_methods_post_request : ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_payment_methods_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_payment_methods_post(organization_id, api_v1_organizations_organization_id_billing_details_payment_methods_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_billing_details_payment_methods_post_request: (required)
        :type api_v1_organizations_organization_id_billing_details_payment_methods_post_request: ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_payment_methods_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_payment_methods_post_with_http_info(organization_id, api_v1_organizations_organization_id_billing_details_payment_methods_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_payment_methods_post_with_http_info(self, organization_id : StrictStr, api_v1_organizations_organization_id_billing_details_payment_methods_post_request : ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_payment_methods_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_payment_methods_post_with_http_info(organization_id, api_v1_organizations_organization_id_billing_details_payment_methods_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_billing_details_payment_methods_post_request: (required)
        :type api_v1_organizations_organization_id_billing_details_payment_methods_post_request: ApiV1OrganizationsOrganizationIdBillingDetailsPaymentMethodsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_organizations_organization_id_billing_details_payment_methods_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_payment_methods_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organizations_organization_id_billing_details_payment_methods_post_request'] is not None:
            _body_params = _params['api_v1_organizations_organization_id_billing_details_payment_methods_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details/payment-methods', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_tax_ids_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_tax_ids_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_tax_ids_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_tax_ids_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_tax_ids_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_tax_ids_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_tax_ids_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_tax_ids_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_tax_ids_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details/tax-ids', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_tax_ids_post(self, organization_id : StrictStr, api_v1_organizations_organization_id_billing_details_tax_ids_post_request : ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_tax_ids_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_tax_ids_post(organization_id, api_v1_organizations_organization_id_billing_details_tax_ids_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_billing_details_tax_ids_post_request: (required)
        :type api_v1_organizations_organization_id_billing_details_tax_ids_post_request: ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_tax_ids_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_tax_ids_post_with_http_info(organization_id, api_v1_organizations_organization_id_billing_details_tax_ids_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_tax_ids_post_with_http_info(self, organization_id : StrictStr, api_v1_organizations_organization_id_billing_details_tax_ids_post_request : ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_tax_ids_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_tax_ids_post_with_http_info(organization_id, api_v1_organizations_organization_id_billing_details_tax_ids_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_billing_details_tax_ids_post_request: (required)
        :type api_v1_organizations_organization_id_billing_details_tax_ids_post_request: ApiV1OrganizationsOrganizationIdBillingDetailsTaxIdsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_organizations_organization_id_billing_details_tax_ids_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_tax_ids_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organizations_organization_id_billing_details_tax_ids_post_request'] is not None:
            _body_params = _params['api_v1_organizations_organization_id_billing_details_tax_ids_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details/tax-ids', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete(self, organization_id : StrictStr, tax_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete(organization_id, tax_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param tax_id: (required)
        :type tax_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete_with_http_info(organization_id, tax_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete_with_http_info(self, organization_id : StrictStr, tax_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete_with_http_info(organization_id, tax_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param tax_id: (required)
        :type tax_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'tax_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_billing_details_tax_ids_tax_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['tax_id'] is not None:
            _path_params['taxId'] = _params['tax_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/billing-details/tax-ids/{taxId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_customer_portal_session_post(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_customer_portal_session_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_customer_portal_session_post(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_customer_portal_session_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_customer_portal_session_post_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_customer_portal_session_post_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_customer_portal_session_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_customer_portal_session_post_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_customer_portal_session_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/customer-portal-session', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_invoices_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_invoices_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_invoices_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_invoices_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_invoices_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_invoices_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_invoices_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_invoices_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_invoices_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/invoices', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_licenses_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_licenses_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_licenses_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_licenses_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_licenses_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_licenses_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_licenses_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_licenses_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_licenses_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/licenses', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_plan_billing_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_plan_billing_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plan_billing_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_plan_billing_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_plan_billing_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_plan_billing_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_plan_billing_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plan_billing_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_plan_billing_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/plan/billing', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_plan_get(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationsOrganizationIdPlanGet200Response:  # noqa: E501
        """api_v1_organizations_organization_id_plan_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plan_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationsOrganizationIdPlanGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_plan_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_plan_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_plan_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_plan_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plan_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationsOrganizationIdPlanGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_plan_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationsOrganizationIdPlanGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/plan', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_plan_table_get(self, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_plan_table_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plan_table_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_plan_table_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_plan_table_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_plan_table_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_plan_table_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plan_table_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_plan_table_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/plan/table', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_plans_get(self, organization_id : StrictStr, workspace_id : Optional[StrictStr] = None, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_plans_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plans_get(organization_id, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param workspace_id:
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_plans_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_plans_get_with_http_info(organization_id, workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_plans_get_with_http_info(self, organization_id : StrictStr, workspace_id : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_plans_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plans_get_with_http_info(organization_id, workspace_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param workspace_id:
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_plans_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/plans', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_plans_table_get(self, billing_cycle : StrictStr, organization_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_plans_table_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plans_table_get(billing_cycle, organization_id, async_req=True)
        >>> result = thread.get()

        :param billing_cycle: (required)
        :type billing_cycle: str
        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_plans_table_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_plans_table_get_with_http_info(billing_cycle, organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_plans_table_get_with_http_info(self, billing_cycle : StrictStr, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_plans_table_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_plans_table_get_with_http_info(billing_cycle, organization_id, async_req=True)
        >>> result = thread.get()

        :param billing_cycle: (required)
        :type billing_cycle: str
        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'billing_cycle',
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_plans_table_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        if _params.get('billing_cycle') is not None:  # noqa: E501
            _query_params.append(('billingCycle', _params['billing_cycle']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/plans/table', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_organizations_organization_id_session_trial_post(self, organization_id : StrictStr, api_v1_organizations_organization_id_session_trial_post_request : ApiV1OrganizationsOrganizationIdSessionTrialPostRequest, **kwargs) -> object:  # noqa: E501
        """api_v1_organizations_organization_id_session_trial_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_session_trial_post(organization_id, api_v1_organizations_organization_id_session_trial_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_session_trial_post_request: (required)
        :type api_v1_organizations_organization_id_session_trial_post_request: ApiV1OrganizationsOrganizationIdSessionTrialPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_organizations_organization_id_session_trial_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_organizations_organization_id_session_trial_post_with_http_info(organization_id, api_v1_organizations_organization_id_session_trial_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_organizations_organization_id_session_trial_post_with_http_info(self, organization_id : StrictStr, api_v1_organizations_organization_id_session_trial_post_request : ApiV1OrganizationsOrganizationIdSessionTrialPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_organizations_organization_id_session_trial_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_organizations_organization_id_session_trial_post_with_http_info(organization_id, api_v1_organizations_organization_id_session_trial_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param api_v1_organizations_organization_id_session_trial_post_request: (required)
        :type api_v1_organizations_organization_id_session_trial_post_request: ApiV1OrganizationsOrganizationIdSessionTrialPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'api_v1_organizations_organization_id_session_trial_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_organizations_organization_id_session_trial_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_organizations_organization_id_session_trial_post_request'] is not None:
            _body_params = _params['api_v1_organizations_organization_id_session_trial_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/organizations/{organizationId}/session/trial', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_backup_private_key_get(self, **kwargs) -> ApiV1PasswordBackupPrivateKeyGet200Response:  # noqa: E501
        """api_v1_password_backup_private_key_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_backup_private_key_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PasswordBackupPrivateKeyGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_backup_private_key_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_backup_private_key_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_backup_private_key_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_backup_private_key_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_backup_private_key_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PasswordBackupPrivateKeyGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_backup_private_key_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PasswordBackupPrivateKeyGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/backup-private-key', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_backup_private_key_post(self, api_v1_password_backup_private_key_post_request : ApiV1PasswordBackupPrivateKeyPostRequest, **kwargs) -> ApiV1PasswordBackupPrivateKeyGet200Response:  # noqa: E501
        """api_v1_password_backup_private_key_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_backup_private_key_post(api_v1_password_backup_private_key_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_backup_private_key_post_request: (required)
        :type api_v1_password_backup_private_key_post_request: ApiV1PasswordBackupPrivateKeyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PasswordBackupPrivateKeyGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_backup_private_key_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_backup_private_key_post_with_http_info(api_v1_password_backup_private_key_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_backup_private_key_post_with_http_info(self, api_v1_password_backup_private_key_post_request : ApiV1PasswordBackupPrivateKeyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_backup_private_key_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_backup_private_key_post_with_http_info(api_v1_password_backup_private_key_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_backup_private_key_post_request: (required)
        :type api_v1_password_backup_private_key_post_request: ApiV1PasswordBackupPrivateKeyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PasswordBackupPrivateKeyGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_backup_private_key_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_backup_private_key_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_backup_private_key_post_request'] is not None:
            _body_params = _params['api_v1_password_backup_private_key_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PasswordBackupPrivateKeyGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/backup-private-key', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_change_password_post(self, api_v1_password_change_password_post_request : ApiV1PasswordChangePasswordPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_password_change_password_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_change_password_post(api_v1_password_change_password_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_change_password_post_request: (required)
        :type api_v1_password_change_password_post_request: ApiV1PasswordChangePasswordPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_change_password_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_change_password_post_with_http_info(api_v1_password_change_password_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_change_password_post_with_http_info(self, api_v1_password_change_password_post_request : ApiV1PasswordChangePasswordPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_change_password_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_change_password_post_with_http_info(api_v1_password_change_password_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_change_password_post_request: (required)
        :type api_v1_password_change_password_post_request: ApiV1PasswordChangePasswordPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_change_password_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_change_password_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_change_password_post_request'] is not None:
            _body_params = _params['api_v1_password_change_password_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/change-password', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_email_password_reset_post(self, api_v1_password_email_password_reset_post_request : ApiV1PasswordEmailPasswordResetPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_password_email_password_reset_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_email_password_reset_post(api_v1_password_email_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_post_request: (required)
        :type api_v1_password_email_password_reset_post_request: ApiV1PasswordEmailPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_email_password_reset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_email_password_reset_post_with_http_info(api_v1_password_email_password_reset_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_email_password_reset_post_with_http_info(self, api_v1_password_email_password_reset_post_request : ApiV1PasswordEmailPasswordResetPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_email_password_reset_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_email_password_reset_post_with_http_info(api_v1_password_email_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_post_request: (required)
        :type api_v1_password_email_password_reset_post_request: ApiV1PasswordEmailPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_email_password_reset_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_email_password_reset_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_email_password_reset_post_request'] is not None:
            _body_params = _params['api_v1_password_email_password_reset_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/email/password-reset', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_email_password_reset_verify_post(self, api_v1_password_email_password_reset_verify_post_request : ApiV1PasswordEmailPasswordResetVerifyPostRequest, **kwargs) -> ApiV1PasswordEmailPasswordResetVerifyPost200Response:  # noqa: E501
        """api_v1_password_email_password_reset_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_email_password_reset_verify_post(api_v1_password_email_password_reset_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_verify_post_request: (required)
        :type api_v1_password_email_password_reset_verify_post_request: ApiV1PasswordEmailPasswordResetVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PasswordEmailPasswordResetVerifyPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_email_password_reset_verify_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_email_password_reset_verify_post_with_http_info(api_v1_password_email_password_reset_verify_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_email_password_reset_verify_post_with_http_info(self, api_v1_password_email_password_reset_verify_post_request : ApiV1PasswordEmailPasswordResetVerifyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_email_password_reset_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_email_password_reset_verify_post_with_http_info(api_v1_password_email_password_reset_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_verify_post_request: (required)
        :type api_v1_password_email_password_reset_verify_post_request: ApiV1PasswordEmailPasswordResetVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PasswordEmailPasswordResetVerifyPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_email_password_reset_verify_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_email_password_reset_verify_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_email_password_reset_verify_post_request'] is not None:
            _body_params = _params['api_v1_password_email_password_reset_verify_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PasswordEmailPasswordResetVerifyPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/email/password-reset-verify', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_password_reset_post(self, api_v1_password_password_reset_post_request : ApiV1PasswordPasswordResetPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_password_password_reset_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_password_reset_post(api_v1_password_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_password_reset_post_request: (required)
        :type api_v1_password_password_reset_post_request: ApiV1PasswordPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_password_reset_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_password_reset_post_with_http_info(api_v1_password_password_reset_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_password_reset_post_with_http_info(self, api_v1_password_password_reset_post_request : ApiV1PasswordPasswordResetPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_password_reset_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_password_reset_post_with_http_info(api_v1_password_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_password_reset_post_request: (required)
        :type api_v1_password_password_reset_post_request: ApiV1PasswordPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_password_reset_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_password_reset_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_password_reset_post_request'] is not None:
            _body_params = _params['api_v1_password_password_reset_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/password-reset', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_password_srp1_post(self, api_v1_password_srp1_post_request : ApiV1PasswordSrp1PostRequest, **kwargs) -> ApiV1PasswordSrp1Post200Response:  # noqa: E501
        """api_v1_password_srp1_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_srp1_post(api_v1_password_srp1_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_srp1_post_request: (required)
        :type api_v1_password_srp1_post_request: ApiV1PasswordSrp1PostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PasswordSrp1Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_password_srp1_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_password_srp1_post_with_http_info(api_v1_password_srp1_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_password_srp1_post_with_http_info(self, api_v1_password_srp1_post_request : ApiV1PasswordSrp1PostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_password_srp1_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_password_srp1_post_with_http_info(api_v1_password_srp1_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_srp1_post_request: (required)
        :type api_v1_password_srp1_post_request: ApiV1PasswordSrp1PostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PasswordSrp1Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_srp1_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_password_srp1_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_srp1_post_request'] is not None:
            _body_params = _params['api_v1_password_srp1_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PasswordSrp1Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/password/srp1', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_certificate_get(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to get the certificate body and certificate chain from")], **kwargs) -> ApiV1PkiCaCaIdCertificateGet200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_certificate_get  # noqa: E501

        Get cert and cert chain of a CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_certificate_get(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to get the certificate body and certificate chain from (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdCertificateGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_certificate_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_certificate_get_with_http_info(ca_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_certificate_get_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to get the certificate body and certificate chain from")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_certificate_get  # noqa: E501

        Get cert and cert chain of a CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_certificate_get_with_http_info(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to get the certificate body and certificate chain from (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdCertificateGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_certificate_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdCertificateGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/certificate', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_crl_get(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to get the certificate revocation list (CRL) for")], **kwargs) -> ApiV1PkiCaCaIdCrlGet200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_crl_get  # noqa: E501

        Get CRL of the CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_crl_get(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to get the certificate revocation list (CRL) for (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdCrlGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_crl_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_crl_get_with_http_info(ca_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_crl_get_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to get the certificate revocation list (CRL) for")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_crl_get  # noqa: E501

        Get CRL of the CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_crl_get_with_http_info(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to get the certificate revocation list (CRL) for (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdCrlGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_crl_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdCrlGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/crl', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_csr_get(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to generate CSR from")], **kwargs) -> ApiV1PkiCaCaIdCsrGet200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_csr_get  # noqa: E501

        Get CA CSR  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_csr_get(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to generate CSR from (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdCsrGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_csr_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_csr_get_with_http_info(ca_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_csr_get_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to generate CSR from")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_csr_get  # noqa: E501

        Get CA CSR  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_csr_get_with_http_info(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to generate CSR from (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdCsrGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_csr_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdCsrGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/csr', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_delete(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to delete")], **kwargs) -> ApiV1PkiCaPost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_delete  # noqa: E501

        Delete CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_delete(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to delete (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_delete_with_http_info(ca_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_delete_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_delete  # noqa: E501

        Delete CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_delete_with_http_info(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to delete (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_get(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to get")], **kwargs) -> ApiV1PkiCaPost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_get  # noqa: E501

        Get CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_get(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to get (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_get_with_http_info(ca_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_get_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_get  # noqa: E501

        Get CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_get_with_http_info(ca_id, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to get (required)
        :type ca_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_import_certificate_post(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to import the certificate for")], api_v1_pki_ca_ca_id_import_certificate_post_request : ApiV1PkiCaCaIdImportCertificatePostRequest, **kwargs) -> ApiV1PkiCaCaIdImportCertificatePost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_import_certificate_post  # noqa: E501

        Import certificate and chain to CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_import_certificate_post(ca_id, api_v1_pki_ca_ca_id_import_certificate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to import the certificate for (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_import_certificate_post_request: (required)
        :type api_v1_pki_ca_ca_id_import_certificate_post_request: ApiV1PkiCaCaIdImportCertificatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdImportCertificatePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_import_certificate_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_import_certificate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_import_certificate_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_import_certificate_post_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to import the certificate for")], api_v1_pki_ca_ca_id_import_certificate_post_request : ApiV1PkiCaCaIdImportCertificatePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_import_certificate_post  # noqa: E501

        Import certificate and chain to CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_import_certificate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_import_certificate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to import the certificate for (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_import_certificate_post_request: (required)
        :type api_v1_pki_ca_ca_id_import_certificate_post_request: ApiV1PkiCaCaIdImportCertificatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdImportCertificatePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id',
            'api_v1_pki_ca_ca_id_import_certificate_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_import_certificate_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_ca_ca_id_import_certificate_post_request'] is not None:
            _body_params = _params['api_v1_pki_ca_ca_id_import_certificate_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdImportCertificatePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/import-certificate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_issue_certificate_post(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to issue the certificate from")], api_v1_pki_ca_ca_id_issue_certificate_post_request : ApiV1PkiCaCaIdIssueCertificatePostRequest, **kwargs) -> ApiV1PkiCaCaIdIssueCertificatePost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_issue_certificate_post  # noqa: E501

        Issue certificate from CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_issue_certificate_post(ca_id, api_v1_pki_ca_ca_id_issue_certificate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to issue the certificate from (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_issue_certificate_post_request: (required)
        :type api_v1_pki_ca_ca_id_issue_certificate_post_request: ApiV1PkiCaCaIdIssueCertificatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdIssueCertificatePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_issue_certificate_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_issue_certificate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_issue_certificate_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_issue_certificate_post_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to issue the certificate from")], api_v1_pki_ca_ca_id_issue_certificate_post_request : ApiV1PkiCaCaIdIssueCertificatePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_issue_certificate_post  # noqa: E501

        Issue certificate from CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_issue_certificate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_issue_certificate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to issue the certificate from (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_issue_certificate_post_request: (required)
        :type api_v1_pki_ca_ca_id_issue_certificate_post_request: ApiV1PkiCaCaIdIssueCertificatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdIssueCertificatePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id',
            'api_v1_pki_ca_ca_id_issue_certificate_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_issue_certificate_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_ca_ca_id_issue_certificate_post_request'] is not None:
            _body_params = _params['api_v1_pki_ca_ca_id_issue_certificate_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdIssueCertificatePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/issue-certificate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_patch(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to update")], api_v1_pki_ca_ca_id_patch_request : Optional[ApiV1PkiCaCaIdPatchRequest] = None, **kwargs) -> ApiV1PkiCaPost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_patch  # noqa: E501

        Update CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_patch(ca_id, api_v1_pki_ca_ca_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to update (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_patch_request:
        :type api_v1_pki_ca_ca_id_patch_request: ApiV1PkiCaCaIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_patch_with_http_info(ca_id, api_v1_pki_ca_ca_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_patch_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to update")], api_v1_pki_ca_ca_id_patch_request : Optional[ApiV1PkiCaCaIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_patch  # noqa: E501

        Update CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_patch_with_http_info(ca_id, api_v1_pki_ca_ca_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to update (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_patch_request:
        :type api_v1_pki_ca_ca_id_patch_request: ApiV1PkiCaCaIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id',
            'api_v1_pki_ca_ca_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_ca_ca_id_patch_request'] is not None:
            _body_params = _params['api_v1_pki_ca_ca_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_sign_certificate_post(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to issue the certificate from")], api_v1_pki_ca_ca_id_sign_certificate_post_request : ApiV1PkiCaCaIdSignCertificatePostRequest, **kwargs) -> ApiV1PkiCaCaIdSignCertificatePost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_sign_certificate_post  # noqa: E501

        Sign certificate from CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_sign_certificate_post(ca_id, api_v1_pki_ca_ca_id_sign_certificate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to issue the certificate from (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_sign_certificate_post_request: (required)
        :type api_v1_pki_ca_ca_id_sign_certificate_post_request: ApiV1PkiCaCaIdSignCertificatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdSignCertificatePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_sign_certificate_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_sign_certificate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_sign_certificate_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_sign_certificate_post_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to issue the certificate from")], api_v1_pki_ca_ca_id_sign_certificate_post_request : ApiV1PkiCaCaIdSignCertificatePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_sign_certificate_post  # noqa: E501

        Sign certificate from CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_sign_certificate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_sign_certificate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to issue the certificate from (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_sign_certificate_post_request: (required)
        :type api_v1_pki_ca_ca_id_sign_certificate_post_request: ApiV1PkiCaCaIdSignCertificatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdSignCertificatePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id',
            'api_v1_pki_ca_ca_id_sign_certificate_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_sign_certificate_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_ca_ca_id_sign_certificate_post_request'] is not None:
            _body_params = _params['api_v1_pki_ca_ca_id_sign_certificate_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdSignCertificatePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/sign-certificate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_ca_id_sign_intermediate_post(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to sign the intermediate certificate with")], api_v1_pki_ca_ca_id_sign_intermediate_post_request : ApiV1PkiCaCaIdSignIntermediatePostRequest, **kwargs) -> ApiV1PkiCaCaIdSignIntermediatePost200Response:  # noqa: E501
        """api_v1_pki_ca_ca_id_sign_intermediate_post  # noqa: E501

        Create intermediate CA certificate from parent CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_sign_intermediate_post(ca_id, api_v1_pki_ca_ca_id_sign_intermediate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to sign the intermediate certificate with (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_sign_intermediate_post_request: (required)
        :type api_v1_pki_ca_ca_id_sign_intermediate_post_request: ApiV1PkiCaCaIdSignIntermediatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaCaIdSignIntermediatePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_ca_id_sign_intermediate_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_ca_id_sign_intermediate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_sign_intermediate_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_ca_id_sign_intermediate_post_with_http_info(self, ca_id : Annotated[StrictStr, Field(..., description="The ID of the CA to sign the intermediate certificate with")], api_v1_pki_ca_ca_id_sign_intermediate_post_request : ApiV1PkiCaCaIdSignIntermediatePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_ca_id_sign_intermediate_post  # noqa: E501

        Create intermediate CA certificate from parent CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_ca_id_sign_intermediate_post_with_http_info(ca_id, api_v1_pki_ca_ca_id_sign_intermediate_post_request, async_req=True)
        >>> result = thread.get()

        :param ca_id: The ID of the CA to sign the intermediate certificate with (required)
        :type ca_id: str
        :param api_v1_pki_ca_ca_id_sign_intermediate_post_request: (required)
        :type api_v1_pki_ca_ca_id_sign_intermediate_post_request: ApiV1PkiCaCaIdSignIntermediatePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaCaIdSignIntermediatePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ca_id',
            'api_v1_pki_ca_ca_id_sign_intermediate_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_ca_id_sign_intermediate_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['ca_id'] is not None:
            _path_params['caId'] = _params['ca_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_ca_ca_id_sign_intermediate_post_request'] is not None:
            _body_params = _params['api_v1_pki_ca_ca_id_sign_intermediate_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaCaIdSignIntermediatePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca/{caId}/sign-intermediate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_ca_post(self, api_v1_pki_ca_post_request : ApiV1PkiCaPostRequest, **kwargs) -> ApiV1PkiCaPost200Response:  # noqa: E501
        """api_v1_pki_ca_post  # noqa: E501

        Create CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_post(api_v1_pki_ca_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_pki_ca_post_request: (required)
        :type api_v1_pki_ca_post_request: ApiV1PkiCaPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCaPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_ca_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_ca_post_with_http_info(api_v1_pki_ca_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_ca_post_with_http_info(self, api_v1_pki_ca_post_request : ApiV1PkiCaPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_ca_post  # noqa: E501

        Create CA  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_ca_post_with_http_info(api_v1_pki_ca_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_pki_ca_post_request: (required)
        :type api_v1_pki_ca_post_request: ApiV1PkiCaPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCaPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_pki_ca_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_ca_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_ca_post_request'] is not None:
            _body_params = _params['api_v1_pki_ca_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCaPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/ca', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_certificates_serial_number_certificate_get(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to get the certificate body and certificate chain for")], **kwargs) -> ApiV1PkiCertificatesSerialNumberCertificateGet200Response:  # noqa: E501
        """api_v1_pki_certificates_serial_number_certificate_get  # noqa: E501

        Get certificate body of certificate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_certificate_get(serial_number, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to get the certificate body and certificate chain for (required)
        :type serial_number: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCertificatesSerialNumberCertificateGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_certificates_serial_number_certificate_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_certificates_serial_number_certificate_get_with_http_info(serial_number, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_certificates_serial_number_certificate_get_with_http_info(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to get the certificate body and certificate chain for")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_certificates_serial_number_certificate_get  # noqa: E501

        Get certificate body of certificate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_certificate_get_with_http_info(serial_number, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to get the certificate body and certificate chain for (required)
        :type serial_number: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCertificatesSerialNumberCertificateGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'serial_number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_certificates_serial_number_certificate_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['serial_number'] is not None:
            _path_params['serialNumber'] = _params['serial_number']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCertificatesSerialNumberCertificateGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/certificates/{serialNumber}/certificate', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_certificates_serial_number_delete(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to delete")], **kwargs) -> ApiV1PkiCertificatesSerialNumberGet200Response:  # noqa: E501
        """api_v1_pki_certificates_serial_number_delete  # noqa: E501

        Delete certificate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_delete(serial_number, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to delete (required)
        :type serial_number: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCertificatesSerialNumberGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_certificates_serial_number_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_certificates_serial_number_delete_with_http_info(serial_number, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_certificates_serial_number_delete_with_http_info(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to delete")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_certificates_serial_number_delete  # noqa: E501

        Delete certificate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_delete_with_http_info(serial_number, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to delete (required)
        :type serial_number: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCertificatesSerialNumberGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'serial_number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_certificates_serial_number_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['serial_number'] is not None:
            _path_params['serialNumber'] = _params['serial_number']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCertificatesSerialNumberGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/certificates/{serialNumber}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_certificates_serial_number_get(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to get")], **kwargs) -> ApiV1PkiCertificatesSerialNumberGet200Response:  # noqa: E501
        """api_v1_pki_certificates_serial_number_get  # noqa: E501

        Get certificate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_get(serial_number, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to get (required)
        :type serial_number: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCertificatesSerialNumberGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_certificates_serial_number_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_certificates_serial_number_get_with_http_info(serial_number, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_certificates_serial_number_get_with_http_info(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to get")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_certificates_serial_number_get  # noqa: E501

        Get certificate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_get_with_http_info(serial_number, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to get (required)
        :type serial_number: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCertificatesSerialNumberGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'serial_number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_certificates_serial_number_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['serial_number'] is not None:
            _path_params['serialNumber'] = _params['serial_number']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCertificatesSerialNumberGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/certificates/{serialNumber}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_pki_certificates_serial_number_revoke_post(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA.")], api_v1_pki_certificates_serial_number_revoke_post_request : ApiV1PkiCertificatesSerialNumberRevokePostRequest, **kwargs) -> ApiV1PkiCertificatesSerialNumberRevokePost200Response:  # noqa: E501
        """api_v1_pki_certificates_serial_number_revoke_post  # noqa: E501

        Revoke  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_revoke_post(serial_number, api_v1_pki_certificates_serial_number_revoke_post_request, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA. (required)
        :type serial_number: str
        :param api_v1_pki_certificates_serial_number_revoke_post_request: (required)
        :type api_v1_pki_certificates_serial_number_revoke_post_request: ApiV1PkiCertificatesSerialNumberRevokePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PkiCertificatesSerialNumberRevokePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_pki_certificates_serial_number_revoke_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_pki_certificates_serial_number_revoke_post_with_http_info(serial_number, api_v1_pki_certificates_serial_number_revoke_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_pki_certificates_serial_number_revoke_post_with_http_info(self, serial_number : Annotated[StrictStr, Field(..., description="The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA.")], api_v1_pki_certificates_serial_number_revoke_post_request : ApiV1PkiCertificatesSerialNumberRevokePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_pki_certificates_serial_number_revoke_post  # noqa: E501

        Revoke  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_pki_certificates_serial_number_revoke_post_with_http_info(serial_number, api_v1_pki_certificates_serial_number_revoke_post_request, async_req=True)
        >>> result = thread.get()

        :param serial_number: The serial number of the certificate to revoke. The revoked certificate will be added to the certificate revocation list (CRL) of the CA. (required)
        :type serial_number: str
        :param api_v1_pki_certificates_serial_number_revoke_post_request: (required)
        :type api_v1_pki_certificates_serial_number_revoke_post_request: ApiV1PkiCertificatesSerialNumberRevokePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PkiCertificatesSerialNumberRevokePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'serial_number',
            'api_v1_pki_certificates_serial_number_revoke_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_pki_certificates_serial_number_revoke_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['serial_number'] is not None:
            _path_params['serialNumber'] = _params['serial_number']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_pki_certificates_serial_number_revoke_post_request'] is not None:
            _body_params = _params['api_v1_pki_certificates_serial_number_revoke_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PkiCertificatesSerialNumberRevokePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/pki/certificates/{serialNumber}/revoke', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_rate_limit_get(self, **kwargs) -> ApiV1RateLimitGet200Response:  # noqa: E501
        """api_v1_rate_limit_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_rate_limit_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1RateLimitGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_rate_limit_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_rate_limit_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_rate_limit_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_rate_limit_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_rate_limit_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1RateLimitGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_rate_limit_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1RateLimitGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/rate-limit', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_rate_limit_put(self, api_v1_rate_limit_put_request : ApiV1RateLimitPutRequest, **kwargs) -> ApiV1RateLimitGet200Response:  # noqa: E501
        """api_v1_rate_limit_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_rate_limit_put(api_v1_rate_limit_put_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_rate_limit_put_request: (required)
        :type api_v1_rate_limit_put_request: ApiV1RateLimitPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1RateLimitGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_rate_limit_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_rate_limit_put_with_http_info(api_v1_rate_limit_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_rate_limit_put_with_http_info(self, api_v1_rate_limit_put_request : ApiV1RateLimitPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_rate_limit_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_rate_limit_put_with_http_info(api_v1_rate_limit_put_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_rate_limit_put_request: (required)
        :type api_v1_rate_limit_put_request: ApiV1RateLimitPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1RateLimitGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_rate_limit_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_rate_limit_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_rate_limit_put_request'] is not None:
            _body_params = _params['api_v1_rate_limit_put_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1RateLimitGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/rate-limit', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_groups_get(self, start_index : Optional[Union[StrictFloat, StrictInt]] = None, count : Optional[Union[StrictFloat, StrictInt]] = None, filter : Optional[StrictStr] = None, **kwargs) -> ApiV1ScimGroupsGet200Response:  # noqa: E501
        """api_v1_scim_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_get(start_index, count, filter, async_req=True)
        >>> result = thread.get()

        :param start_index:
        :type start_index: float
        :param count:
        :type count: float
        :param filter:
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimGroupsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_groups_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_groups_get_with_http_info(start_index, count, filter, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_groups_get_with_http_info(self, start_index : Optional[Union[StrictFloat, StrictInt]] = None, count : Optional[Union[StrictFloat, StrictInt]] = None, filter : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_groups_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_get_with_http_info(start_index, count, filter, async_req=True)
        >>> result = thread.get()

        :param start_index:
        :type start_index: float
        :param count:
        :type count: float
        :param filter:
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimGroupsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'start_index',
            'count',
            'filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_groups_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('start_index') is not None:  # noqa: E501
            _query_params.append(('startIndex', _params['start_index']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimGroupsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Groups', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_groups_group_id_delete(self, group_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_scim_groups_group_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_delete(group_id, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_groups_group_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_groups_group_id_delete_with_http_info(group_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_groups_group_id_delete_with_http_info(self, group_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_groups_group_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_delete_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'group_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_groups_group_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['group_id'] is not None:
            _path_params['groupId'] = _params['group_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Groups/{groupId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_groups_group_id_get(self, group_id : StrictStr, **kwargs) -> ApiV1ScimGroupsGet200ResponseResourcesInner:  # noqa: E501
        """api_v1_scim_groups_group_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_get(group_id, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimGroupsGet200ResponseResourcesInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_groups_group_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_groups_group_id_get_with_http_info(group_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_groups_group_id_get_with_http_info(self, group_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_groups_group_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_get_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimGroupsGet200ResponseResourcesInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'group_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_groups_group_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['group_id'] is not None:
            _path_params['groupId'] = _params['group_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimGroupsGet200ResponseResourcesInner",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Groups/{groupId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_groups_group_id_patch(self, group_id : StrictStr, api_v1_scim_groups_group_id_patch_request : ApiV1ScimGroupsGroupIdPatchRequest, **kwargs) -> ApiV1ScimGroupsGet200ResponseResourcesInner:  # noqa: E501
        """api_v1_scim_groups_group_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_patch(group_id, api_v1_scim_groups_group_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param api_v1_scim_groups_group_id_patch_request: (required)
        :type api_v1_scim_groups_group_id_patch_request: ApiV1ScimGroupsGroupIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimGroupsGet200ResponseResourcesInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_groups_group_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_groups_group_id_patch_with_http_info(group_id, api_v1_scim_groups_group_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_groups_group_id_patch_with_http_info(self, group_id : StrictStr, api_v1_scim_groups_group_id_patch_request : ApiV1ScimGroupsGroupIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_groups_group_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_patch_with_http_info(group_id, api_v1_scim_groups_group_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param api_v1_scim_groups_group_id_patch_request: (required)
        :type api_v1_scim_groups_group_id_patch_request: ApiV1ScimGroupsGroupIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimGroupsGet200ResponseResourcesInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'group_id',
            'api_v1_scim_groups_group_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_groups_group_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['group_id'] is not None:
            _path_params['groupId'] = _params['group_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_scim_groups_group_id_patch_request'] is not None:
            _body_params = _params['api_v1_scim_groups_group_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimGroupsGet200ResponseResourcesInner",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Groups/{groupId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_groups_group_id_put(self, group_id : StrictStr, api_v1_scim_groups_group_id_put_request : ApiV1ScimGroupsGroupIdPutRequest, **kwargs) -> ApiV1ScimGroupsGet200ResponseResourcesInner:  # noqa: E501
        """api_v1_scim_groups_group_id_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_put(group_id, api_v1_scim_groups_group_id_put_request, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param api_v1_scim_groups_group_id_put_request: (required)
        :type api_v1_scim_groups_group_id_put_request: ApiV1ScimGroupsGroupIdPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimGroupsGet200ResponseResourcesInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_groups_group_id_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_groups_group_id_put_with_http_info(group_id, api_v1_scim_groups_group_id_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_groups_group_id_put_with_http_info(self, group_id : StrictStr, api_v1_scim_groups_group_id_put_request : ApiV1ScimGroupsGroupIdPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_groups_group_id_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_group_id_put_with_http_info(group_id, api_v1_scim_groups_group_id_put_request, async_req=True)
        >>> result = thread.get()

        :param group_id: (required)
        :type group_id: str
        :param api_v1_scim_groups_group_id_put_request: (required)
        :type api_v1_scim_groups_group_id_put_request: ApiV1ScimGroupsGroupIdPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimGroupsGet200ResponseResourcesInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'group_id',
            'api_v1_scim_groups_group_id_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_groups_group_id_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['group_id'] is not None:
            _path_params['groupId'] = _params['group_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_scim_groups_group_id_put_request'] is not None:
            _body_params = _params['api_v1_scim_groups_group_id_put_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimGroupsGet200ResponseResourcesInner",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Groups/{groupId}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_groups_post(self, api_v1_scim_groups_post_request : ApiV1ScimGroupsPostRequest, **kwargs) -> ApiV1ScimGroupsPost200Response:  # noqa: E501
        """api_v1_scim_groups_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_post(api_v1_scim_groups_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_scim_groups_post_request: (required)
        :type api_v1_scim_groups_post_request: ApiV1ScimGroupsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimGroupsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_groups_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_groups_post_with_http_info(api_v1_scim_groups_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_groups_post_with_http_info(self, api_v1_scim_groups_post_request : ApiV1ScimGroupsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_groups_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_groups_post_with_http_info(api_v1_scim_groups_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_scim_groups_post_request: (required)
        :type api_v1_scim_groups_post_request: ApiV1ScimGroupsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimGroupsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_scim_groups_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_groups_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_scim_groups_post_request'] is not None:
            _body_params = _params['api_v1_scim_groups_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimGroupsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Groups', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_scim_tokens_get(self, organization_id : StrictStr, **kwargs) -> ApiV1ScimScimTokensGet200Response:  # noqa: E501
        """api_v1_scim_scim_tokens_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_scim_tokens_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimScimTokensGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_scim_tokens_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_scim_tokens_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_scim_tokens_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_scim_tokens_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_scim_tokens_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimScimTokensGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_scim_tokens_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('organization_id') is not None:  # noqa: E501
            _query_params.append(('organizationId', _params['organization_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimScimTokensGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/scim-tokens', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_scim_tokens_post(self, api_v1_scim_scim_tokens_post_request : ApiV1ScimScimTokensPostRequest, **kwargs) -> ApiV1ScimScimTokensPost200Response:  # noqa: E501
        """api_v1_scim_scim_tokens_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_scim_tokens_post(api_v1_scim_scim_tokens_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_scim_scim_tokens_post_request: (required)
        :type api_v1_scim_scim_tokens_post_request: ApiV1ScimScimTokensPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimScimTokensPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_scim_tokens_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_scim_tokens_post_with_http_info(api_v1_scim_scim_tokens_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_scim_tokens_post_with_http_info(self, api_v1_scim_scim_tokens_post_request : ApiV1ScimScimTokensPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_scim_tokens_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_scim_tokens_post_with_http_info(api_v1_scim_scim_tokens_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_scim_scim_tokens_post_request: (required)
        :type api_v1_scim_scim_tokens_post_request: ApiV1ScimScimTokensPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimScimTokensPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_scim_scim_tokens_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_scim_tokens_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_scim_scim_tokens_post_request'] is not None:
            _body_params = _params['api_v1_scim_scim_tokens_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimScimTokensPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/scim-tokens', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_scim_tokens_scim_token_id_delete(self, scim_token_id : StrictStr, **kwargs) -> ApiV1ScimScimTokensScimTokenIdDelete200Response:  # noqa: E501
        """api_v1_scim_scim_tokens_scim_token_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_scim_tokens_scim_token_id_delete(scim_token_id, async_req=True)
        >>> result = thread.get()

        :param scim_token_id: (required)
        :type scim_token_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimScimTokensScimTokenIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_scim_tokens_scim_token_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_scim_tokens_scim_token_id_delete_with_http_info(scim_token_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_scim_tokens_scim_token_id_delete_with_http_info(self, scim_token_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_scim_tokens_scim_token_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_scim_tokens_scim_token_id_delete_with_http_info(scim_token_id, async_req=True)
        >>> result = thread.get()

        :param scim_token_id: (required)
        :type scim_token_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimScimTokensScimTokenIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'scim_token_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_scim_tokens_scim_token_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['scim_token_id'] is not None:
            _path_params['scimTokenId'] = _params['scim_token_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimScimTokensScimTokenIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/scim-tokens/{scimTokenId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_users_get(self, start_index : Optional[Union[StrictFloat, StrictInt]] = None, count : Optional[Union[StrictFloat, StrictInt]] = None, filter : Optional[StrictStr] = None, **kwargs) -> ApiV1ScimUsersGet200Response:  # noqa: E501
        """api_v1_scim_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_get(start_index, count, filter, async_req=True)
        >>> result = thread.get()

        :param start_index:
        :type start_index: float
        :param count:
        :type count: float
        :param filter:
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimUsersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_users_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_users_get_with_http_info(start_index, count, filter, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_users_get_with_http_info(self, start_index : Optional[Union[StrictFloat, StrictInt]] = None, count : Optional[Union[StrictFloat, StrictInt]] = None, filter : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_get_with_http_info(start_index, count, filter, async_req=True)
        >>> result = thread.get()

        :param start_index:
        :type start_index: float
        :param count:
        :type count: float
        :param filter:
        :type filter: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimUsersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'start_index',
            'count',
            'filter'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('start_index') is not None:  # noqa: E501
            _query_params.append(('startIndex', _params['start_index']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('filter') is not None:  # noqa: E501
            _query_params.append(('filter', _params['filter']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimUsersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_users_org_membership_id_delete(self, org_membership_id : StrictStr, **kwargs) -> object:  # noqa: E501
        """api_v1_scim_users_org_membership_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_org_membership_id_delete(org_membership_id, async_req=True)
        >>> result = thread.get()

        :param org_membership_id: (required)
        :type org_membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_users_org_membership_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_users_org_membership_id_delete_with_http_info(org_membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_users_org_membership_id_delete_with_http_info(self, org_membership_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_users_org_membership_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_org_membership_id_delete_with_http_info(org_membership_id, async_req=True)
        >>> result = thread.get()

        :param org_membership_id: (required)
        :type org_membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_users_org_membership_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['org_membership_id'] is not None:
            _path_params['orgMembershipId'] = _params['org_membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Users/{orgMembershipId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_users_org_membership_id_get(self, org_membership_id : StrictStr, **kwargs) -> ApiV1ScimUsersOrgMembershipIdGet201Response:  # noqa: E501
        """api_v1_scim_users_org_membership_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_org_membership_id_get(org_membership_id, async_req=True)
        >>> result = thread.get()

        :param org_membership_id: (required)
        :type org_membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimUsersOrgMembershipIdGet201Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_users_org_membership_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_users_org_membership_id_get_with_http_info(org_membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_users_org_membership_id_get_with_http_info(self, org_membership_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_users_org_membership_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_org_membership_id_get_with_http_info(org_membership_id, async_req=True)
        >>> result = thread.get()

        :param org_membership_id: (required)
        :type org_membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimUsersOrgMembershipIdGet201Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_users_org_membership_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['org_membership_id'] is not None:
            _path_params['orgMembershipId'] = _params['org_membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "ApiV1ScimUsersOrgMembershipIdGet201Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Users/{orgMembershipId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_users_org_membership_id_put(self, org_membership_id : StrictStr, api_v1_scim_users_org_membership_id_put_request : ApiV1ScimUsersOrgMembershipIdPutRequest, **kwargs) -> ApiV1ScimUsersOrgMembershipIdPut200Response:  # noqa: E501
        """api_v1_scim_users_org_membership_id_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_org_membership_id_put(org_membership_id, api_v1_scim_users_org_membership_id_put_request, async_req=True)
        >>> result = thread.get()

        :param org_membership_id: (required)
        :type org_membership_id: str
        :param api_v1_scim_users_org_membership_id_put_request: (required)
        :type api_v1_scim_users_org_membership_id_put_request: ApiV1ScimUsersOrgMembershipIdPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimUsersOrgMembershipIdPut200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_users_org_membership_id_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_users_org_membership_id_put_with_http_info(org_membership_id, api_v1_scim_users_org_membership_id_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_users_org_membership_id_put_with_http_info(self, org_membership_id : StrictStr, api_v1_scim_users_org_membership_id_put_request : ApiV1ScimUsersOrgMembershipIdPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_users_org_membership_id_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_org_membership_id_put_with_http_info(org_membership_id, api_v1_scim_users_org_membership_id_put_request, async_req=True)
        >>> result = thread.get()

        :param org_membership_id: (required)
        :type org_membership_id: str
        :param api_v1_scim_users_org_membership_id_put_request: (required)
        :type api_v1_scim_users_org_membership_id_put_request: ApiV1ScimUsersOrgMembershipIdPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimUsersOrgMembershipIdPut200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_membership_id',
            'api_v1_scim_users_org_membership_id_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_users_org_membership_id_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['org_membership_id'] is not None:
            _path_params['orgMembershipId'] = _params['org_membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_scim_users_org_membership_id_put_request'] is not None:
            _body_params = _params['api_v1_scim_users_org_membership_id_put_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimUsersOrgMembershipIdPut200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Users/{orgMembershipId}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_scim_users_post(self, api_v1_scim_users_post_request : ApiV1ScimUsersPostRequest, **kwargs) -> ApiV1ScimUsersPost200Response:  # noqa: E501
        """api_v1_scim_users_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_post(api_v1_scim_users_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_scim_users_post_request: (required)
        :type api_v1_scim_users_post_request: ApiV1ScimUsersPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1ScimUsersPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_scim_users_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_scim_users_post_with_http_info(api_v1_scim_users_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_scim_users_post_with_http_info(self, api_v1_scim_users_post_request : ApiV1ScimUsersPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_scim_users_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_scim_users_post_with_http_info(api_v1_scim_users_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_scim_users_post_request: (required)
        :type api_v1_scim_users_post_request: ApiV1ScimUsersPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1ScimUsersPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_scim_users_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_scim_users_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_scim_users_post_request'] is not None:
            _body_params = _params['api_v1_scim_users_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1ScimUsersPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/scim/Users', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approval_requests_count_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1SecretApprovalRequestsCountGet200Response:  # noqa: E501
        """api_v1_secret_approval_requests_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_count_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalRequestsCountGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approval_requests_count_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approval_requests_count_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approval_requests_count_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approval_requests_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_count_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalRequestsCountGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approval_requests_count_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalRequestsCountGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approval-requests/count', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approval_requests_get(self, workspace_id : StrictStr, environment : Optional[StrictStr] = None, committer : Optional[StrictStr] = None, status : Optional[StrictStr] = None, limit : Optional[Union[StrictFloat, StrictInt]] = None, offset : Optional[Union[StrictFloat, StrictInt]] = None, **kwargs) -> ApiV1SecretApprovalRequestsGet200Response:  # noqa: E501
        """api_v1_secret_approval_requests_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_get(workspace_id, environment, committer, status, limit, offset, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment:
        :type environment: str
        :param committer:
        :type committer: str
        :param status:
        :type status: str
        :param limit:
        :type limit: float
        :param offset:
        :type offset: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalRequestsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approval_requests_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approval_requests_get_with_http_info(workspace_id, environment, committer, status, limit, offset, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approval_requests_get_with_http_info(self, workspace_id : StrictStr, environment : Optional[StrictStr] = None, committer : Optional[StrictStr] = None, status : Optional[StrictStr] = None, limit : Optional[Union[StrictFloat, StrictInt]] = None, offset : Optional[Union[StrictFloat, StrictInt]] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approval_requests_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_get_with_http_info(workspace_id, environment, committer, status, limit, offset, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment:
        :type environment: str
        :param committer:
        :type committer: str
        :param status:
        :type status: str
        :param limit:
        :type limit: float
        :param offset:
        :type offset: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalRequestsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'committer',
            'status',
            'limit',
            'offset'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approval_requests_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('committer') is not None:  # noqa: E501
            _query_params.append(('committer', _params['committer']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalRequestsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approval-requests', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approval_requests_id_get(self, id : StrictStr, **kwargs) -> ApiV1SecretApprovalRequestsIdGet200Response:  # noqa: E501
        """api_v1_secret_approval_requests_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalRequestsIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approval_requests_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approval_requests_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approval_requests_id_get_with_http_info(self, id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approval_requests_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalRequestsIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approval_requests_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalRequestsIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approval-requests/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approval_requests_id_merge_post(self, id : StrictStr, api_v1_secret_approval_requests_id_merge_post_request : Optional[ApiV1SecretApprovalRequestsIdMergePostRequest] = None, **kwargs) -> ApiV1SecretApprovalRequestsIdMergePost200Response:  # noqa: E501
        """api_v1_secret_approval_requests_id_merge_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_merge_post(id, api_v1_secret_approval_requests_id_merge_post_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_secret_approval_requests_id_merge_post_request:
        :type api_v1_secret_approval_requests_id_merge_post_request: ApiV1SecretApprovalRequestsIdMergePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalRequestsIdMergePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approval_requests_id_merge_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approval_requests_id_merge_post_with_http_info(id, api_v1_secret_approval_requests_id_merge_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approval_requests_id_merge_post_with_http_info(self, id : StrictStr, api_v1_secret_approval_requests_id_merge_post_request : Optional[ApiV1SecretApprovalRequestsIdMergePostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approval_requests_id_merge_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_merge_post_with_http_info(id, api_v1_secret_approval_requests_id_merge_post_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_secret_approval_requests_id_merge_post_request:
        :type api_v1_secret_approval_requests_id_merge_post_request: ApiV1SecretApprovalRequestsIdMergePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalRequestsIdMergePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'api_v1_secret_approval_requests_id_merge_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approval_requests_id_merge_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_approval_requests_id_merge_post_request'] is not None:
            _body_params = _params['api_v1_secret_approval_requests_id_merge_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalRequestsIdMergePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approval-requests/{id}/merge', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approval_requests_id_review_post(self, id : StrictStr, api_v1_secret_approval_requests_id_review_post_request : ApiV1SecretApprovalRequestsIdReviewPostRequest, **kwargs) -> ApiV1SecretApprovalRequestsIdReviewPost200Response:  # noqa: E501
        """api_v1_secret_approval_requests_id_review_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_review_post(id, api_v1_secret_approval_requests_id_review_post_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_secret_approval_requests_id_review_post_request: (required)
        :type api_v1_secret_approval_requests_id_review_post_request: ApiV1SecretApprovalRequestsIdReviewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalRequestsIdReviewPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approval_requests_id_review_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approval_requests_id_review_post_with_http_info(id, api_v1_secret_approval_requests_id_review_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approval_requests_id_review_post_with_http_info(self, id : StrictStr, api_v1_secret_approval_requests_id_review_post_request : ApiV1SecretApprovalRequestsIdReviewPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approval_requests_id_review_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_review_post_with_http_info(id, api_v1_secret_approval_requests_id_review_post_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_secret_approval_requests_id_review_post_request: (required)
        :type api_v1_secret_approval_requests_id_review_post_request: ApiV1SecretApprovalRequestsIdReviewPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalRequestsIdReviewPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'api_v1_secret_approval_requests_id_review_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approval_requests_id_review_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_approval_requests_id_review_post_request'] is not None:
            _body_params = _params['api_v1_secret_approval_requests_id_review_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalRequestsIdReviewPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approval-requests/{id}/review', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approval_requests_id_status_post(self, id : StrictStr, api_v1_secret_approval_requests_id_status_post_request : ApiV1SecretApprovalRequestsIdStatusPostRequest, **kwargs) -> ApiV1SecretApprovalRequestsIdMergePost200Response:  # noqa: E501
        """api_v1_secret_approval_requests_id_status_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_status_post(id, api_v1_secret_approval_requests_id_status_post_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_secret_approval_requests_id_status_post_request: (required)
        :type api_v1_secret_approval_requests_id_status_post_request: ApiV1SecretApprovalRequestsIdStatusPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalRequestsIdMergePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approval_requests_id_status_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approval_requests_id_status_post_with_http_info(id, api_v1_secret_approval_requests_id_status_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approval_requests_id_status_post_with_http_info(self, id : StrictStr, api_v1_secret_approval_requests_id_status_post_request : ApiV1SecretApprovalRequestsIdStatusPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approval_requests_id_status_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approval_requests_id_status_post_with_http_info(id, api_v1_secret_approval_requests_id_status_post_request, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param api_v1_secret_approval_requests_id_status_post_request: (required)
        :type api_v1_secret_approval_requests_id_status_post_request: ApiV1SecretApprovalRequestsIdStatusPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalRequestsIdMergePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'api_v1_secret_approval_requests_id_status_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approval_requests_id_status_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_approval_requests_id_status_post_request'] is not None:
            _body_params = _params['api_v1_secret_approval_requests_id_status_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalRequestsIdMergePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approval-requests/{id}/status', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approvals_board_get(self, workspace_id : StrictStr, environment : StrictStr, secret_path : StrictStr, **kwargs) -> ApiV1SecretApprovalsBoardGet200Response:  # noqa: E501
        """api_v1_secret_approvals_board_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_board_get(workspace_id, environment, secret_path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param secret_path: (required)
        :type secret_path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsBoardGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approvals_board_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approvals_board_get_with_http_info(workspace_id, environment, secret_path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approvals_board_get_with_http_info(self, workspace_id : StrictStr, environment : StrictStr, secret_path : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approvals_board_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_board_get_with_http_info(workspace_id, environment, secret_path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param secret_path: (required)
        :type secret_path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsBoardGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'secret_path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approvals_board_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('secret_path') is not None:  # noqa: E501
            _query_params.append(('secretPath', _params['secret_path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsBoardGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approvals/board', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approvals_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1SecretApprovalsGet200Response:  # noqa: E501
        """api_v1_secret_approvals_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approvals_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approvals_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approvals_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approvals_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approvals_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approvals', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approvals_post(self, api_v1_secret_approvals_post_request : ApiV1SecretApprovalsPostRequest, **kwargs) -> ApiV1SecretApprovalsPost200Response:  # noqa: E501
        """api_v1_secret_approvals_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_post(api_v1_secret_approvals_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_approvals_post_request: (required)
        :type api_v1_secret_approvals_post_request: ApiV1SecretApprovalsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approvals_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approvals_post_with_http_info(api_v1_secret_approvals_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approvals_post_with_http_info(self, api_v1_secret_approvals_post_request : ApiV1SecretApprovalsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approvals_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_post_with_http_info(api_v1_secret_approvals_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_approvals_post_request: (required)
        :type api_v1_secret_approvals_post_request: ApiV1SecretApprovalsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_approvals_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approvals_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_approvals_post_request'] is not None:
            _body_params = _params['api_v1_secret_approvals_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approvals', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approvals_sap_id_delete(self, sap_id : StrictStr, **kwargs) -> ApiV1SecretApprovalsPost200Response:  # noqa: E501
        """api_v1_secret_approvals_sap_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_sap_id_delete(sap_id, async_req=True)
        >>> result = thread.get()

        :param sap_id: (required)
        :type sap_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approvals_sap_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approvals_sap_id_delete_with_http_info(sap_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approvals_sap_id_delete_with_http_info(self, sap_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approvals_sap_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_sap_id_delete_with_http_info(sap_id, async_req=True)
        >>> result = thread.get()

        :param sap_id: (required)
        :type sap_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'sap_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approvals_sap_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['sap_id'] is not None:
            _path_params['sapId'] = _params['sap_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approvals/{sapId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_approvals_sap_id_patch(self, sap_id : StrictStr, api_v1_secret_approvals_sap_id_patch_request : ApiV1SecretApprovalsSapIdPatchRequest, **kwargs) -> ApiV1SecretApprovalsPost200Response:  # noqa: E501
        """api_v1_secret_approvals_sap_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_sap_id_patch(sap_id, api_v1_secret_approvals_sap_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param sap_id: (required)
        :type sap_id: str
        :param api_v1_secret_approvals_sap_id_patch_request: (required)
        :type api_v1_secret_approvals_sap_id_patch_request: ApiV1SecretApprovalsSapIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretApprovalsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_approvals_sap_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_approvals_sap_id_patch_with_http_info(sap_id, api_v1_secret_approvals_sap_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_approvals_sap_id_patch_with_http_info(self, sap_id : StrictStr, api_v1_secret_approvals_sap_id_patch_request : ApiV1SecretApprovalsSapIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_approvals_sap_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_approvals_sap_id_patch_with_http_info(sap_id, api_v1_secret_approvals_sap_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param sap_id: (required)
        :type sap_id: str
        :param api_v1_secret_approvals_sap_id_patch_request: (required)
        :type api_v1_secret_approvals_sap_id_patch_request: ApiV1SecretApprovalsSapIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretApprovalsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'sap_id',
            'api_v1_secret_approvals_sap_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_approvals_sap_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['sap_id'] is not None:
            _path_params['sapId'] = _params['sap_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_approvals_sap_id_patch_request'] is not None:
            _body_params = _params['api_v1_secret_approvals_sap_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretApprovalsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-approvals/{sapId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list secret imports from.")], environment : Annotated[StrictStr, Field(..., description="The slug of the environment to list secret imports from.")], path : Annotated[Optional[StrictStr], Field(description="The path to list secret imports from.")] = None, **kwargs) -> ApiV1SecretImportsGet200Response:  # noqa: E501
        """api_v1_secret_imports_get  # noqa: E501

        Get secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_get(workspace_id, environment, path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list secret imports from. (required)
        :type workspace_id: str
        :param environment: The slug of the environment to list secret imports from. (required)
        :type environment: str
        :param path: The path to list secret imports from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretImportsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_get_with_http_info(workspace_id, environment, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list secret imports from.")], environment : Annotated[StrictStr, Field(..., description="The slug of the environment to list secret imports from.")], path : Annotated[Optional[StrictStr], Field(description="The path to list secret imports from.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_get  # noqa: E501

        Get secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_get_with_http_info(workspace_id, environment, path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list secret imports from. (required)
        :type workspace_id: str
        :param environment: The slug of the environment to list secret imports from. (required)
        :type environment: str
        :param path: The path to list secret imports from.
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretImportsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretImportsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_post(self, api_v1_secret_imports_post_request : ApiV1SecretImportsPostRequest, **kwargs) -> ApiV1SecretImportsPost200Response:  # noqa: E501
        """api_v1_secret_imports_post  # noqa: E501

        Create secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_post(api_v1_secret_imports_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_imports_post_request: (required)
        :type api_v1_secret_imports_post_request: ApiV1SecretImportsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretImportsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_post_with_http_info(api_v1_secret_imports_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_post_with_http_info(self, api_v1_secret_imports_post_request : ApiV1SecretImportsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_post  # noqa: E501

        Create secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_post_with_http_info(api_v1_secret_imports_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_imports_post_request: (required)
        :type api_v1_secret_imports_post_request: ApiV1SecretImportsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretImportsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_imports_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_imports_post_request'] is not None:
            _body_params = _params['api_v1_secret_imports_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretImportsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_secret_import_id_delete(self, secret_import_id : Annotated[StrictStr, Field(..., description="The ID of the secret import to delete.")], api_v1_secret_imports_secret_import_id_delete_request : ApiV1SecretImportsSecretImportIdDeleteRequest, **kwargs) -> ApiV1SecretImportsPost200Response:  # noqa: E501
        """api_v1_secret_imports_secret_import_id_delete  # noqa: E501

        Delete secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secret_import_id_delete(secret_import_id, api_v1_secret_imports_secret_import_id_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_import_id: The ID of the secret import to delete. (required)
        :type secret_import_id: str
        :param api_v1_secret_imports_secret_import_id_delete_request: (required)
        :type api_v1_secret_imports_secret_import_id_delete_request: ApiV1SecretImportsSecretImportIdDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretImportsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_secret_import_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_secret_import_id_delete_with_http_info(secret_import_id, api_v1_secret_imports_secret_import_id_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_secret_import_id_delete_with_http_info(self, secret_import_id : Annotated[StrictStr, Field(..., description="The ID of the secret import to delete.")], api_v1_secret_imports_secret_import_id_delete_request : ApiV1SecretImportsSecretImportIdDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_secret_import_id_delete  # noqa: E501

        Delete secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secret_import_id_delete_with_http_info(secret_import_id, api_v1_secret_imports_secret_import_id_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_import_id: The ID of the secret import to delete. (required)
        :type secret_import_id: str
        :param api_v1_secret_imports_secret_import_id_delete_request: (required)
        :type api_v1_secret_imports_secret_import_id_delete_request: ApiV1SecretImportsSecretImportIdDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretImportsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_import_id',
            'api_v1_secret_imports_secret_import_id_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_secret_import_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_import_id'] is not None:
            _path_params['secretImportId'] = _params['secret_import_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_imports_secret_import_id_delete_request'] is not None:
            _body_params = _params['api_v1_secret_imports_secret_import_id_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretImportsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports/{secretImportId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_secret_import_id_patch(self, secret_import_id : Annotated[StrictStr, Field(..., description="The ID of the secret import to update.")], api_v1_secret_imports_secret_import_id_patch_request : ApiV1SecretImportsSecretImportIdPatchRequest, **kwargs) -> ApiV1SecretImportsPost200Response:  # noqa: E501
        """api_v1_secret_imports_secret_import_id_patch  # noqa: E501

        Update secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secret_import_id_patch(secret_import_id, api_v1_secret_imports_secret_import_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param secret_import_id: The ID of the secret import to update. (required)
        :type secret_import_id: str
        :param api_v1_secret_imports_secret_import_id_patch_request: (required)
        :type api_v1_secret_imports_secret_import_id_patch_request: ApiV1SecretImportsSecretImportIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretImportsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_secret_import_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_secret_import_id_patch_with_http_info(secret_import_id, api_v1_secret_imports_secret_import_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_secret_import_id_patch_with_http_info(self, secret_import_id : Annotated[StrictStr, Field(..., description="The ID of the secret import to update.")], api_v1_secret_imports_secret_import_id_patch_request : ApiV1SecretImportsSecretImportIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_secret_import_id_patch  # noqa: E501

        Update secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secret_import_id_patch_with_http_info(secret_import_id, api_v1_secret_imports_secret_import_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param secret_import_id: The ID of the secret import to update. (required)
        :type secret_import_id: str
        :param api_v1_secret_imports_secret_import_id_patch_request: (required)
        :type api_v1_secret_imports_secret_import_id_patch_request: ApiV1SecretImportsSecretImportIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretImportsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_import_id',
            'api_v1_secret_imports_secret_import_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_secret_import_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_import_id'] is not None:
            _path_params['secretImportId'] = _params['secret_import_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_imports_secret_import_id_patch_request'] is not None:
            _body_params = _params['api_v1_secret_imports_secret_import_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretImportsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports/{secretImportId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_secret_import_id_replication_resync_post(self, secret_import_id : Annotated[StrictStr, Field(..., description="The ID of the secret import to update.")], api_v1_secret_imports_secret_import_id_replication_resync_post_request : ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_secret_imports_secret_import_id_replication_resync_post  # noqa: E501

        Resync secret replication of secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secret_import_id_replication_resync_post(secret_import_id, api_v1_secret_imports_secret_import_id_replication_resync_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_import_id: The ID of the secret import to update. (required)
        :type secret_import_id: str
        :param api_v1_secret_imports_secret_import_id_replication_resync_post_request: (required)
        :type api_v1_secret_imports_secret_import_id_replication_resync_post_request: ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_secret_import_id_replication_resync_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_secret_import_id_replication_resync_post_with_http_info(secret_import_id, api_v1_secret_imports_secret_import_id_replication_resync_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_secret_import_id_replication_resync_post_with_http_info(self, secret_import_id : Annotated[StrictStr, Field(..., description="The ID of the secret import to update.")], api_v1_secret_imports_secret_import_id_replication_resync_post_request : ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_secret_import_id_replication_resync_post  # noqa: E501

        Resync secret replication of secret imports  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secret_import_id_replication_resync_post_with_http_info(secret_import_id, api_v1_secret_imports_secret_import_id_replication_resync_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_import_id: The ID of the secret import to update. (required)
        :type secret_import_id: str
        :param api_v1_secret_imports_secret_import_id_replication_resync_post_request: (required)
        :type api_v1_secret_imports_secret_import_id_replication_resync_post_request: ApiV1SecretImportsSecretImportIdReplicationResyncPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_import_id',
            'api_v1_secret_imports_secret_import_id_replication_resync_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_secret_import_id_replication_resync_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_import_id'] is not None:
            _path_params['secretImportId'] = _params['secret_import_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_imports_secret_import_id_replication_resync_post_request'] is not None:
            _body_params = _params['api_v1_secret_imports_secret_import_id_replication_resync_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports/{secretImportId}/replication-resync', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_secrets_get(self, workspace_id : StrictStr, environment : StrictStr, path : Optional[StrictStr] = None, **kwargs) -> ApiV1SecretImportsSecretsGet200Response:  # noqa: E501
        """api_v1_secret_imports_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secrets_get(workspace_id, environment, path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretImportsSecretsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_secrets_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_secrets_get_with_http_info(workspace_id, environment, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_secrets_get_with_http_info(self, workspace_id : StrictStr, environment : StrictStr, path : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secrets_get_with_http_info(workspace_id, environment, path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretImportsSecretsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_secrets_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretImportsSecretsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports/secrets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_imports_secrets_raw_get(self, workspace_id : StrictStr, environment : StrictStr, path : Optional[StrictStr] = None, **kwargs) -> ApiV1SecretImportsSecretsRawGet200Response:  # noqa: E501
        """api_v1_secret_imports_secrets_raw_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secrets_raw_get(workspace_id, environment, path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretImportsSecretsRawGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_imports_secrets_raw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_imports_secrets_raw_get_with_http_info(workspace_id, environment, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_imports_secrets_raw_get_with_http_info(self, workspace_id : StrictStr, environment : StrictStr, path : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_imports_secrets_raw_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_imports_secrets_raw_get_with_http_info(workspace_id, environment, path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretImportsSecretsRawGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_imports_secrets_raw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretImportsSecretsRawGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-imports/secrets/raw', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_rotation_providers_workspace_id_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1SecretRotationProvidersWorkspaceIdGet200Response:  # noqa: E501
        """api_v1_secret_rotation_providers_workspace_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotation_providers_workspace_id_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretRotationProvidersWorkspaceIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_rotation_providers_workspace_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_rotation_providers_workspace_id_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_rotation_providers_workspace_id_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_rotation_providers_workspace_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotation_providers_workspace_id_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretRotationProvidersWorkspaceIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_rotation_providers_workspace_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretRotationProvidersWorkspaceIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-rotation-providers/{workspaceId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_rotations_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1SecretRotationsGet200Response:  # noqa: E501
        """api_v1_secret_rotations_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretRotationsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_rotations_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_rotations_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_rotations_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_rotations_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretRotationsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_rotations_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretRotationsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-rotations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_rotations_id_delete(self, id : StrictStr, **kwargs) -> ApiV1SecretRotationsRestartPost200Response:  # noqa: E501
        """api_v1_secret_rotations_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretRotationsRestartPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_rotations_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_rotations_id_delete_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_rotations_id_delete_with_http_info(self, id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_rotations_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretRotationsRestartPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_rotations_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretRotationsRestartPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-rotations/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_rotations_post(self, api_v1_secret_rotations_post_request : ApiV1SecretRotationsPostRequest, **kwargs) -> ApiV1SecretRotationsPost200Response:  # noqa: E501
        """api_v1_secret_rotations_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_post(api_v1_secret_rotations_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_rotations_post_request: (required)
        :type api_v1_secret_rotations_post_request: ApiV1SecretRotationsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretRotationsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_rotations_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_rotations_post_with_http_info(api_v1_secret_rotations_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_rotations_post_with_http_info(self, api_v1_secret_rotations_post_request : ApiV1SecretRotationsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_rotations_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_post_with_http_info(api_v1_secret_rotations_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_rotations_post_request: (required)
        :type api_v1_secret_rotations_post_request: ApiV1SecretRotationsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretRotationsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_rotations_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_rotations_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_rotations_post_request'] is not None:
            _body_params = _params['api_v1_secret_rotations_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretRotationsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-rotations', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_rotations_restart_post(self, api_v1_secret_rotations_restart_post_request : ApiV1SecretRotationsRestartPostRequest, **kwargs) -> ApiV1SecretRotationsRestartPost200Response:  # noqa: E501
        """api_v1_secret_rotations_restart_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_restart_post(api_v1_secret_rotations_restart_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_rotations_restart_post_request: (required)
        :type api_v1_secret_rotations_restart_post_request: ApiV1SecretRotationsRestartPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretRotationsRestartPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_rotations_restart_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_rotations_restart_post_with_http_info(api_v1_secret_rotations_restart_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_rotations_restart_post_with_http_info(self, api_v1_secret_rotations_restart_post_request : ApiV1SecretRotationsRestartPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_rotations_restart_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_rotations_restart_post_with_http_info(api_v1_secret_rotations_restart_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_rotations_restart_post_request: (required)
        :type api_v1_secret_rotations_restart_post_request: ApiV1SecretRotationsRestartPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretRotationsRestartPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_rotations_restart_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_rotations_restart_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_rotations_restart_post_request'] is not None:
            _body_params = _params['api_v1_secret_rotations_restart_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretRotationsRestartPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-rotations/restart', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_scanning_create_installation_session_organization_post(self, api_v1_secret_scanning_create_installation_session_organization_post_request : ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, **kwargs) -> ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response:  # noqa: E501
        """api_v1_secret_scanning_create_installation_session_organization_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_create_installation_session_organization_post(api_v1_secret_scanning_create_installation_session_organization_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_scanning_create_installation_session_organization_post_request: (required)
        :type api_v1_secret_scanning_create_installation_session_organization_post_request: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_scanning_create_installation_session_organization_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_scanning_create_installation_session_organization_post_with_http_info(api_v1_secret_scanning_create_installation_session_organization_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_scanning_create_installation_session_organization_post_with_http_info(self, api_v1_secret_scanning_create_installation_session_organization_post_request : ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_scanning_create_installation_session_organization_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_create_installation_session_organization_post_with_http_info(api_v1_secret_scanning_create_installation_session_organization_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_scanning_create_installation_session_organization_post_request: (required)
        :type api_v1_secret_scanning_create_installation_session_organization_post_request: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_scanning_create_installation_session_organization_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_scanning_create_installation_session_organization_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_scanning_create_installation_session_organization_post_request'] is not None:
            _body_params = _params['api_v1_secret_scanning_create_installation_session_organization_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretScanningCreateInstallationSessionOrganizationPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-scanning/create-installation-session/organization', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_scanning_installation_status_organization_organization_id_get(self, organization_id : StrictStr, **kwargs) -> ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response:  # noqa: E501
        """api_v1_secret_scanning_installation_status_organization_organization_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_installation_status_organization_organization_id_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_scanning_installation_status_organization_organization_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_scanning_installation_status_organization_organization_id_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_scanning_installation_status_organization_organization_id_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_scanning_installation_status_organization_organization_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_installation_status_organization_organization_id_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_scanning_installation_status_organization_organization_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretScanningInstallationStatusOrganizationOrganizationIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-scanning/installation-status/organization/{organizationId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_scanning_link_installation_post(self, api_v1_secret_scanning_link_installation_post_request : ApiV1SecretScanningLinkInstallationPostRequest, **kwargs) -> ApiV1SecretScanningLinkInstallationPost200Response:  # noqa: E501
        """api_v1_secret_scanning_link_installation_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_link_installation_post(api_v1_secret_scanning_link_installation_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_scanning_link_installation_post_request: (required)
        :type api_v1_secret_scanning_link_installation_post_request: ApiV1SecretScanningLinkInstallationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretScanningLinkInstallationPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_scanning_link_installation_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_scanning_link_installation_post_with_http_info(api_v1_secret_scanning_link_installation_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_scanning_link_installation_post_with_http_info(self, api_v1_secret_scanning_link_installation_post_request : ApiV1SecretScanningLinkInstallationPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_scanning_link_installation_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_link_installation_post_with_http_info(api_v1_secret_scanning_link_installation_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_scanning_link_installation_post_request: (required)
        :type api_v1_secret_scanning_link_installation_post_request: ApiV1SecretScanningLinkInstallationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretScanningLinkInstallationPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_scanning_link_installation_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_scanning_link_installation_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_scanning_link_installation_post_request'] is not None:
            _body_params = _params['api_v1_secret_scanning_link_installation_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretScanningLinkInstallationPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-scanning/link-installation', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_scanning_organization_organization_id_risks_get(self, organization_id : StrictStr, **kwargs) -> ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response:  # noqa: E501
        """api_v1_secret_scanning_organization_organization_id_risks_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_organization_organization_id_risks_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_scanning_organization_organization_id_risks_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_scanning_organization_organization_id_risks_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_scanning_organization_organization_id_risks_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_scanning_organization_organization_id_risks_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_organization_organization_id_risks_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_scanning_organization_organization_id_risks_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretScanningOrganizationOrganizationIdRisksGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-scanning/organization/{organizationId}/risks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post(self, organization_id : StrictStr, risk_id : StrictStr, api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request : ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, **kwargs) -> ApiV1SecretScanningOrganizationOrganizationIdRisksGet200ResponseRisksInner:  # noqa: E501
        """api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post(organization_id, risk_id, api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param risk_id: (required)
        :type risk_id: str
        :param api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request: (required)
        :type api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request: ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretScanningOrganizationOrganizationIdRisksGet200ResponseRisksInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_with_http_info(organization_id, risk_id, api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_with_http_info(self, organization_id : StrictStr, risk_id : StrictStr, api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request : ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_with_http_info(organization_id, risk_id, api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param risk_id: (required)
        :type risk_id: str
        :param api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request: (required)
        :type api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request: ApiV1SecretScanningOrganizationOrganizationIdRisksRiskIdStatusPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretScanningOrganizationOrganizationIdRisksGet200ResponseRisksInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'risk_id',
            'api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['risk_id'] is not None:
            _path_params['riskId'] = _params['risk_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request'] is not None:
            _body_params = _params['api_v1_secret_scanning_organization_organization_id_risks_risk_id_status_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretScanningOrganizationOrganizationIdRisksGet200ResponseRisksInner",
        }

        return self.api_client.call_api(
            '/api/v1/secret-scanning/organization/{organizationId}/risks/{riskId}/status', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_secret_id_secret_versions_get(self, offset : Union[StrictFloat, StrictInt], limit : Union[StrictFloat, StrictInt], secret_id : StrictStr, **kwargs) -> ApiV1SecretSecretIdSecretVersionsGet200Response:  # noqa: E501
        """api_v1_secret_secret_id_secret_versions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_secret_id_secret_versions_get(offset, limit, secret_id, async_req=True)
        >>> result = thread.get()

        :param offset: (required)
        :type offset: float
        :param limit: (required)
        :type limit: float
        :param secret_id: (required)
        :type secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSecretIdSecretVersionsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_secret_id_secret_versions_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_secret_id_secret_versions_get_with_http_info(offset, limit, secret_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_secret_id_secret_versions_get_with_http_info(self, offset : Union[StrictFloat, StrictInt], limit : Union[StrictFloat, StrictInt], secret_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_secret_id_secret_versions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_secret_id_secret_versions_get_with_http_info(offset, limit, secret_id, async_req=True)
        >>> result = thread.get()

        :param offset: (required)
        :type offset: float
        :param limit: (required)
        :type limit: float
        :param secret_id: (required)
        :type secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSecretIdSecretVersionsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'offset',
            'limit',
            'secret_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_secret_id_secret_versions_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_id'] is not None:
            _path_params['secretId'] = _params['secret_id']


        # process the query parameters
        _query_params = []
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSecretIdSecretVersionsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret/{secretId}/secret-versions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_sharing_get(self, offset : Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]] = None, limit : Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]] = None, **kwargs) -> ApiV1SecretSharingGet200Response:  # noqa: E501
        """api_v1_secret_sharing_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_get(offset, limit, async_req=True)
        >>> result = thread.get()

        :param offset:
        :type offset: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSharingGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_sharing_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_sharing_get_with_http_info(offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_sharing_get_with_http_info(self, offset : Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]] = None, limit : Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_sharing_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_get_with_http_info(offset, limit, async_req=True)
        >>> result = thread.get()

        :param offset:
        :type offset: float
        :param limit:
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSharingGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_sharing_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSharingGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-sharing', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_sharing_post(self, api_v1_secret_sharing_post_request : ApiV1SecretSharingPostRequest, **kwargs) -> ApiV1SecretSharingPost200Response:  # noqa: E501
        """api_v1_secret_sharing_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_post(api_v1_secret_sharing_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_sharing_post_request: (required)
        :type api_v1_secret_sharing_post_request: ApiV1SecretSharingPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSharingPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_sharing_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_sharing_post_with_http_info(api_v1_secret_sharing_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_sharing_post_with_http_info(self, api_v1_secret_sharing_post_request : ApiV1SecretSharingPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_sharing_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_post_with_http_info(api_v1_secret_sharing_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_sharing_post_request: (required)
        :type api_v1_secret_sharing_post_request: ApiV1SecretSharingPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSharingPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_sharing_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_sharing_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_sharing_post_request'] is not None:
            _body_params = _params['api_v1_secret_sharing_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSharingPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-sharing', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_sharing_public_id_get(self, hashed_hex : constr(strict=True, min_length=1), id : StrictStr, **kwargs) -> ApiV1SecretSharingPublicIdGet200Response:  # noqa: E501
        """api_v1_secret_sharing_public_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_public_id_get(hashed_hex, id, async_req=True)
        >>> result = thread.get()

        :param hashed_hex: (required)
        :type hashed_hex: str
        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSharingPublicIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_sharing_public_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_sharing_public_id_get_with_http_info(hashed_hex, id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_sharing_public_id_get_with_http_info(self, hashed_hex : constr(strict=True, min_length=1), id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_sharing_public_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_public_id_get_with_http_info(hashed_hex, id, async_req=True)
        >>> result = thread.get()

        :param hashed_hex: (required)
        :type hashed_hex: str
        :param id: (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSharingPublicIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'hashed_hex',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_sharing_public_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        if _params.get('hashed_hex') is not None:  # noqa: E501
            _query_params.append(('hashedHex', _params['hashed_hex']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSharingPublicIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-sharing/public/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_sharing_public_post(self, api_v1_secret_sharing_public_post_request : ApiV1SecretSharingPublicPostRequest, **kwargs) -> ApiV1SecretSharingPost200Response:  # noqa: E501
        """api_v1_secret_sharing_public_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_public_post(api_v1_secret_sharing_public_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_sharing_public_post_request: (required)
        :type api_v1_secret_sharing_public_post_request: ApiV1SecretSharingPublicPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSharingPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_sharing_public_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_sharing_public_post_with_http_info(api_v1_secret_sharing_public_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_sharing_public_post_with_http_info(self, api_v1_secret_sharing_public_post_request : ApiV1SecretSharingPublicPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_sharing_public_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_public_post_with_http_info(api_v1_secret_sharing_public_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_sharing_public_post_request: (required)
        :type api_v1_secret_sharing_public_post_request: ApiV1SecretSharingPublicPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSharingPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_sharing_public_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_sharing_public_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_sharing_public_post_request'] is not None:
            _body_params = _params['api_v1_secret_sharing_public_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSharingPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-sharing/public', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_sharing_shared_secret_id_delete(self, shared_secret_id : StrictStr, **kwargs) -> ApiV1SecretSharingGet200ResponseSecretsInner:  # noqa: E501
        """api_v1_secret_sharing_shared_secret_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_shared_secret_id_delete(shared_secret_id, async_req=True)
        >>> result = thread.get()

        :param shared_secret_id: (required)
        :type shared_secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSharingGet200ResponseSecretsInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_sharing_shared_secret_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_sharing_shared_secret_id_delete_with_http_info(shared_secret_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_sharing_shared_secret_id_delete_with_http_info(self, shared_secret_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_sharing_shared_secret_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_sharing_shared_secret_id_delete_with_http_info(shared_secret_id, async_req=True)
        >>> result = thread.get()

        :param shared_secret_id: (required)
        :type shared_secret_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSharingGet200ResponseSecretsInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'shared_secret_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_sharing_shared_secret_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['shared_secret_id'] is not None:
            _path_params['sharedSecretId'] = _params['shared_secret_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSharingGet200ResponseSecretsInner",
        }

        return self.api_client.call_api(
            '/api/v1/secret-sharing/{sharedSecretId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_snapshot_secret_snapshot_id_get(self, secret_snapshot_id : StrictStr, **kwargs) -> ApiV1SecretSnapshotSecretSnapshotIdGet200Response:  # noqa: E501
        """api_v1_secret_snapshot_secret_snapshot_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_snapshot_secret_snapshot_id_get(secret_snapshot_id, async_req=True)
        >>> result = thread.get()

        :param secret_snapshot_id: (required)
        :type secret_snapshot_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSnapshotSecretSnapshotIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_snapshot_secret_snapshot_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_snapshot_secret_snapshot_id_get_with_http_info(secret_snapshot_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_snapshot_secret_snapshot_id_get_with_http_info(self, secret_snapshot_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_snapshot_secret_snapshot_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_snapshot_secret_snapshot_id_get_with_http_info(secret_snapshot_id, async_req=True)
        >>> result = thread.get()

        :param secret_snapshot_id: (required)
        :type secret_snapshot_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSnapshotSecretSnapshotIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_snapshot_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_snapshot_secret_snapshot_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_snapshot_id'] is not None:
            _path_params['secretSnapshotId'] = _params['secret_snapshot_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSnapshotSecretSnapshotIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-snapshot/{secretSnapshotId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_secret_snapshot_secret_snapshot_id_rollback_post(self, secret_snapshot_id : Annotated[StrictStr, Field(..., description="The ID of the snapshot to rollback to.")], **kwargs) -> ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response:  # noqa: E501
        """api_v1_secret_snapshot_secret_snapshot_id_rollback_post  # noqa: E501

        Roll back project secrets to those captured in a secret snapshot version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_snapshot_secret_snapshot_id_rollback_post(secret_snapshot_id, async_req=True)
        >>> result = thread.get()

        :param secret_snapshot_id: The ID of the snapshot to rollback to. (required)
        :type secret_snapshot_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_secret_snapshot_secret_snapshot_id_rollback_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_secret_snapshot_secret_snapshot_id_rollback_post_with_http_info(secret_snapshot_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_secret_snapshot_secret_snapshot_id_rollback_post_with_http_info(self, secret_snapshot_id : Annotated[StrictStr, Field(..., description="The ID of the snapshot to rollback to.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_secret_snapshot_secret_snapshot_id_rollback_post  # noqa: E501

        Roll back project secrets to those captured in a secret snapshot version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_secret_snapshot_secret_snapshot_id_rollback_post_with_http_info(secret_snapshot_id, async_req=True)
        >>> result = thread.get()

        :param secret_snapshot_id: The ID of the snapshot to rollback to. (required)
        :type secret_snapshot_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_snapshot_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_secret_snapshot_secret_snapshot_id_rollback_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_snapshot_id'] is not None:
            _path_params['secretSnapshotId'] = _params['secret_snapshot_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SecretSnapshotSecretSnapshotIdRollbackPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/secret-snapshot/{secretSnapshotId}/rollback', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_config_get(self, organization_id : StrictStr, **kwargs) -> ApiV1SsoConfigGet200Response:  # noqa: E501
        """api_v1_sso_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_config_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SsoConfigGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_config_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_config_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_config_get_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_config_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SsoConfigGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_config_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('organization_id') is not None:  # noqa: E501
            _query_params.append(('organizationId', _params['organization_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SsoConfigGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/sso/config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_config_patch(self, api_v1_sso_config_patch_request : ApiV1SsoConfigPatchRequest, **kwargs) -> ApiV1SsoConfigPost200Response:  # noqa: E501
        """api_v1_sso_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_config_patch(api_v1_sso_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_config_patch_request: (required)
        :type api_v1_sso_config_patch_request: ApiV1SsoConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SsoConfigPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_config_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_config_patch_with_http_info(api_v1_sso_config_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_config_patch_with_http_info(self, api_v1_sso_config_patch_request : ApiV1SsoConfigPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_config_patch_with_http_info(api_v1_sso_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_config_patch_request: (required)
        :type api_v1_sso_config_patch_request: ApiV1SsoConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SsoConfigPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_sso_config_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_config_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_sso_config_patch_request'] is not None:
            _body_params = _params['api_v1_sso_config_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SsoConfigPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/sso/config', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_config_post(self, api_v1_sso_config_post_request : ApiV1SsoConfigPostRequest, **kwargs) -> ApiV1SsoConfigPost200Response:  # noqa: E501
        """api_v1_sso_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_config_post(api_v1_sso_config_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_config_post_request: (required)
        :type api_v1_sso_config_post_request: ApiV1SsoConfigPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SsoConfigPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_config_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_config_post_with_http_info(api_v1_sso_config_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_config_post_with_http_info(self, api_v1_sso_config_post_request : ApiV1SsoConfigPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_config_post_with_http_info(api_v1_sso_config_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_config_post_request: (required)
        :type api_v1_sso_config_post_request: ApiV1SsoConfigPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SsoConfigPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_sso_config_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_config_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_sso_config_post_request'] is not None:
            _body_params = _params['api_v1_sso_config_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SsoConfigPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/sso/config', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_github_get(self, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_github_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_github_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_github_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_github_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_github_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_github_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_github_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_github_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/github', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_gitlab_get(self, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_gitlab_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_gitlab_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_gitlab_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_gitlab_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_gitlab_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_gitlab_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_gitlab_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_gitlab_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/gitlab', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_google_get(self, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_google_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_google_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_google_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_google_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_google_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_google_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_google_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_google_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/google', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_oidc_callback_get(self, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_oidc_callback_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_callback_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_oidc_callback_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_oidc_callback_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_oidc_callback_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_oidc_callback_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_callback_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_oidc_callback_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/oidc/callback', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_oidc_config_get(self, org_slug : StrictStr, **kwargs) -> ApiV1SsoOidcConfigGet200Response:  # noqa: E501
        """api_v1_sso_oidc_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_config_get(org_slug, async_req=True)
        >>> result = thread.get()

        :param org_slug: (required)
        :type org_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SsoOidcConfigGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_oidc_config_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_oidc_config_get_with_http_info(org_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_oidc_config_get_with_http_info(self, org_slug : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_oidc_config_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_config_get_with_http_info(org_slug, async_req=True)
        >>> result = thread.get()

        :param org_slug: (required)
        :type org_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SsoOidcConfigGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_oidc_config_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('org_slug') is not None:  # noqa: E501
            _query_params.append(('orgSlug', _params['org_slug']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SsoOidcConfigGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/sso/oidc/config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_oidc_config_patch(self, api_v1_sso_oidc_config_patch_request : ApiV1SsoOidcConfigPatchRequest, **kwargs) -> ApiV1SsoOidcConfigPatch200Response:  # noqa: E501
        """api_v1_sso_oidc_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_config_patch(api_v1_sso_oidc_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_oidc_config_patch_request: (required)
        :type api_v1_sso_oidc_config_patch_request: ApiV1SsoOidcConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SsoOidcConfigPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_oidc_config_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_oidc_config_patch_with_http_info(api_v1_sso_oidc_config_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_oidc_config_patch_with_http_info(self, api_v1_sso_oidc_config_patch_request : ApiV1SsoOidcConfigPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_oidc_config_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_config_patch_with_http_info(api_v1_sso_oidc_config_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_oidc_config_patch_request: (required)
        :type api_v1_sso_oidc_config_patch_request: ApiV1SsoOidcConfigPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SsoOidcConfigPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_sso_oidc_config_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_oidc_config_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_sso_oidc_config_patch_request'] is not None:
            _body_params = _params['api_v1_sso_oidc_config_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SsoOidcConfigPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v1/sso/oidc/config', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_oidc_config_post(self, api_v1_sso_oidc_config_post_request : ApiV1SsoOidcConfigPostRequest, **kwargs) -> ApiV1SsoOidcConfigPost200Response:  # noqa: E501
        """api_v1_sso_oidc_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_config_post(api_v1_sso_oidc_config_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_oidc_config_post_request: (required)
        :type api_v1_sso_oidc_config_post_request: ApiV1SsoOidcConfigPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1SsoOidcConfigPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_oidc_config_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_oidc_config_post_with_http_info(api_v1_sso_oidc_config_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_oidc_config_post_with_http_info(self, api_v1_sso_oidc_config_post_request : ApiV1SsoOidcConfigPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_oidc_config_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_config_post_with_http_info(api_v1_sso_oidc_config_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_oidc_config_post_request: (required)
        :type api_v1_sso_oidc_config_post_request: ApiV1SsoOidcConfigPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1SsoOidcConfigPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_sso_oidc_config_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_oidc_config_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_sso_oidc_config_post_request'] is not None:
            _body_params = _params['api_v1_sso_oidc_config_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1SsoOidcConfigPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/sso/oidc/config', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_oidc_login_error_get(self, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_oidc_login_error_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_login_error_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_oidc_login_error_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_oidc_login_error_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_oidc_login_error_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_oidc_login_error_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_login_error_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_oidc_login_error_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/oidc/login/error', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_oidc_login_get(self, org_slug : StrictStr, callback_port : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_oidc_login_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_login_get(org_slug, callback_port, async_req=True)
        >>> result = thread.get()

        :param org_slug: (required)
        :type org_slug: str
        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_oidc_login_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_oidc_login_get_with_http_info(org_slug, callback_port, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_oidc_login_get_with_http_info(self, org_slug : StrictStr, callback_port : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_oidc_login_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_oidc_login_get_with_http_info(org_slug, callback_port, async_req=True)
        >>> result = thread.get()

        :param org_slug: (required)
        :type org_slug: str
        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'org_slug',
            'callback_port'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_oidc_login_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('org_slug') is not None:  # noqa: E501
            _query_params.append(('orgSlug', _params['org_slug']))

        if _params.get('callback_port') is not None:  # noqa: E501
            _query_params.append(('callbackPort', _params['callback_port']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/oidc/login', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_redirect_github_get(self, callback_port : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_redirect_github_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_github_get(callback_port, async_req=True)
        >>> result = thread.get()

        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_redirect_github_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_redirect_github_get_with_http_info(callback_port, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_redirect_github_get_with_http_info(self, callback_port : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_redirect_github_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_github_get_with_http_info(callback_port, async_req=True)
        >>> result = thread.get()

        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'callback_port'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_redirect_github_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('callback_port') is not None:  # noqa: E501
            _query_params.append(('callback_port', _params['callback_port']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/redirect/github', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_redirect_gitlab_get(self, callback_port : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_redirect_gitlab_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_gitlab_get(callback_port, async_req=True)
        >>> result = thread.get()

        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_redirect_gitlab_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_redirect_gitlab_get_with_http_info(callback_port, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_redirect_gitlab_get_with_http_info(self, callback_port : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_redirect_gitlab_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_gitlab_get_with_http_info(callback_port, async_req=True)
        >>> result = thread.get()

        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'callback_port'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_redirect_gitlab_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('callback_port') is not None:  # noqa: E501
            _query_params.append(('callback_port', _params['callback_port']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/redirect/gitlab', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_redirect_google_get(self, callback_port : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_redirect_google_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_google_get(callback_port, async_req=True)
        >>> result = thread.get()

        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_redirect_google_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_redirect_google_get_with_http_info(callback_port, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_redirect_google_get_with_http_info(self, callback_port : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_redirect_google_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_google_get_with_http_info(callback_port, async_req=True)
        >>> result = thread.get()

        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'callback_port'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_redirect_google_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('callback_port') is not None:  # noqa: E501
            _query_params.append(('callback_port', _params['callback_port']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/redirect/google', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_redirect_saml2_organizations_org_slug_get(self, org_slug : StrictStr, callback_port : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_redirect_saml2_organizations_org_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_saml2_organizations_org_slug_get(org_slug, callback_port, async_req=True)
        >>> result = thread.get()

        :param org_slug: (required)
        :type org_slug: str
        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_redirect_saml2_organizations_org_slug_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_redirect_saml2_organizations_org_slug_get_with_http_info(org_slug, callback_port, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_redirect_saml2_organizations_org_slug_get_with_http_info(self, org_slug : StrictStr, callback_port : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_redirect_saml2_organizations_org_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_saml2_organizations_org_slug_get_with_http_info(org_slug, callback_port, async_req=True)
        >>> result = thread.get()

        :param org_slug: (required)
        :type org_slug: str
        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'org_slug',
            'callback_port'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_redirect_saml2_organizations_org_slug_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['org_slug'] is not None:
            _path_params['orgSlug'] = _params['org_slug']


        # process the query parameters
        _query_params = []
        if _params.get('callback_port') is not None:  # noqa: E501
            _query_params.append(('callback_port', _params['callback_port']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/redirect/saml2/organizations/{orgSlug}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_redirect_saml2_saml_config_id_get(self, saml_config_id : StrictStr, callback_port : Optional[StrictStr] = None, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_redirect_saml2_saml_config_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_saml2_saml_config_id_get(saml_config_id, callback_port, async_req=True)
        >>> result = thread.get()

        :param saml_config_id: (required)
        :type saml_config_id: str
        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_redirect_saml2_saml_config_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_redirect_saml2_saml_config_id_get_with_http_info(saml_config_id, callback_port, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_redirect_saml2_saml_config_id_get_with_http_info(self, saml_config_id : StrictStr, callback_port : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_redirect_saml2_saml_config_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_redirect_saml2_saml_config_id_get_with_http_info(saml_config_id, callback_port, async_req=True)
        >>> result = thread.get()

        :param saml_config_id: (required)
        :type saml_config_id: str
        :param callback_port:
        :type callback_port: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'saml_config_id',
            'callback_port'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_redirect_saml2_saml_config_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['saml_config_id'] is not None:
            _path_params['samlConfigId'] = _params['saml_config_id']


        # process the query parameters
        _query_params = []
        if _params.get('callback_port') is not None:  # noqa: E501
            _query_params.append(('callback_port', _params['callback_port']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/redirect/saml2/{samlConfigId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_saml2_saml_config_id_post(self, saml_config_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_saml2_saml_config_id_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_saml2_saml_config_id_post(saml_config_id, async_req=True)
        >>> result = thread.get()

        :param saml_config_id: (required)
        :type saml_config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_saml2_saml_config_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_saml2_saml_config_id_post_with_http_info(saml_config_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_saml2_saml_config_id_post_with_http_info(self, saml_config_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_saml2_saml_config_id_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_saml2_saml_config_id_post_with_http_info(saml_config_id, async_req=True)
        >>> result = thread.get()

        :param saml_config_id: (required)
        :type saml_config_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'saml_config_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_saml2_saml_config_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['saml_config_id'] is not None:
            _path_params['samlConfigId'] = _params['saml_config_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/saml2/{samlConfigId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_sso_token_exchange_post(self, api_v1_sso_token_exchange_post_request : ApiV1SsoTokenExchangePostRequest, **kwargs) -> None:  # noqa: E501
        """api_v1_sso_token_exchange_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_token_exchange_post(api_v1_sso_token_exchange_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_token_exchange_post_request: (required)
        :type api_v1_sso_token_exchange_post_request: ApiV1SsoTokenExchangePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_sso_token_exchange_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_sso_token_exchange_post_with_http_info(api_v1_sso_token_exchange_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_sso_token_exchange_post_with_http_info(self, api_v1_sso_token_exchange_post_request : ApiV1SsoTokenExchangePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_sso_token_exchange_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_sso_token_exchange_post_with_http_info(api_v1_sso_token_exchange_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_sso_token_exchange_post_request: (required)
        :type api_v1_sso_token_exchange_post_request: ApiV1SsoTokenExchangePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'api_v1_sso_token_exchange_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_sso_token_exchange_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_sso_token_exchange_post_request'] is not None:
            _body_params = _params['api_v1_sso_token_exchange_post_request']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/sso/token-exchange', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_action_get(self, action : StrictStr, **kwargs) -> ApiV1UserActionGet200Response:  # noqa: E501
        """api_v1_user_action_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_action_get(action, async_req=True)
        >>> result = thread.get()

        :param action: (required)
        :type action: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1UserActionGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_action_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_action_get_with_http_info(action, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_action_get_with_http_info(self, action : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_action_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_action_get_with_http_info(action, async_req=True)
        >>> result = thread.get()

        :param action: (required)
        :type action: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1UserActionGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'action'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_action_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('action') is not None:  # noqa: E501
            _query_params.append(('action', _params['action']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1UserActionGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/user-action', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_action_post(self, api_v1_user_action_post_request : ApiV1UserActionPostRequest, **kwargs) -> ApiV1UserActionPost200Response:  # noqa: E501
        """api_v1_user_action_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_action_post(api_v1_user_action_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_user_action_post_request: (required)
        :type api_v1_user_action_post_request: ApiV1UserActionPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1UserActionPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_action_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_action_post_with_http_info(api_v1_user_action_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_action_post_with_http_info(self, api_v1_user_action_post_request : ApiV1UserActionPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_action_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_action_post_with_http_info(api_v1_user_action_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_user_action_post_request: (required)
        :type api_v1_user_action_post_request: ApiV1UserActionPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1UserActionPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_user_action_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_action_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_user_action_post_request'] is not None:
            _body_params = _params['api_v1_user_action_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1UserActionPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/user-action', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_engagement_me_wish_post(self, api_v1_user_engagement_me_wish_post_request : ApiV1UserEngagementMeWishPostRequest, **kwargs) -> object:  # noqa: E501
        """api_v1_user_engagement_me_wish_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_engagement_me_wish_post(api_v1_user_engagement_me_wish_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_user_engagement_me_wish_post_request: (required)
        :type api_v1_user_engagement_me_wish_post_request: ApiV1UserEngagementMeWishPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_engagement_me_wish_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_engagement_me_wish_post_with_http_info(api_v1_user_engagement_me_wish_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_engagement_me_wish_post_with_http_info(self, api_v1_user_engagement_me_wish_post_request : ApiV1UserEngagementMeWishPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_engagement_me_wish_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_engagement_me_wish_post_with_http_info(api_v1_user_engagement_me_wish_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_user_engagement_me_wish_post_request: (required)
        :type api_v1_user_engagement_me_wish_post_request: ApiV1UserEngagementMeWishPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_user_engagement_me_wish_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_engagement_me_wish_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_user_engagement_me_wish_post_request'] is not None:
            _body_params = _params['api_v1_user_engagement_me_wish_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v1/user-engagement/me/wish', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_get(self, **kwargs) -> ApiV1UserGet200Response:  # noqa: E501
        """api_v1_user_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1UserGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1UserGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1UserGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/user', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_me_project_favorites_get(self, org_id : StrictStr, **kwargs) -> ApiV1UserMeProjectFavoritesGet200Response:  # noqa: E501
        """api_v1_user_me_project_favorites_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_me_project_favorites_get(org_id, async_req=True)
        >>> result = thread.get()

        :param org_id: (required)
        :type org_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1UserMeProjectFavoritesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_me_project_favorites_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_me_project_favorites_get_with_http_info(org_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_me_project_favorites_get_with_http_info(self, org_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_me_project_favorites_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_me_project_favorites_get_with_http_info(org_id, async_req=True)
        >>> result = thread.get()

        :param org_id: (required)
        :type org_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1UserMeProjectFavoritesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_me_project_favorites_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('org_id') is not None:  # noqa: E501
            _query_params.append(('orgId', _params['org_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1UserMeProjectFavoritesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/user/me/project-favorites', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_me_project_favorites_put(self, api_v1_user_me_project_favorites_put_request : ApiV1UserMeProjectFavoritesPutRequest, **kwargs) -> None:  # noqa: E501
        """api_v1_user_me_project_favorites_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_me_project_favorites_put(api_v1_user_me_project_favorites_put_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_user_me_project_favorites_put_request: (required)
        :type api_v1_user_me_project_favorites_put_request: ApiV1UserMeProjectFavoritesPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_me_project_favorites_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_me_project_favorites_put_with_http_info(api_v1_user_me_project_favorites_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_me_project_favorites_put_with_http_info(self, api_v1_user_me_project_favorites_put_request : ApiV1UserMeProjectFavoritesPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_me_project_favorites_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_me_project_favorites_put_with_http_info(api_v1_user_me_project_favorites_put_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_user_me_project_favorites_put_request: (required)
        :type api_v1_user_me_project_favorites_put_request: ApiV1UserMeProjectFavoritesPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'api_v1_user_me_project_favorites_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_me_project_favorites_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_user_me_project_favorites_put_request'] is not None:
            _body_params = _params['api_v1_user_me_project_favorites_put_request']

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/user/me/project-favorites', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_private_key_get(self, **kwargs) -> ApiV1UserPrivateKeyGet200Response:  # noqa: E501
        """api_v1_user_private_key_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_private_key_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1UserPrivateKeyGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_private_key_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_private_key_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_private_key_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_private_key_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_private_key_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1UserPrivateKeyGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_private_key_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1UserPrivateKeyGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/user/private-key', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_user_user_id_unlock_get(self, token : StrictStr, user_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """api_v1_user_user_id_unlock_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_user_id_unlock_get(token, user_id, async_req=True)
        >>> result = thread.get()

        :param token: (required)
        :type token: str
        :param user_id: (required)
        :type user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_user_user_id_unlock_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_user_user_id_unlock_get_with_http_info(token, user_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_user_user_id_unlock_get_with_http_info(self, token : StrictStr, user_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_user_user_id_unlock_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_user_user_id_unlock_get_with_http_info(token, user_id, async_req=True)
        >>> result = thread.get()

        :param token: (required)
        :type token: str
        :param user_id: (required)
        :type user_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'token',
            'user_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_user_user_id_unlock_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['user_id'] is not None:
            _path_params['userId'] = _params['user_id']


        # process the query parameters
        _query_params = []
        if _params.get('token') is not None:  # noqa: E501
            _query_params.append(('token', _params['token']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/user/{userId}/unlock', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_webhooks_get(self, workspace_id : StrictStr, environment : Optional[StrictStr] = None, secret_path : Optional[StrictStr] = None, **kwargs) -> ApiV1WebhooksGet200Response:  # noqa: E501
        """api_v1_webhooks_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_get(workspace_id, environment, secret_path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment:
        :type environment: str
        :param secret_path:
        :type secret_path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WebhooksGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_webhooks_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_webhooks_get_with_http_info(workspace_id, environment, secret_path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_webhooks_get_with_http_info(self, workspace_id : StrictStr, environment : Optional[StrictStr] = None, secret_path : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_webhooks_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_get_with_http_info(workspace_id, environment, secret_path, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment:
        :type environment: str
        :param secret_path:
        :type secret_path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WebhooksGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'secret_path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_webhooks_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('secret_path') is not None:  # noqa: E501
            _query_params.append(('secretPath', _params['secret_path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WebhooksGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/webhooks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_webhooks_post(self, api_v1_webhooks_post_request : ApiV1WebhooksPostRequest, **kwargs) -> ApiV1WebhooksPost200Response:  # noqa: E501
        """api_v1_webhooks_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_post(api_v1_webhooks_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_webhooks_post_request: (required)
        :type api_v1_webhooks_post_request: ApiV1WebhooksPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WebhooksPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_webhooks_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_webhooks_post_with_http_info(api_v1_webhooks_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_webhooks_post_with_http_info(self, api_v1_webhooks_post_request : ApiV1WebhooksPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_webhooks_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_post_with_http_info(api_v1_webhooks_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_webhooks_post_request: (required)
        :type api_v1_webhooks_post_request: ApiV1WebhooksPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WebhooksPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_webhooks_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_webhooks_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_webhooks_post_request'] is not None:
            _body_params = _params['api_v1_webhooks_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WebhooksPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/webhooks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_webhooks_webhook_id_delete(self, webhook_id : StrictStr, **kwargs) -> None:  # noqa: E501
        """api_v1_webhooks_webhook_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_webhook_id_delete(webhook_id, async_req=True)
        >>> result = thread.get()

        :param webhook_id: (required)
        :type webhook_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_webhooks_webhook_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_webhooks_webhook_id_delete_with_http_info(webhook_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_webhooks_webhook_id_delete_with_http_info(self, webhook_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_webhooks_webhook_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_webhook_id_delete_with_http_info(webhook_id, async_req=True)
        >>> result = thread.get()

        :param webhook_id: (required)
        :type webhook_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'webhook_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_webhooks_webhook_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['webhook_id'] is not None:
            _path_params['webhookId'] = _params['webhook_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/api/v1/webhooks/{webhookId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_webhooks_webhook_id_patch(self, webhook_id : StrictStr, api_v1_webhooks_webhook_id_patch_request : Optional[ApiV1WebhooksWebhookIdPatchRequest] = None, **kwargs) -> ApiV1WebhooksPost200Response:  # noqa: E501
        """api_v1_webhooks_webhook_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_webhook_id_patch(webhook_id, api_v1_webhooks_webhook_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param webhook_id: (required)
        :type webhook_id: str
        :param api_v1_webhooks_webhook_id_patch_request:
        :type api_v1_webhooks_webhook_id_patch_request: ApiV1WebhooksWebhookIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WebhooksPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_webhooks_webhook_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_webhooks_webhook_id_patch_with_http_info(webhook_id, api_v1_webhooks_webhook_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_webhooks_webhook_id_patch_with_http_info(self, webhook_id : StrictStr, api_v1_webhooks_webhook_id_patch_request : Optional[ApiV1WebhooksWebhookIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_webhooks_webhook_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_webhook_id_patch_with_http_info(webhook_id, api_v1_webhooks_webhook_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param webhook_id: (required)
        :type webhook_id: str
        :param api_v1_webhooks_webhook_id_patch_request:
        :type api_v1_webhooks_webhook_id_patch_request: ApiV1WebhooksWebhookIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WebhooksPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'webhook_id',
            'api_v1_webhooks_webhook_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_webhooks_webhook_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['webhook_id'] is not None:
            _path_params['webhookId'] = _params['webhook_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_webhooks_webhook_id_patch_request'] is not None:
            _body_params = _params['api_v1_webhooks_webhook_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WebhooksPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/webhooks/{webhookId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_webhooks_webhook_id_test_post(self, webhook_id : StrictStr, **kwargs) -> ApiV1WebhooksPost200Response:  # noqa: E501
        """api_v1_webhooks_webhook_id_test_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_webhook_id_test_post(webhook_id, async_req=True)
        >>> result = thread.get()

        :param webhook_id: (required)
        :type webhook_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WebhooksPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_webhooks_webhook_id_test_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_webhooks_webhook_id_test_post_with_http_info(webhook_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_webhooks_webhook_id_test_post_with_http_info(self, webhook_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_webhooks_webhook_id_test_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_webhooks_webhook_id_test_post_with_http_info(webhook_id, async_req=True)
        >>> result = thread.get()

        :param webhook_id: (required)
        :type webhook_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WebhooksPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'webhook_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_webhooks_webhook_id_test_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['webhook_id'] is not None:
            _path_params['webhookId'] = _params['webhook_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WebhooksPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/webhooks/{webhookId}/test', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_get(self, **kwargs) -> ApiV1WorkspaceGet200Response:  # noqa: E501
        """api_v1_workspace_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_permissions_get(self, project_id : StrictStr, **kwargs) -> ApiV1WorkspaceProjectIdPermissionsGet200Response:  # noqa: E501
        """api_v1_workspace_project_id_permissions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_permissions_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdPermissionsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_permissions_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_permissions_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_permissions_get_with_http_info(self, project_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_permissions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_permissions_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdPermissionsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_permissions_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdPermissionsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/permissions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_tags_get(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to list tags from.")], **kwargs) -> ApiV1WorkspaceProjectIdTagsGet200Response:  # noqa: E501
        """api_v1_workspace_project_id_tags_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to list tags from. (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdTagsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_tags_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_tags_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_tags_get_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to list tags from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_tags_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to list tags from. (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdTagsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_tags_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdTagsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/tags', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_tags_post(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to create the tag in.")], api_v1_workspace_project_id_tags_post_request : ApiV1WorkspaceProjectIdTagsPostRequest, **kwargs) -> ApiV1WorkspaceProjectIdTagsPost200Response:  # noqa: E501
        """api_v1_workspace_project_id_tags_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_post(project_id, api_v1_workspace_project_id_tags_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to create the tag in. (required)
        :type project_id: str
        :param api_v1_workspace_project_id_tags_post_request: (required)
        :type api_v1_workspace_project_id_tags_post_request: ApiV1WorkspaceProjectIdTagsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdTagsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_tags_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_tags_post_with_http_info(project_id, api_v1_workspace_project_id_tags_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_tags_post_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to create the tag in.")], api_v1_workspace_project_id_tags_post_request : ApiV1WorkspaceProjectIdTagsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_tags_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_post_with_http_info(project_id, api_v1_workspace_project_id_tags_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to create the tag in. (required)
        :type project_id: str
        :param api_v1_workspace_project_id_tags_post_request: (required)
        :type api_v1_workspace_project_id_tags_post_request: ApiV1WorkspaceProjectIdTagsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdTagsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'api_v1_workspace_project_id_tags_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_tags_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_project_id_tags_post_request'] is not None:
            _body_params = _params['api_v1_workspace_project_id_tags_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdTagsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/tags', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_tags_slug_tag_slug_get(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get tags from.")], tag_slug : Annotated[StrictStr, Field(..., description="The slug of the tag to get details")], **kwargs) -> ApiV1WorkspaceProjectIdTagsTagIdGet200Response:  # noqa: E501
        """api_v1_workspace_project_id_tags_slug_tag_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_slug_tag_slug_get(project_id, tag_slug, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get tags from. (required)
        :type project_id: str
        :param tag_slug: The slug of the tag to get details (required)
        :type tag_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdTagsTagIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_tags_slug_tag_slug_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_tags_slug_tag_slug_get_with_http_info(project_id, tag_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_tags_slug_tag_slug_get_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get tags from.")], tag_slug : Annotated[StrictStr, Field(..., description="The slug of the tag to get details")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_tags_slug_tag_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_slug_tag_slug_get_with_http_info(project_id, tag_slug, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get tags from. (required)
        :type project_id: str
        :param tag_slug: The slug of the tag to get details (required)
        :type tag_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdTagsTagIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'tag_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_tags_slug_tag_slug_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['tag_slug'] is not None:
            _path_params['tagSlug'] = _params['tag_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdTagsTagIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/tags/slug/{tagSlug}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_tags_tag_id_delete(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the tag from.")], tag_id : Annotated[StrictStr, Field(..., description="The ID of the tag to delete.")], **kwargs) -> ApiV1WorkspaceProjectIdTagsPost200Response:  # noqa: E501
        """api_v1_workspace_project_id_tags_tag_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_tag_id_delete(project_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to delete the tag from. (required)
        :type project_id: str
        :param tag_id: The ID of the tag to delete. (required)
        :type tag_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdTagsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_tags_tag_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_tags_tag_id_delete_with_http_info(project_id, tag_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_tags_tag_id_delete_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the tag from.")], tag_id : Annotated[StrictStr, Field(..., description="The ID of the tag to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_tags_tag_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_tag_id_delete_with_http_info(project_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to delete the tag from. (required)
        :type project_id: str
        :param tag_id: The ID of the tag to delete. (required)
        :type tag_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdTagsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'tag_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_tags_tag_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['tag_id'] is not None:
            _path_params['tagId'] = _params['tag_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdTagsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/tags/{tagId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_tags_tag_id_get(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get tags from.")], tag_id : Annotated[StrictStr, Field(..., description="The ID of the tag to get details")], **kwargs) -> ApiV1WorkspaceProjectIdTagsTagIdGet200Response:  # noqa: E501
        """api_v1_workspace_project_id_tags_tag_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_tag_id_get(project_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get tags from. (required)
        :type project_id: str
        :param tag_id: The ID of the tag to get details (required)
        :type tag_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdTagsTagIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_tags_tag_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_tags_tag_id_get_with_http_info(project_id, tag_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_tags_tag_id_get_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get tags from.")], tag_id : Annotated[StrictStr, Field(..., description="The ID of the tag to get details")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_tags_tag_id_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_tag_id_get_with_http_info(project_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get tags from. (required)
        :type project_id: str
        :param tag_id: The ID of the tag to get details (required)
        :type tag_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdTagsTagIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'tag_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_tags_tag_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['tag_id'] is not None:
            _path_params['tagId'] = _params['tag_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdTagsTagIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/tags/{tagId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_id_tags_tag_id_patch(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the tag in.")], tag_id : Annotated[StrictStr, Field(..., description="The ID of the tag to get details")], api_v1_workspace_project_id_tags_tag_id_patch_request : ApiV1WorkspaceProjectIdTagsTagIdPatchRequest, **kwargs) -> ApiV1WorkspaceProjectIdTagsPost200Response:  # noqa: E501
        """api_v1_workspace_project_id_tags_tag_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_tag_id_patch(project_id, tag_id, api_v1_workspace_project_id_tags_tag_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to update the tag in. (required)
        :type project_id: str
        :param tag_id: The ID of the tag to get details (required)
        :type tag_id: str
        :param api_v1_workspace_project_id_tags_tag_id_patch_request: (required)
        :type api_v1_workspace_project_id_tags_tag_id_patch_request: ApiV1WorkspaceProjectIdTagsTagIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectIdTagsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_id_tags_tag_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_id_tags_tag_id_patch_with_http_info(project_id, tag_id, api_v1_workspace_project_id_tags_tag_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_id_tags_tag_id_patch_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the tag in.")], tag_id : Annotated[StrictStr, Field(..., description="The ID of the tag to get details")], api_v1_workspace_project_id_tags_tag_id_patch_request : ApiV1WorkspaceProjectIdTagsTagIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_id_tags_tag_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_id_tags_tag_id_patch_with_http_info(project_id, tag_id, api_v1_workspace_project_id_tags_tag_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to update the tag in. (required)
        :type project_id: str
        :param tag_id: The ID of the tag to get details (required)
        :type tag_id: str
        :param api_v1_workspace_project_id_tags_tag_id_patch_request: (required)
        :type api_v1_workspace_project_id_tags_tag_id_patch_request: ApiV1WorkspaceProjectIdTagsTagIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectIdTagsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'tag_id',
            'api_v1_workspace_project_id_tags_tag_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_id_tags_tag_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['tag_id'] is not None:
            _path_params['tagId'] = _params['tag_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_project_id_tags_tag_id_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_project_id_tags_tag_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectIdTagsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectId}/tags/{tagId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_slug_roles_get(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to list the roles of.")], **kwargs) -> ApiV1WorkspaceProjectSlugRolesGet200Response:  # noqa: E501
        """api_v1_workspace_project_slug_roles_get  # noqa: E501

        List project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_get(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to list the roles of. (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectSlugRolesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_slug_roles_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_slug_roles_get_with_http_info(project_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_slug_roles_get_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to list the roles of.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_slug_roles_get  # noqa: E501

        List project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_get_with_http_info(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to list the roles of. (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectSlugRolesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_slug_roles_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectSlugRolesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectSlug}/roles', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_slug_roles_post(self, project_slug : Annotated[StrictStr, Field(..., description="Slug of the project to create the role for.")], api_v1_workspace_project_slug_roles_post_request : ApiV1WorkspaceProjectSlugRolesPostRequest, **kwargs) -> ApiV1WorkspaceProjectSlugRolesPost200Response:  # noqa: E501
        """api_v1_workspace_project_slug_roles_post  # noqa: E501

        Create a project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_post(project_slug, api_v1_workspace_project_slug_roles_post_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: Slug of the project to create the role for. (required)
        :type project_slug: str
        :param api_v1_workspace_project_slug_roles_post_request: (required)
        :type api_v1_workspace_project_slug_roles_post_request: ApiV1WorkspaceProjectSlugRolesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectSlugRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_slug_roles_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_slug_roles_post_with_http_info(project_slug, api_v1_workspace_project_slug_roles_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_slug_roles_post_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="Slug of the project to create the role for.")], api_v1_workspace_project_slug_roles_post_request : ApiV1WorkspaceProjectSlugRolesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_slug_roles_post  # noqa: E501

        Create a project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_post_with_http_info(project_slug, api_v1_workspace_project_slug_roles_post_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: Slug of the project to create the role for. (required)
        :type project_slug: str
        :param api_v1_workspace_project_slug_roles_post_request: (required)
        :type api_v1_workspace_project_slug_roles_post_request: ApiV1WorkspaceProjectSlugRolesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectSlugRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'api_v1_workspace_project_slug_roles_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_slug_roles_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_project_slug_roles_post_request'] is not None:
            _body_params = _params['api_v1_workspace_project_slug_roles_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectSlugRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectSlug}/roles', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_slug_roles_role_id_delete(self, project_slug : Annotated[StrictStr, Field(..., description="Slug of the project to delete this role for.")], role_id : Annotated[StrictStr, Field(..., description="The ID of the role to update")], **kwargs) -> ApiV1WorkspaceProjectSlugRolesPost200Response:  # noqa: E501
        """api_v1_workspace_project_slug_roles_role_id_delete  # noqa: E501

        Delete a project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_role_id_delete(project_slug, role_id, async_req=True)
        >>> result = thread.get()

        :param project_slug: Slug of the project to delete this role for. (required)
        :type project_slug: str
        :param role_id: The ID of the role to update (required)
        :type role_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectSlugRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_slug_roles_role_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_slug_roles_role_id_delete_with_http_info(project_slug, role_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_slug_roles_role_id_delete_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="Slug of the project to delete this role for.")], role_id : Annotated[StrictStr, Field(..., description="The ID of the role to update")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_slug_roles_role_id_delete  # noqa: E501

        Delete a project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_role_id_delete_with_http_info(project_slug, role_id, async_req=True)
        >>> result = thread.get()

        :param project_slug: Slug of the project to delete this role for. (required)
        :type project_slug: str
        :param role_id: The ID of the role to update (required)
        :type role_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectSlugRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'role_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_slug_roles_role_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']

        if _params['role_id'] is not None:
            _path_params['roleId'] = _params['role_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectSlugRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectSlug}/roles/{roleId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_slug_roles_role_id_patch(self, project_slug : Annotated[StrictStr, Field(..., description="Slug of the project to update the role for.")], role_id : Annotated[StrictStr, Field(..., description="The ID of the role to update")], api_v1_workspace_project_slug_roles_role_id_patch_request : Optional[ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest] = None, **kwargs) -> ApiV1WorkspaceProjectSlugRolesPost200Response:  # noqa: E501
        """api_v1_workspace_project_slug_roles_role_id_patch  # noqa: E501

        Update a project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_role_id_patch(project_slug, role_id, api_v1_workspace_project_slug_roles_role_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: Slug of the project to update the role for. (required)
        :type project_slug: str
        :param role_id: The ID of the role to update (required)
        :type role_id: str
        :param api_v1_workspace_project_slug_roles_role_id_patch_request:
        :type api_v1_workspace_project_slug_roles_role_id_patch_request: ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectSlugRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_slug_roles_role_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_slug_roles_role_id_patch_with_http_info(project_slug, role_id, api_v1_workspace_project_slug_roles_role_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_slug_roles_role_id_patch_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="Slug of the project to update the role for.")], role_id : Annotated[StrictStr, Field(..., description="The ID of the role to update")], api_v1_workspace_project_slug_roles_role_id_patch_request : Optional[ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_slug_roles_role_id_patch  # noqa: E501

        Update a project role  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_role_id_patch_with_http_info(project_slug, role_id, api_v1_workspace_project_slug_roles_role_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: Slug of the project to update the role for. (required)
        :type project_slug: str
        :param role_id: The ID of the role to update (required)
        :type role_id: str
        :param api_v1_workspace_project_slug_roles_role_id_patch_request:
        :type api_v1_workspace_project_slug_roles_role_id_patch_request: ApiV1WorkspaceProjectSlugRolesRoleIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectSlugRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'role_id',
            'api_v1_workspace_project_slug_roles_role_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_slug_roles_role_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']

        if _params['role_id'] is not None:
            _path_params['roleId'] = _params['role_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_project_slug_roles_role_id_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_project_slug_roles_role_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectSlugRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectSlug}/roles/{roleId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_project_slug_roles_slug_slug_get(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project.")], slug : Annotated[StrictStr, Field(..., description="The slug of the role to get details")], **kwargs) -> ApiV1WorkspaceProjectSlugRolesPost200Response:  # noqa: E501
        """api_v1_workspace_project_slug_roles_slug_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_slug_slug_get(project_slug, slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project. (required)
        :type project_slug: str
        :param slug: The slug of the role to get details (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceProjectSlugRolesPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_project_slug_roles_slug_slug_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_project_slug_roles_slug_slug_get_with_http_info(project_slug, slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_project_slug_roles_slug_slug_get_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project.")], slug : Annotated[StrictStr, Field(..., description="The slug of the role to get details")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_project_slug_roles_slug_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_project_slug_roles_slug_slug_get_with_http_info(project_slug, slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project. (required)
        :type project_slug: str
        :param slug: The slug of the role to get details (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceProjectSlugRolesPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_project_slug_roles_slug_slug_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']

        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceProjectSlugRolesPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{projectSlug}/roles/slug/{slug}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_audit_logs_filters_actors_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_audit_logs_filters_actors_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_audit_logs_filters_actors_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_audit_logs_filters_actors_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_audit_logs_filters_actors_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_audit_logs_filters_actors_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_audit_logs_filters_actors_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_audit_logs_filters_actors_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_audit_logs_filters_actors_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdAuditLogsFiltersActorsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/audit-logs/filters/actors', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_audit_logs_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to export audit logs from.")], event_type : Annotated[Optional[StrictStr], Field(description="The type of the event to export.")] = None, user_agent_type : Annotated[Optional[StrictStr], Field(description="Choose which consuming application to export audit logs for.")] = None, start_date : Annotated[Optional[datetime], Field(description="The date to start the export from.")] = None, end_date : Annotated[Optional[datetime], Field(description="The date to end the export at.")] = None, offset : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The offset to start from. If you enter 10, it will start from the 10th audit log.")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The number of audit logs to return.")] = None, actor : Annotated[Optional[StrictStr], Field(description="The actor to filter the audit logs by.")] = None, **kwargs) -> ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_audit_logs_get  # noqa: E501

        Return audit logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_audit_logs_get(workspace_id, event_type, user_agent_type, start_date, end_date, offset, limit, actor, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to export audit logs from. (required)
        :type workspace_id: str
        :param event_type: The type of the event to export.
        :type event_type: str
        :param user_agent_type: Choose which consuming application to export audit logs for.
        :type user_agent_type: str
        :param start_date: The date to start the export from.
        :type start_date: datetime
        :param end_date: The date to end the export at.
        :type end_date: datetime
        :param offset: The offset to start from. If you enter 10, it will start from the 10th audit log.
        :type offset: float
        :param limit: The number of audit logs to return.
        :type limit: float
        :param actor: The actor to filter the audit logs by.
        :type actor: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_audit_logs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_audit_logs_get_with_http_info(workspace_id, event_type, user_agent_type, start_date, end_date, offset, limit, actor, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_audit_logs_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to export audit logs from.")], event_type : Annotated[Optional[StrictStr], Field(description="The type of the event to export.")] = None, user_agent_type : Annotated[Optional[StrictStr], Field(description="Choose which consuming application to export audit logs for.")] = None, start_date : Annotated[Optional[datetime], Field(description="The date to start the export from.")] = None, end_date : Annotated[Optional[datetime], Field(description="The date to end the export at.")] = None, offset : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The offset to start from. If you enter 10, it will start from the 10th audit log.")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The number of audit logs to return.")] = None, actor : Annotated[Optional[StrictStr], Field(description="The actor to filter the audit logs by.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_audit_logs_get  # noqa: E501

        Return audit logs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_audit_logs_get_with_http_info(workspace_id, event_type, user_agent_type, start_date, end_date, offset, limit, actor, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to export audit logs from. (required)
        :type workspace_id: str
        :param event_type: The type of the event to export.
        :type event_type: str
        :param user_agent_type: Choose which consuming application to export audit logs for.
        :type user_agent_type: str
        :param start_date: The date to start the export from.
        :type start_date: datetime
        :param end_date: The date to end the export at.
        :type end_date: datetime
        :param offset: The offset to start from. If you enter 10, it will start from the 10th audit log.
        :type offset: float
        :param limit: The number of audit logs to return.
        :type limit: float
        :param actor: The actor to filter the audit logs by.
        :type actor: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'event_type',
            'user_agent_type',
            'start_date',
            'end_date',
            'offset',
            'limit',
            'actor'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_audit_logs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        if _params.get('event_type') is not None:  # noqa: E501
            _query_params.append(('eventType', _params['event_type']))

        if _params.get('user_agent_type') is not None:  # noqa: E501
            _query_params.append(('userAgentType', _params['user_agent_type']))

        if _params.get('start_date') is not None:  # noqa: E501
            if isinstance(_params['start_date'], datetime):
                _query_params.append(('startDate', _params['start_date'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('startDate', _params['start_date']))

        if _params.get('end_date') is not None:  # noqa: E501
            if isinstance(_params['end_date'], datetime):
                _query_params.append(('endDate', _params['end_date'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('endDate', _params['end_date']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('actor') is not None:  # noqa: E501
            _query_params.append(('actor', _params['actor']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdAuditLogsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/audit-logs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_authorizations_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list integration auths for.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdAuthorizationsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_authorizations_get  # noqa: E501

        List integration auth objects for a workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_authorizations_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list integration auths for. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdAuthorizationsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_authorizations_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_authorizations_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_authorizations_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list integration auths for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_authorizations_get  # noqa: E501

        List integration auth objects for a workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_authorizations_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list integration auths for. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdAuthorizationsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_authorizations_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdAuthorizationsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/authorizations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_auto_capitalization_post(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_auto_capitalization_post_request : ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdNamePost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_auto_capitalization_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_auto_capitalization_post(workspace_id, api_v1_workspace_workspace_id_auto_capitalization_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_auto_capitalization_post_request: (required)
        :type api_v1_workspace_workspace_id_auto_capitalization_post_request: ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_auto_capitalization_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_auto_capitalization_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_auto_capitalization_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_auto_capitalization_post_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_auto_capitalization_post_request : ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_auto_capitalization_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_auto_capitalization_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_auto_capitalization_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_auto_capitalization_post_request: (required)
        :type api_v1_workspace_workspace_id_auto_capitalization_post_request: ApiV1WorkspaceWorkspaceIdAutoCapitalizationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_auto_capitalization_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_auto_capitalization_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_auto_capitalization_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_auto_capitalization_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/auto-capitalization', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_delete(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdDelete200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_delete  # noqa: E501

        Delete project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_delete(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to delete. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_delete_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_delete_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_delete  # noqa: E501

        Delete project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_delete_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to delete. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_env_id_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project the environment belongs to.")], env_id : Annotated[StrictStr, Field(..., description="The ID of the environment to fetch.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_env_id_get  # noqa: E501

        Get Environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_env_id_get(workspace_id, env_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project the environment belongs to. (required)
        :type workspace_id: str
        :param env_id: The ID of the environment to fetch. (required)
        :type env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_environments_env_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_environments_env_id_get_with_http_info(workspace_id, env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_env_id_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project the environment belongs to.")], env_id : Annotated[StrictStr, Field(..., description="The ID of the environment to fetch.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_env_id_get  # noqa: E501

        Get Environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_env_id_get_with_http_info(workspace_id, env_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project the environment belongs to. (required)
        :type workspace_id: str
        :param env_id: The ID of the environment to fetch. (required)
        :type env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_environments_env_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['env_id'] is not None:
            _path_params['envId'] = _params['env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdEnvironmentsEnvIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/environments/{envId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_id_delete(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the environment from.")], id : Annotated[StrictStr, Field(..., description="The ID of the environment to delete.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_id_delete  # noqa: E501

        Delete environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_id_delete(workspace_id, id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to delete the environment from. (required)
        :type workspace_id: str
        :param id: The ID of the environment to delete. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_environments_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_environments_id_delete_with_http_info(workspace_id, id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_id_delete_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the environment from.")], id : Annotated[StrictStr, Field(..., description="The ID of the environment to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_id_delete  # noqa: E501

        Delete environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_id_delete_with_http_info(workspace_id, id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to delete the environment from. (required)
        :type workspace_id: str
        :param id: The ID of the environment to delete. (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_environments_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/environments/{id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_id_patch(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the environment in.")], id : Annotated[StrictStr, Field(..., description="The ID of the environment to update.")], api_v1_workspace_workspace_id_environments_id_patch_request : Optional[ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest] = None, **kwargs) -> ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_id_patch  # noqa: E501

        Update environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_id_patch(workspace_id, id, api_v1_workspace_workspace_id_environments_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to update the environment in. (required)
        :type workspace_id: str
        :param id: The ID of the environment to update. (required)
        :type id: str
        :param api_v1_workspace_workspace_id_environments_id_patch_request:
        :type api_v1_workspace_workspace_id_environments_id_patch_request: ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_environments_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_environments_id_patch_with_http_info(workspace_id, id, api_v1_workspace_workspace_id_environments_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_id_patch_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the environment in.")], id : Annotated[StrictStr, Field(..., description="The ID of the environment to update.")], api_v1_workspace_workspace_id_environments_id_patch_request : Optional[ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_id_patch  # noqa: E501

        Update environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_id_patch_with_http_info(workspace_id, id, api_v1_workspace_workspace_id_environments_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to update the environment in. (required)
        :type workspace_id: str
        :param id: The ID of the environment to update. (required)
        :type id: str
        :param api_v1_workspace_workspace_id_environments_id_patch_request:
        :type api_v1_workspace_workspace_id_environments_id_patch_request: ApiV1WorkspaceWorkspaceIdEnvironmentsIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'id',
            'api_v1_workspace_workspace_id_environments_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_environments_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['id'] is not None:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_environments_id_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_environments_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/environments/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_post(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to create the environment in.")], api_v1_workspace_workspace_id_environments_post_request : ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_post  # noqa: E501

        Create environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_post(workspace_id, api_v1_workspace_workspace_id_environments_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to create the environment in. (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_environments_post_request: (required)
        :type api_v1_workspace_workspace_id_environments_post_request: ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_environments_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_environments_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_environments_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_environments_post_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to create the environment in.")], api_v1_workspace_workspace_id_environments_post_request : ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_environments_post  # noqa: E501

        Create environment  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_environments_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_environments_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to create the environment in. (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_environments_post_request: (required)
        :type api_v1_workspace_workspace_id_environments_post_request: ApiV1WorkspaceWorkspaceIdEnvironmentsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_environments_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_environments_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_environments_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_environments_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdEnvironmentsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/environments', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_get  # noqa: E501

        Get project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_get  # noqa: E501

        Get project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_integrations_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list integrations for.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_integrations_get  # noqa: E501

        List integrations for a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_integrations_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list integrations for. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_integrations_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_integrations_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_integrations_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to list integrations for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_integrations_get  # noqa: E501

        List integrations for a project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_integrations_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list integrations for. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_integrations_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdIntegrationsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/integrations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_key_post(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_key_post_request : ApiV1WorkspaceWorkspaceIdKeyPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_key_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_key_post(workspace_id, api_v1_workspace_workspace_id_key_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_key_post_request: (required)
        :type api_v1_workspace_workspace_id_key_post_request: ApiV1WorkspaceWorkspaceIdKeyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_key_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_key_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_key_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_key_post_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_key_post_request : ApiV1WorkspaceWorkspaceIdKeyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_key_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_key_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_key_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_key_post_request: (required)
        :type api_v1_workspace_workspace_id_key_post_request: ApiV1WorkspaceWorkspaceIdKeyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_key_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_key_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_key_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_key_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/key', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_keys_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdKeysGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_keys_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdKeysGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_keys_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_keys_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_keys_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_keys_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdKeysGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_keys_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdKeysGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_backup_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_backup_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_backup_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_kms_backup_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_kms_backup_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_backup_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_backup_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_backup_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_kms_backup_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdKmsBackupGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/kms/backup', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_backup_post(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_kms_backup_post_request : ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdKmsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_backup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_backup_post(workspace_id, api_v1_workspace_workspace_id_kms_backup_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_kms_backup_post_request: (required)
        :type api_v1_workspace_workspace_id_kms_backup_post_request: ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdKmsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_kms_backup_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_kms_backup_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_kms_backup_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_backup_post_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_kms_backup_post_request : ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_backup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_backup_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_kms_backup_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_kms_backup_post_request: (required)
        :type api_v1_workspace_workspace_id_kms_backup_post_request: ApiV1WorkspaceWorkspaceIdKmsBackupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdKmsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_kms_backup_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_kms_backup_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_kms_backup_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_kms_backup_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdKmsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/kms/backup', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdKmsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdKmsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_kms_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_kms_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdKmsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_kms_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdKmsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/kms', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_patch(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_kms_patch_request : ApiV1WorkspaceWorkspaceIdKmsPatchRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdKmsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_patch(workspace_id, api_v1_workspace_workspace_id_kms_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_kms_patch_request: (required)
        :type api_v1_workspace_workspace_id_kms_patch_request: ApiV1WorkspaceWorkspaceIdKmsPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdKmsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_kms_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_kms_patch_with_http_info(workspace_id, api_v1_workspace_workspace_id_kms_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_kms_patch_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_kms_patch_request : ApiV1WorkspaceWorkspaceIdKmsPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_kms_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_kms_patch_with_http_info(workspace_id, api_v1_workspace_workspace_id_kms_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_kms_patch_request: (required)
        :type api_v1_workspace_workspace_id_kms_patch_request: ApiV1WorkspaceWorkspaceIdKmsPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdKmsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_kms_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_kms_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_kms_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_kms_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdKmsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/kms', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_leave_delete(self, workspace_id : StrictStr, **kwargs) -> ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_leave_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_leave_delete(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_leave_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_leave_delete_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_leave_delete_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_leave_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_leave_delete_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_leave_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/leave', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_details_post(self, workspace_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the project to get memberships from.")], api_v1_workspace_workspace_id_memberships_details_post_request : ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_details_post  # noqa: E501

        Return project user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_details_post(workspace_id, api_v1_workspace_workspace_id_memberships_details_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to get memberships from. (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_memberships_details_post_request: (required)
        :type api_v1_workspace_workspace_id_memberships_details_post_request: ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_memberships_details_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_memberships_details_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_memberships_details_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_details_post_with_http_info(self, workspace_id : Annotated[constr(strict=True, min_length=1), Field(..., description="The ID of the project to get memberships from.")], api_v1_workspace_workspace_id_memberships_details_post_request : ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_details_post  # noqa: E501

        Return project user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_details_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_memberships_details_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to get memberships from. (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_memberships_details_post_request: (required)
        :type api_v1_workspace_workspace_id_memberships_details_post_request: ApiV1WorkspaceWorkspaceIdMembershipsDetailsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_memberships_details_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_memberships_details_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_memberships_details_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_memberships_details_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMembershipsDetailsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/memberships/details', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to get memberships from.")], **kwargs) -> ApiV1WorkspaceWorkspaceIdMembershipsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_get  # noqa: E501

        Return project user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to get memberships from. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMembershipsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_memberships_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_memberships_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to get memberships from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_get  # noqa: E501

        Return project user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to get memberships from. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMembershipsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_memberships_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMembershipsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/memberships', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_membership_id_delete(self, workspace_id : StrictStr, membership_id : StrictStr, **kwargs) -> ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_membership_id_delete  # noqa: E501

        Delete project user membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_membership_id_delete(workspace_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param membership_id: (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_memberships_membership_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_memberships_membership_id_delete_with_http_info(workspace_id, membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_membership_id_delete_with_http_info(self, workspace_id : StrictStr, membership_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_membership_id_delete  # noqa: E501

        Delete project user membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_membership_id_delete_with_http_info(workspace_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param membership_id: (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_memberships_membership_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['membership_id'] is not None:
            _path_params['membershipId'] = _params['membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationAdminProjectsProjectIdGrantAdminAccessPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/memberships/{membershipId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_membership_id_patch(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the membership for.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to update.")], api_v1_workspace_workspace_id_memberships_membership_id_patch_request : ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_membership_id_patch  # noqa: E501

        Update project user membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_membership_id_patch(workspace_id, membership_id, api_v1_workspace_workspace_id_memberships_membership_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to update the membership for. (required)
        :type workspace_id: str
        :param membership_id: The ID of the membership to update. (required)
        :type membership_id: str
        :param api_v1_workspace_workspace_id_memberships_membership_id_patch_request: (required)
        :type api_v1_workspace_workspace_id_memberships_membership_id_patch_request: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_memberships_membership_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_memberships_membership_id_patch_with_http_info(workspace_id, membership_id, api_v1_workspace_workspace_id_memberships_membership_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_membership_id_patch_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the membership for.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to update.")], api_v1_workspace_workspace_id_memberships_membership_id_patch_request : ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_membership_id_patch  # noqa: E501

        Update project user membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_membership_id_patch_with_http_info(workspace_id, membership_id, api_v1_workspace_workspace_id_memberships_membership_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to update the membership for. (required)
        :type workspace_id: str
        :param membership_id: The ID of the membership to update. (required)
        :type membership_id: str
        :param api_v1_workspace_workspace_id_memberships_membership_id_patch_request: (required)
        :type api_v1_workspace_workspace_id_memberships_membership_id_patch_request: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'membership_id',
            'api_v1_workspace_workspace_id_memberships_membership_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_memberships_membership_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['membership_id'] is not None:
            _path_params['membershipId'] = _params['membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_memberships_membership_id_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_memberships_membership_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/memberships/{membershipId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_post(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_memberships_post_request : ApiV1WorkspaceWorkspaceIdMembershipsPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMembershipsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_post(workspace_id, api_v1_workspace_workspace_id_memberships_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_memberships_post_request: (required)
        :type api_v1_workspace_workspace_id_memberships_post_request: ApiV1WorkspaceWorkspaceIdMembershipsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMembershipsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_memberships_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_memberships_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_memberships_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_memberships_post_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_memberships_post_request : ApiV1WorkspaceWorkspaceIdMembershipsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_memberships_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_memberships_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_memberships_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_memberships_post_request: (required)
        :type api_v1_workspace_workspace_id_memberships_post_request: ApiV1WorkspaceWorkspaceIdMembershipsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMembershipsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_memberships_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_memberships_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_memberships_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_memberships_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMembershipsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/memberships', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_migrate_v3_post(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_migrate_v3_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_migrate_v3_post(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_migrate_v3_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_migrate_v3_post_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_migrate_v3_post_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_migrate_v3_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_migrate_v3_post_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_migrate_v3_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/migrate-v3', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_name_post(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_name_post_request : ApiV1WorkspaceWorkspaceIdNamePostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdNamePost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_name_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_name_post(workspace_id, api_v1_workspace_workspace_id_name_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_name_post_request: (required)
        :type api_v1_workspace_workspace_id_name_post_request: ApiV1WorkspaceWorkspaceIdNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_name_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_name_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_name_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_name_post_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_name_post_request : ApiV1WorkspaceWorkspaceIdNamePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_name_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_name_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_name_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_name_post_request: (required)
        :type api_v1_workspace_workspace_id_name_post_request: ApiV1WorkspaceWorkspaceIdNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_name_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_name_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_name_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_name_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/name', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_patch(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to update.")], api_v1_workspace_workspace_id_patch_request : Optional[ApiV1WorkspaceWorkspaceIdPatchRequest] = None, **kwargs) -> ApiV1WorkspaceWorkspaceIdPatch200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_patch  # noqa: E501

        Update project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_patch(workspace_id, api_v1_workspace_workspace_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to update. (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_patch_request:
        :type api_v1_workspace_workspace_id_patch_request: ApiV1WorkspaceWorkspaceIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_patch_with_http_info(workspace_id, api_v1_workspace_workspace_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_patch_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to update.")], api_v1_workspace_workspace_id_patch_request : Optional[ApiV1WorkspaceWorkspaceIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_patch  # noqa: E501

        Update project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_patch_with_http_info(workspace_id, api_v1_workspace_workspace_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to update. (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_patch_request:
        :type api_v1_workspace_workspace_id_patch_request: ApiV1WorkspaceWorkspaceIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_secret_snapshots_count_get(self, environment : StrictStr, workspace_id : StrictStr, path : Optional[StrictStr] = None, **kwargs) -> ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_secret_snapshots_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_secret_snapshots_count_get(environment, workspace_id, path, async_req=True)
        >>> result = thread.get()

        :param environment: (required)
        :type environment: str
        :param workspace_id: (required)
        :type workspace_id: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_secret_snapshots_count_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_secret_snapshots_count_get_with_http_info(environment, workspace_id, path, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_secret_snapshots_count_get_with_http_info(self, environment : StrictStr, workspace_id : StrictStr, path : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_secret_snapshots_count_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_secret_snapshots_count_get_with_http_info(environment, workspace_id, path, async_req=True)
        >>> result = thread.get()

        :param environment: (required)
        :type environment: str
        :param workspace_id: (required)
        :type workspace_id: str
        :param path:
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'environment',
            'workspace_id',
            'path'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_secret_snapshots_count_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdSecretSnapshotsCountGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/secret-snapshots/count', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_secret_snapshots_get(self, environment : Annotated[StrictStr, Field(..., description="The environment to get snapshots from.")], workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to get snapshots from.")], path : Annotated[Optional[StrictStr], Field(description="The secret path to get snapshots from.")] = None, offset : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The offset to start from. If you enter 10, it will start from the 10th snapshot.")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The number of snapshots to return.")] = None, **kwargs) -> ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_secret_snapshots_get  # noqa: E501

        Return project secret snapshots ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_secret_snapshots_get(environment, workspace_id, path, offset, limit, async_req=True)
        >>> result = thread.get()

        :param environment: The environment to get snapshots from. (required)
        :type environment: str
        :param workspace_id: The ID of the project to get snapshots from. (required)
        :type workspace_id: str
        :param path: The secret path to get snapshots from.
        :type path: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th snapshot.
        :type offset: float
        :param limit: The number of snapshots to return.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_secret_snapshots_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_secret_snapshots_get_with_http_info(environment, workspace_id, path, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_secret_snapshots_get_with_http_info(self, environment : Annotated[StrictStr, Field(..., description="The environment to get snapshots from.")], workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to get snapshots from.")], path : Annotated[Optional[StrictStr], Field(description="The secret path to get snapshots from.")] = None, offset : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The offset to start from. If you enter 10, it will start from the 10th snapshot.")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The number of snapshots to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_secret_snapshots_get  # noqa: E501

        Return project secret snapshots ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_secret_snapshots_get_with_http_info(environment, workspace_id, path, offset, limit, async_req=True)
        >>> result = thread.get()

        :param environment: The environment to get snapshots from. (required)
        :type environment: str
        :param workspace_id: The ID of the project to get snapshots from. (required)
        :type workspace_id: str
        :param path: The secret path to get snapshots from.
        :type path: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th snapshot.
        :type offset: float
        :param limit: The number of snapshots to return.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'environment',
            'workspace_id',
            'path',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_secret_snapshots_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdSecretSnapshotsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/secret-snapshots', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_service_token_data_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_service_token_data_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_service_token_data_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_service_token_data_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_service_token_data_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_service_token_data_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_service_token_data_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_service_token_data_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_service_token_data_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdServiceTokenDataGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/service-token-data', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_trusted_ips_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_trusted_ips_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_trusted_ips_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdTrustedIpsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/trusted-ips', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_post(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_trusted_ips_post_request : ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_post(workspace_id, api_v1_workspace_workspace_id_trusted_ips_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_trusted_ips_post_request: (required)
        :type api_v1_workspace_workspace_id_trusted_ips_post_request: ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_trusted_ips_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_trusted_ips_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_trusted_ips_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_post_with_http_info(self, workspace_id : StrictStr, api_v1_workspace_workspace_id_trusted_ips_post_request : ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_post_with_http_info(workspace_id, api_v1_workspace_workspace_id_trusted_ips_post_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param api_v1_workspace_workspace_id_trusted_ips_post_request: (required)
        :type api_v1_workspace_workspace_id_trusted_ips_post_request: ApiV1WorkspaceWorkspaceIdTrustedIpsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'api_v1_workspace_workspace_id_trusted_ips_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_trusted_ips_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_trusted_ips_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_trusted_ips_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/trusted-ips', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete(self, workspace_id : StrictStr, trusted_ip_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete(workspace_id, trusted_ip_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param trusted_ip_id: (required)
        :type trusted_ip_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete_with_http_info(workspace_id, trusted_ip_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete_with_http_info(self, workspace_id : StrictStr, trusted_ip_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete_with_http_info(workspace_id, trusted_ip_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param trusted_ip_id: (required)
        :type trusted_ip_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'trusted_ip_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['trusted_ip_id'] is not None:
            _path_params['trustedIpId'] = _params['trusted_ip_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/trusted-ips/{trustedIpId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch(self, workspace_id : StrictStr, trusted_ip_id : StrictStr, api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request : ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch(workspace_id, trusted_ip_id, api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param trusted_ip_id: (required)
        :type trusted_ip_id: str
        :param api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request: (required)
        :type api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request: ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_with_http_info(workspace_id, trusted_ip_id, api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_with_http_info(self, workspace_id : StrictStr, trusted_ip_id : StrictStr, api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request : ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_with_http_info(workspace_id, trusted_ip_id, api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param trusted_ip_id: (required)
        :type trusted_ip_id: str
        :param api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request: (required)
        :type api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request: ApiV1WorkspaceWorkspaceIdTrustedIpsTrustedIpIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'trusted_ip_id',
            'api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']

        if _params['trusted_ip_id'] is not None:
            _path_params['trustedIpId'] = _params['trusted_ip_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_trusted_ips_trusted_ip_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdTrustedIpsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/trusted-ips/{trustedIpId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_id_users_get(self, workspace_id : StrictStr, **kwargs) -> ApiV1WorkspaceWorkspaceIdUsersGet200Response:  # noqa: E501
        """api_v1_workspace_workspace_id_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_users_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdUsersGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_id_users_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_id_users_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_id_users_get_with_http_info(self, workspace_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_id_users_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_id_users_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdUsersGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_id_users_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdUsersGet200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceId}/users', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_slug_audit_logs_retention_put(self, workspace_slug : StrictStr, api_v1_workspace_workspace_slug_audit_logs_retention_put_request : ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdNamePost200Response:  # noqa: E501
        """api_v1_workspace_workspace_slug_audit_logs_retention_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_slug_audit_logs_retention_put(workspace_slug, api_v1_workspace_workspace_slug_audit_logs_retention_put_request, async_req=True)
        >>> result = thread.get()

        :param workspace_slug: (required)
        :type workspace_slug: str
        :param api_v1_workspace_workspace_slug_audit_logs_retention_put_request: (required)
        :type api_v1_workspace_workspace_slug_audit_logs_retention_put_request: ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_slug_audit_logs_retention_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_slug_audit_logs_retention_put_with_http_info(workspace_slug, api_v1_workspace_workspace_slug_audit_logs_retention_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_slug_audit_logs_retention_put_with_http_info(self, workspace_slug : StrictStr, api_v1_workspace_workspace_slug_audit_logs_retention_put_request : ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_slug_audit_logs_retention_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_slug_audit_logs_retention_put_with_http_info(workspace_slug, api_v1_workspace_workspace_slug_audit_logs_retention_put_request, async_req=True)
        >>> result = thread.get()

        :param workspace_slug: (required)
        :type workspace_slug: str
        :param api_v1_workspace_workspace_slug_audit_logs_retention_put_request: (required)
        :type api_v1_workspace_workspace_slug_audit_logs_retention_put_request: ApiV1WorkspaceWorkspaceSlugAuditLogsRetentionPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_slug',
            'api_v1_workspace_workspace_slug_audit_logs_retention_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_slug_audit_logs_retention_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_slug'] is not None:
            _path_params['workspaceSlug'] = _params['workspace_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_slug_audit_logs_retention_put_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_slug_audit_logs_retention_put_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceSlug}/audit-logs-retention', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v1_workspace_workspace_slug_version_limit_put(self, workspace_slug : StrictStr, api_v1_workspace_workspace_slug_version_limit_put_request : ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdNamePost200Response:  # noqa: E501
        """api_v1_workspace_workspace_slug_version_limit_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_slug_version_limit_put(workspace_slug, api_v1_workspace_workspace_slug_version_limit_put_request, async_req=True)
        >>> result = thread.get()

        :param workspace_slug: (required)
        :type workspace_slug: str
        :param api_v1_workspace_workspace_slug_version_limit_put_request: (required)
        :type api_v1_workspace_workspace_slug_version_limit_put_request: ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v1_workspace_workspace_slug_version_limit_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v1_workspace_workspace_slug_version_limit_put_with_http_info(workspace_slug, api_v1_workspace_workspace_slug_version_limit_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v1_workspace_workspace_slug_version_limit_put_with_http_info(self, workspace_slug : StrictStr, api_v1_workspace_workspace_slug_version_limit_put_request : ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v1_workspace_workspace_slug_version_limit_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v1_workspace_workspace_slug_version_limit_put_with_http_info(workspace_slug, api_v1_workspace_workspace_slug_version_limit_put_request, async_req=True)
        >>> result = thread.get()

        :param workspace_slug: (required)
        :type workspace_slug: str
        :param api_v1_workspace_workspace_slug_version_limit_put_request: (required)
        :type api_v1_workspace_workspace_slug_version_limit_put_request: ApiV1WorkspaceWorkspaceSlugVersionLimitPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_slug',
            'api_v1_workspace_workspace_slug_version_limit_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v1_workspace_workspace_slug_version_limit_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_slug'] is not None:
            _path_params['workspaceSlug'] = _params['workspace_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_slug_version_limit_put_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_slug_version_limit_put_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v1/workspace/{workspaceSlug}/version-limit', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_auth_mfa_send_post(self, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v2_auth_mfa_send_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_auth_mfa_send_post(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_auth_mfa_send_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_auth_mfa_send_post_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_auth_mfa_send_post_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_auth_mfa_send_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_auth_mfa_send_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_auth_mfa_send_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v2/auth/mfa/send', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_auth_mfa_verify_post(self, api_v2_auth_mfa_verify_post_request : ApiV2AuthMfaVerifyPostRequest, **kwargs) -> ApiV2AuthMfaVerifyPost200Response:  # noqa: E501
        """api_v2_auth_mfa_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_auth_mfa_verify_post(api_v2_auth_mfa_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_auth_mfa_verify_post_request: (required)
        :type api_v2_auth_mfa_verify_post_request: ApiV2AuthMfaVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2AuthMfaVerifyPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_auth_mfa_verify_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_auth_mfa_verify_post_with_http_info(api_v2_auth_mfa_verify_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_auth_mfa_verify_post_with_http_info(self, api_v2_auth_mfa_verify_post_request : ApiV2AuthMfaVerifyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_auth_mfa_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_auth_mfa_verify_post_with_http_info(api_v2_auth_mfa_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_auth_mfa_verify_post_request: (required)
        :type api_v2_auth_mfa_verify_post_request: ApiV2AuthMfaVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2AuthMfaVerifyPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_auth_mfa_verify_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_auth_mfa_verify_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_auth_mfa_verify_post_request'] is not None:
            _body_params = _params['api_v2_auth_mfa_verify_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2AuthMfaVerifyPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/auth/mfa/verify', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_org_id_identity_memberships_get(self, org_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get identity memberships from.")], **kwargs) -> ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response:  # noqa: E501
        """api_v2_organizations_org_id_identity_memberships_get  # noqa: E501

        Return organization identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_org_id_identity_memberships_get(org_id, async_req=True)
        >>> result = thread.get()

        :param org_id: The ID of the organization to get identity memberships from. (required)
        :type org_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_org_id_identity_memberships_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_org_id_identity_memberships_get_with_http_info(org_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_org_id_identity_memberships_get_with_http_info(self, org_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get identity memberships from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_org_id_identity_memberships_get  # noqa: E501

        Return organization identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_org_id_identity_memberships_get_with_http_info(org_id, async_req=True)
        >>> result = thread.get()

        :param org_id: The ID of the organization to get identity memberships from. (required)
        :type org_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'org_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_org_id_identity_memberships_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['org_id'] is not None:
            _path_params['orgId'] = _params['org_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrgIdIdentityMembershipsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{orgId}/identity-memberships', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_delete(self, organization_id : StrictStr, **kwargs) -> ApiV1OrganizationOrganizationIdGet200Response:  # noqa: E501
        """api_v2_organizations_organization_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_delete(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_delete_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_delete_with_http_info(self, organization_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_delete_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_get(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get memberships from.")], **kwargs) -> ApiV2OrganizationsOrganizationIdMembershipsGet200Response:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_get  # noqa: E501

        Return organization user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to get memberships from. (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrganizationIdMembershipsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_memberships_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_memberships_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_get_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get memberships from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_get  # noqa: E501

        Return organization user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to get memberships from. (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrganizationIdMembershipsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_memberships_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrganizationIdMembershipsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}/memberships', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_delete(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to delete the membership from.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to delete.")], **kwargs) -> ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_delete  # noqa: E501

        Delete organization user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_delete(organization_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to delete the membership from. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to delete. (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_memberships_membership_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_memberships_membership_id_delete_with_http_info(organization_id, membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_delete_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to delete the membership from.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_delete  # noqa: E501

        Delete organization user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_delete_with_http_info(organization_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to delete the membership from. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to delete. (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_memberships_membership_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['membership_id'] is not None:
            _path_params['membershipId'] = _params['membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}/memberships/{membershipId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_get(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get the membership for.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to get.")], **kwargs) -> ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_get  # noqa: E501

        Get organization user membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_get(organization_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to get the membership for. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to get. (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_memberships_membership_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_memberships_membership_id_get_with_http_info(organization_id, membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_get_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get the membership for.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to get.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_get  # noqa: E501

        Get organization user membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_get_with_http_info(organization_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to get the membership for. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to get. (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_memberships_membership_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['membership_id'] is not None:
            _path_params['membershipId'] = _params['membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrganizationIdMembershipsMembershipIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}/memberships/{membershipId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_patch(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to update the membership for.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to update.")], api_v2_organizations_organization_id_memberships_membership_id_patch_request : Optional[ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest] = None, **kwargs) -> ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_patch  # noqa: E501

        Update organization user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_patch(organization_id, membership_id, api_v2_organizations_organization_id_memberships_membership_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to update the membership for. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to update. (required)
        :type membership_id: str
        :param api_v2_organizations_organization_id_memberships_membership_id_patch_request:
        :type api_v2_organizations_organization_id_memberships_membership_id_patch_request: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_memberships_membership_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_memberships_membership_id_patch_with_http_info(organization_id, membership_id, api_v2_organizations_organization_id_memberships_membership_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_patch_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to update the membership for.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to update.")], api_v2_organizations_organization_id_memberships_membership_id_patch_request : Optional[ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_patch  # noqa: E501

        Update organization user memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_patch_with_http_info(organization_id, membership_id, api_v2_organizations_organization_id_memberships_membership_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to update the membership for. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to update. (required)
        :type membership_id: str
        :param api_v2_organizations_organization_id_memberships_membership_id_patch_request:
        :type api_v2_organizations_organization_id_memberships_membership_id_patch_request: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'membership_id',
            'api_v2_organizations_organization_id_memberships_membership_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_memberships_membership_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['membership_id'] is not None:
            _path_params['membershipId'] = _params['membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_organizations_organization_id_memberships_membership_id_patch_request'] is not None:
            _body_params = _params['api_v2_organizations_organization_id_memberships_membership_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrganizationIdMembershipsMembershipIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}/memberships/{membershipId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to delete the membership from.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to delete.")], **kwargs) -> ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get  # noqa: E501

        Get project memberships given organization membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get(organization_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to delete the membership from. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to delete. (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get_with_http_info(organization_id, membership_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to delete the membership from.")], membership_id : Annotated[StrictStr, Field(..., description="The ID of the membership to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get  # noqa: E501

        Get project memberships given organization membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get_with_http_info(organization_id, membership_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to delete the membership from. (required)
        :type organization_id: str
        :param membership_id: The ID of the membership to delete. (required)
        :type membership_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id',
            'membership_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_memberships_membership_id_project_memberships_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']

        if _params['membership_id'] is not None:
            _path_params['membershipId'] = _params['membership_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrganizationIdMembershipsMembershipIdProjectMembershipsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}/memberships/{membershipId}/project-memberships', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_organization_id_workspaces_get(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get projects from.")], **kwargs) -> ApiV2OrganizationsOrganizationIdWorkspacesGet200Response:  # noqa: E501
        """api_v2_organizations_organization_id_workspaces_get  # noqa: E501

        Return projects in organization that user is part of  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_workspaces_get(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to get projects from. (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2OrganizationsOrganizationIdWorkspacesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_organization_id_workspaces_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_organization_id_workspaces_get_with_http_info(organization_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_organization_id_workspaces_get_with_http_info(self, organization_id : Annotated[StrictStr, Field(..., description="The ID of the organization to get projects from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_organization_id_workspaces_get  # noqa: E501

        Return projects in organization that user is part of  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_organization_id_workspaces_get_with_http_info(organization_id, async_req=True)
        >>> result = thread.get()

        :param organization_id: The ID of the organization to get projects from. (required)
        :type organization_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2OrganizationsOrganizationIdWorkspacesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'organization_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_organization_id_workspaces_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['organization_id'] is not None:
            _path_params['organizationId'] = _params['organization_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2OrganizationsOrganizationIdWorkspacesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations/{organizationId}/workspaces', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_organizations_post(self, api_v1_workspace_workspace_id_name_post_request : ApiV1WorkspaceWorkspaceIdNamePostRequest, **kwargs) -> ApiV1OrganizationOrganizationIdGet200Response:  # noqa: E501
        """api_v2_organizations_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_post(api_v1_workspace_workspace_id_name_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_workspace_workspace_id_name_post_request: (required)
        :type api_v1_workspace_workspace_id_name_post_request: ApiV1WorkspaceWorkspaceIdNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationOrganizationIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_organizations_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_organizations_post_with_http_info(api_v1_workspace_workspace_id_name_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_organizations_post_with_http_info(self, api_v1_workspace_workspace_id_name_post_request : ApiV1WorkspaceWorkspaceIdNamePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_organizations_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_organizations_post_with_http_info(api_v1_workspace_workspace_id_name_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_workspace_workspace_id_name_post_request: (required)
        :type api_v1_workspace_workspace_id_name_post_request: ApiV1WorkspaceWorkspaceIdNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationOrganizationIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_workspace_workspace_id_name_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_organizations_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_workspace_workspace_id_name_post_request'] is not None:
            _body_params = _params['api_v1_workspace_workspace_id_name_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationOrganizationIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/organizations', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_service_token_get(self, **kwargs) -> ApiV2ServiceTokenGet200Response:  # noqa: E501
        """api_v2_service_token_get  # noqa: E501

        Return Infisical Token data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_service_token_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2ServiceTokenGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_service_token_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_service_token_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_service_token_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_service_token_get  # noqa: E501

        Return Infisical Token data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_service_token_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2ServiceTokenGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_service_token_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2ServiceTokenGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/service-token', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_service_token_post(self, api_v2_service_token_post_request : ApiV2ServiceTokenPostRequest, **kwargs) -> ApiV2ServiceTokenPost200Response:  # noqa: E501
        """api_v2_service_token_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_service_token_post(api_v2_service_token_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_service_token_post_request: (required)
        :type api_v2_service_token_post_request: ApiV2ServiceTokenPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2ServiceTokenPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_service_token_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_service_token_post_with_http_info(api_v2_service_token_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_service_token_post_with_http_info(self, api_v2_service_token_post_request : ApiV2ServiceTokenPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_service_token_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_service_token_post_with_http_info(api_v2_service_token_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_service_token_post_request: (required)
        :type api_v2_service_token_post_request: ApiV2ServiceTokenPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2ServiceTokenPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_service_token_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_service_token_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_service_token_post_request'] is not None:
            _body_params = _params['api_v2_service_token_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2ServiceTokenPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/service-token', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_service_token_service_token_id_delete(self, service_token_id : StrictStr, **kwargs) -> ApiV2ServiceTokenServiceTokenIdDelete200Response:  # noqa: E501
        """api_v2_service_token_service_token_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_service_token_service_token_id_delete(service_token_id, async_req=True)
        >>> result = thread.get()

        :param service_token_id: (required)
        :type service_token_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2ServiceTokenServiceTokenIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_service_token_service_token_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_service_token_service_token_id_delete_with_http_info(service_token_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_service_token_service_token_id_delete_with_http_info(self, service_token_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_service_token_service_token_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_service_token_service_token_id_delete_with_http_info(service_token_id, async_req=True)
        >>> result = thread.get()

        :param service_token_id: (required)
        :type service_token_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2ServiceTokenServiceTokenIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'service_token_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_service_token_service_token_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['service_token_id'] is not None:
            _path_params['serviceTokenId'] = _params['service_token_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2ServiceTokenServiceTokenIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v2/service-token/{serviceTokenId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_api_keys_api_key_data_id_delete(self, api_key_data_id : StrictStr, **kwargs) -> ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response:  # noqa: E501
        """api_v2_users_me_api_keys_api_key_data_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_api_keys_api_key_data_id_delete(api_key_data_id, async_req=True)
        >>> result = thread.get()

        :param api_key_data_id: (required)
        :type api_key_data_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_api_keys_api_key_data_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_api_keys_api_key_data_id_delete_with_http_info(api_key_data_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_api_keys_api_key_data_id_delete_with_http_info(self, api_key_data_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_api_keys_api_key_data_id_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_api_keys_api_key_data_id_delete_with_http_info(api_key_data_id, async_req=True)
        >>> result = thread.get()

        :param api_key_data_id: (required)
        :type api_key_data_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_key_data_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_api_keys_api_key_data_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['api_key_data_id'] is not None:
            _path_params['apiKeyDataId'] = _params['api_key_data_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2UsersMeApiKeysApiKeyDataIdDelete200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/api-keys/{apiKeyDataId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_api_keys_get(self, **kwargs) -> List[ApiV2UsersMeApiKeysGet200ResponseInner]:  # noqa: E501
        """api_v2_users_me_api_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_api_keys_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ApiV2UsersMeApiKeysGet200ResponseInner]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_api_keys_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_api_keys_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_api_keys_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_api_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_api_keys_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ApiV2UsersMeApiKeysGet200ResponseInner], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_api_keys_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[ApiV2UsersMeApiKeysGet200ResponseInner]",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/api-keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_api_keys_post(self, api_v2_users_me_api_keys_post_request : ApiV2UsersMeApiKeysPostRequest, **kwargs) -> ApiV2UsersMeApiKeysPost200Response:  # noqa: E501
        """api_v2_users_me_api_keys_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_api_keys_post(api_v2_users_me_api_keys_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_api_keys_post_request: (required)
        :type api_v2_users_me_api_keys_post_request: ApiV2UsersMeApiKeysPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2UsersMeApiKeysPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_api_keys_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_api_keys_post_with_http_info(api_v2_users_me_api_keys_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_api_keys_post_with_http_info(self, api_v2_users_me_api_keys_post_request : ApiV2UsersMeApiKeysPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_api_keys_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_api_keys_post_with_http_info(api_v2_users_me_api_keys_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_api_keys_post_request: (required)
        :type api_v2_users_me_api_keys_post_request: ApiV2UsersMeApiKeysPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2UsersMeApiKeysPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_users_me_api_keys_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_api_keys_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_users_me_api_keys_post_request'] is not None:
            _body_params = _params['api_v2_users_me_api_keys_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2UsersMeApiKeysPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/api-keys', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_auth_methods_put(self, api_v2_users_me_auth_methods_put_request : ApiV2UsersMeAuthMethodsPutRequest, **kwargs) -> ApiV2UsersMeMfaPatch200Response:  # noqa: E501
        """api_v2_users_me_auth_methods_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_auth_methods_put(api_v2_users_me_auth_methods_put_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_auth_methods_put_request: (required)
        :type api_v2_users_me_auth_methods_put_request: ApiV2UsersMeAuthMethodsPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2UsersMeMfaPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_auth_methods_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_auth_methods_put_with_http_info(api_v2_users_me_auth_methods_put_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_auth_methods_put_with_http_info(self, api_v2_users_me_auth_methods_put_request : ApiV2UsersMeAuthMethodsPutRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_auth_methods_put  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_auth_methods_put_with_http_info(api_v2_users_me_auth_methods_put_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_auth_methods_put_request: (required)
        :type api_v2_users_me_auth_methods_put_request: ApiV2UsersMeAuthMethodsPutRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2UsersMeMfaPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_users_me_auth_methods_put_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_auth_methods_put" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_users_me_auth_methods_put_request'] is not None:
            _body_params = _params['api_v2_users_me_auth_methods_put_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2UsersMeMfaPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/auth-methods', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_delete(self, **kwargs) -> ApiV2UsersMeMfaPatch200Response:  # noqa: E501
        """api_v2_users_me_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_delete(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2UsersMeMfaPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_delete_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_delete_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2UsersMeMfaPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2UsersMeMfaPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_emails_code_post(self, api_v2_users_me_emails_code_post_request : ApiV2UsersMeEmailsCodePostRequest, **kwargs) -> object:  # noqa: E501
        """api_v2_users_me_emails_code_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_emails_code_post(api_v2_users_me_emails_code_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_emails_code_post_request: (required)
        :type api_v2_users_me_emails_code_post_request: ApiV2UsersMeEmailsCodePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_emails_code_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_emails_code_post_with_http_info(api_v2_users_me_emails_code_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_emails_code_post_with_http_info(self, api_v2_users_me_emails_code_post_request : ApiV2UsersMeEmailsCodePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_emails_code_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_emails_code_post_with_http_info(api_v2_users_me_emails_code_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_emails_code_post_request: (required)
        :type api_v2_users_me_emails_code_post_request: ApiV2UsersMeEmailsCodePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_users_me_emails_code_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_emails_code_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_users_me_emails_code_post_request'] is not None:
            _body_params = _params['api_v2_users_me_emails_code_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/emails/code', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_emails_verify_post(self, api_v2_users_me_emails_verify_post_request : ApiV2UsersMeEmailsVerifyPostRequest, **kwargs) -> object:  # noqa: E501
        """api_v2_users_me_emails_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_emails_verify_post(api_v2_users_me_emails_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_emails_verify_post_request: (required)
        :type api_v2_users_me_emails_verify_post_request: ApiV2UsersMeEmailsVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_emails_verify_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_emails_verify_post_with_http_info(api_v2_users_me_emails_verify_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_emails_verify_post_with_http_info(self, api_v2_users_me_emails_verify_post_request : ApiV2UsersMeEmailsVerifyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_emails_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_emails_verify_post_with_http_info(api_v2_users_me_emails_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_emails_verify_post_request: (required)
        :type api_v2_users_me_emails_verify_post_request: ApiV2UsersMeEmailsVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_users_me_emails_verify_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_emails_verify_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_users_me_emails_verify_post_request'] is not None:
            _body_params = _params['api_v2_users_me_emails_verify_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/emails/verify', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_get(self, **kwargs) -> ApiV1UserGet200Response:  # noqa: E501
        """api_v2_users_me_get  # noqa: E501

        Retrieve the current user on the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1UserGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_get  # noqa: E501

        Retrieve the current user on the request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1UserGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1UserGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_mfa_patch(self, api_v2_users_me_mfa_patch_request : ApiV2UsersMeMfaPatchRequest, **kwargs) -> ApiV2UsersMeMfaPatch200Response:  # noqa: E501
        """api_v2_users_me_mfa_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_mfa_patch(api_v2_users_me_mfa_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_mfa_patch_request: (required)
        :type api_v2_users_me_mfa_patch_request: ApiV2UsersMeMfaPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2UsersMeMfaPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_mfa_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_mfa_patch_with_http_info(api_v2_users_me_mfa_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_mfa_patch_with_http_info(self, api_v2_users_me_mfa_patch_request : ApiV2UsersMeMfaPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_mfa_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_mfa_patch_with_http_info(api_v2_users_me_mfa_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_mfa_patch_request: (required)
        :type api_v2_users_me_mfa_patch_request: ApiV2UsersMeMfaPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2UsersMeMfaPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_users_me_mfa_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_mfa_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_users_me_mfa_patch_request'] is not None:
            _body_params = _params['api_v2_users_me_mfa_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2UsersMeMfaPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/mfa', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_name_patch(self, api_v2_users_me_name_patch_request : ApiV2UsersMeNamePatchRequest, **kwargs) -> ApiV2UsersMeMfaPatch200Response:  # noqa: E501
        """api_v2_users_me_name_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_name_patch(api_v2_users_me_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_name_patch_request: (required)
        :type api_v2_users_me_name_patch_request: ApiV2UsersMeNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2UsersMeMfaPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_name_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_name_patch_with_http_info(api_v2_users_me_name_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_name_patch_with_http_info(self, api_v2_users_me_name_patch_request : ApiV2UsersMeNamePatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_name_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_name_patch_with_http_info(api_v2_users_me_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_users_me_name_patch_request: (required)
        :type api_v2_users_me_name_patch_request: ApiV2UsersMeNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2UsersMeMfaPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_users_me_name_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_name_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_users_me_name_patch_request'] is not None:
            _body_params = _params['api_v2_users_me_name_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2UsersMeMfaPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/name', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_organizations_get(self, **kwargs) -> ApiV1OrganizationGet200Response:  # noqa: E501
        """api_v2_users_me_organizations_get  # noqa: E501

        Return organizations that current user is part of  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_organizations_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_organizations_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_organizations_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_organizations_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_organizations_get  # noqa: E501

        Return organizations that current user is part of  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_organizations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_organizations_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/organizations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_sessions_delete(self, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v2_users_me_sessions_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_sessions_delete(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_sessions_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_sessions_delete_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_sessions_delete_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_sessions_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_sessions_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_sessions_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/sessions', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_users_me_sessions_get(self, **kwargs) -> List[ApiV2UsersMeSessionsGet200ResponseInner]:  # noqa: E501
        """api_v2_users_me_sessions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_sessions_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ApiV2UsersMeSessionsGet200ResponseInner]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_users_me_sessions_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_users_me_sessions_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_users_me_sessions_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_users_me_sessions_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_users_me_sessions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ApiV2UsersMeSessionsGet200ResponseInner], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_users_me_sessions_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[ApiV2UsersMeSessionsGet200ResponseInner]",
        }

        return self.api_client.call_api(
            '/api/v2/users/me/sessions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_post(self, api_v2_workspace_post_request : ApiV2WorkspacePostRequest, **kwargs) -> ApiV2WorkspacePost200Response:  # noqa: E501
        """api_v2_workspace_post  # noqa: E501

        Create a new project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_post(api_v2_workspace_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_workspace_post_request: (required)
        :type api_v2_workspace_post_request: ApiV2WorkspacePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspacePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_post_with_http_info(api_v2_workspace_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_post_with_http_info(self, api_v2_workspace_post_request : ApiV2WorkspacePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_post  # noqa: E501

        Create a new project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_post_with_http_info(api_v2_workspace_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v2_workspace_post_request: (required)
        :type api_v2_workspace_post_request: ApiV2WorkspacePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspacePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v2_workspace_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_post_request'] is not None:
            _body_params = _params['api_v2_workspace_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspacePost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_get(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get identity memberships from.")], **kwargs) -> ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_get  # noqa: E501

        Return project identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get identity memberships from. (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_identity_memberships_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_identity_memberships_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_get_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get identity memberships from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_get  # noqa: E501

        Return project identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get identity memberships from. (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_identity_memberships_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1IdentitiesIdentityIdIdentityMembershipsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/identity-memberships', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_delete(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the identity membership from.")], identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to delete the membership from.")], **kwargs) -> ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_delete  # noqa: E501

        Delete project identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_delete(project_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to delete the identity membership from. (required)
        :type project_id: str
        :param identity_id: The ID of the identity to delete the membership from. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_identity_memberships_identity_id_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_identity_memberships_identity_id_delete_with_http_info(project_id, identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_delete_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to delete the identity membership from.")], identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to delete the membership from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_delete  # noqa: E501

        Delete project identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_delete_with_http_info(project_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to delete the identity membership from. (required)
        :type project_id: str
        :param identity_id: The ID of the identity to delete the membership from. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_identity_memberships_identity_id_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/identity-memberships/{identityId}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_get(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get the identity membership for.")], identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get the membership for.")], **kwargs) -> ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_get  # noqa: E501

        Return project identity membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_get(project_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get the identity membership for. (required)
        :type project_id: str
        :param identity_id: The ID of the identity to get the membership for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_identity_memberships_identity_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_identity_memberships_identity_id_get_with_http_info(project_id, identity_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_get_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to get the identity membership for.")], identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to get the membership for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_get  # noqa: E501

        Return project identity membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_get_with_http_info(project_id, identity_id, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to get the identity membership for. (required)
        :type project_id: str
        :param identity_id: The ID of the identity to get the membership for. (required)
        :type identity_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'identity_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_identity_memberships_identity_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/identity-memberships/{identityId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_patch(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the identity membership for.")], identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the membership for.")], api_v2_workspace_project_id_identity_memberships_identity_id_patch_request : ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_patch  # noqa: E501

        Update project identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_patch(project_id, identity_id, api_v2_workspace_project_id_identity_memberships_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to update the identity membership for. (required)
        :type project_id: str
        :param identity_id: The ID of the identity to update the membership for. (required)
        :type identity_id: str
        :param api_v2_workspace_project_id_identity_memberships_identity_id_patch_request: (required)
        :type api_v2_workspace_project_id_identity_memberships_identity_id_patch_request: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_identity_memberships_identity_id_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_identity_memberships_identity_id_patch_with_http_info(project_id, identity_id, api_v2_workspace_project_id_identity_memberships_identity_id_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_patch_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to update the identity membership for.")], identity_id : Annotated[StrictStr, Field(..., description="The ID of the identity to update the membership for.")], api_v2_workspace_project_id_identity_memberships_identity_id_patch_request : ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_patch  # noqa: E501

        Update project identity memberships  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_patch_with_http_info(project_id, identity_id, api_v2_workspace_project_id_identity_memberships_identity_id_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to update the identity membership for. (required)
        :type project_id: str
        :param identity_id: The ID of the identity to update the membership for. (required)
        :type identity_id: str
        :param api_v2_workspace_project_id_identity_memberships_identity_id_patch_request: (required)
        :type api_v2_workspace_project_id_identity_memberships_identity_id_patch_request: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'identity_id',
            'api_v2_workspace_project_id_identity_memberships_identity_id_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_identity_memberships_identity_id_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_id_identity_memberships_identity_id_patch_request'] is not None:
            _body_params = _params['api_v2_workspace_project_id_identity_memberships_identity_id_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/identity-memberships/{identityId}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_post(self, project_id : StrictStr, identity_id : StrictStr, api_v2_workspace_project_id_identity_memberships_identity_id_post_request : Optional[ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest] = None, **kwargs) -> ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_post  # noqa: E501

        Create project identity membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_post(project_id, identity_id, api_v2_workspace_project_id_identity_memberships_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param identity_id: (required)
        :type identity_id: str
        :param api_v2_workspace_project_id_identity_memberships_identity_id_post_request:
        :type api_v2_workspace_project_id_identity_memberships_identity_id_post_request: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_identity_memberships_identity_id_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_identity_memberships_identity_id_post_with_http_info(project_id, identity_id, api_v2_workspace_project_id_identity_memberships_identity_id_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_identity_memberships_identity_id_post_with_http_info(self, project_id : StrictStr, identity_id : StrictStr, api_v2_workspace_project_id_identity_memberships_identity_id_post_request : Optional[ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_identity_memberships_identity_id_post  # noqa: E501

        Create project identity membership  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_identity_memberships_identity_id_post_with_http_info(project_id, identity_id, api_v2_workspace_project_id_identity_memberships_identity_id_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param identity_id: (required)
        :type identity_id: str
        :param api_v2_workspace_project_id_identity_memberships_identity_id_post_request:
        :type api_v2_workspace_project_id_identity_memberships_identity_id_post_request: ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'identity_id',
            'api_v2_workspace_project_id_identity_memberships_identity_id_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_identity_memberships_identity_id_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']

        if _params['identity_id'] is not None:
            _path_params['identityId'] = _params['identity_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_id_identity_memberships_identity_id_post_request'] is not None:
            _body_params = _params['api_v2_workspace_project_id_identity_memberships_identity_id_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectIdIdentityMembershipsIdentityIdPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/identity-memberships/{identityId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_memberships_delete(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to remove the member from.")], api_v2_workspace_project_id_memberships_delete_request : Optional[ApiV2WorkspaceProjectIdMembershipsDeleteRequest] = None, **kwargs) -> ApiV2WorkspaceProjectIdMembershipsPost200Response:  # noqa: E501
        """api_v2_workspace_project_id_memberships_delete  # noqa: E501

        Remove members from project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_memberships_delete(project_id, api_v2_workspace_project_id_memberships_delete_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to remove the member from. (required)
        :type project_id: str
        :param api_v2_workspace_project_id_memberships_delete_request:
        :type api_v2_workspace_project_id_memberships_delete_request: ApiV2WorkspaceProjectIdMembershipsDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectIdMembershipsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_memberships_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_memberships_delete_with_http_info(project_id, api_v2_workspace_project_id_memberships_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_memberships_delete_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to remove the member from.")], api_v2_workspace_project_id_memberships_delete_request : Optional[ApiV2WorkspaceProjectIdMembershipsDeleteRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_memberships_delete  # noqa: E501

        Remove members from project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_memberships_delete_with_http_info(project_id, api_v2_workspace_project_id_memberships_delete_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to remove the member from. (required)
        :type project_id: str
        :param api_v2_workspace_project_id_memberships_delete_request:
        :type api_v2_workspace_project_id_memberships_delete_request: ApiV2WorkspaceProjectIdMembershipsDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectIdMembershipsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'api_v2_workspace_project_id_memberships_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_memberships_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_id_memberships_delete_request'] is not None:
            _body_params = _params['api_v2_workspace_project_id_memberships_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectIdMembershipsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/memberships', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_memberships_post(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to invite the member to.")], api_v2_workspace_project_id_memberships_post_request : Optional[ApiV2WorkspaceProjectIdMembershipsPostRequest] = None, **kwargs) -> ApiV2WorkspaceProjectIdMembershipsPost200Response:  # noqa: E501
        """api_v2_workspace_project_id_memberships_post  # noqa: E501

        Invite members to project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_memberships_post(project_id, api_v2_workspace_project_id_memberships_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to invite the member to. (required)
        :type project_id: str
        :param api_v2_workspace_project_id_memberships_post_request:
        :type api_v2_workspace_project_id_memberships_post_request: ApiV2WorkspaceProjectIdMembershipsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectIdMembershipsPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_memberships_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_memberships_post_with_http_info(project_id, api_v2_workspace_project_id_memberships_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_memberships_post_with_http_info(self, project_id : Annotated[StrictStr, Field(..., description="The ID of the project to invite the member to.")], api_v2_workspace_project_id_memberships_post_request : Optional[ApiV2WorkspaceProjectIdMembershipsPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_memberships_post  # noqa: E501

        Invite members to project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_memberships_post_with_http_info(project_id, api_v2_workspace_project_id_memberships_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: The ID of the project to invite the member to. (required)
        :type project_id: str
        :param api_v2_workspace_project_id_memberships_post_request:
        :type api_v2_workspace_project_id_memberships_post_request: ApiV2WorkspaceProjectIdMembershipsPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectIdMembershipsPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'api_v2_workspace_project_id_memberships_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_memberships_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_id_memberships_post_request'] is not None:
            _body_params = _params['api_v2_workspace_project_id_memberships_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectIdMembershipsPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/memberships', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_upgrade_post(self, project_id : StrictStr, api_v2_workspace_project_id_upgrade_post_request : ApiV2WorkspaceProjectIdUpgradePostRequest, **kwargs) -> object:  # noqa: E501
        """api_v2_workspace_project_id_upgrade_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_upgrade_post(project_id, api_v2_workspace_project_id_upgrade_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param api_v2_workspace_project_id_upgrade_post_request: (required)
        :type api_v2_workspace_project_id_upgrade_post_request: ApiV2WorkspaceProjectIdUpgradePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_upgrade_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_upgrade_post_with_http_info(project_id, api_v2_workspace_project_id_upgrade_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_upgrade_post_with_http_info(self, project_id : StrictStr, api_v2_workspace_project_id_upgrade_post_request : ApiV2WorkspaceProjectIdUpgradePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_upgrade_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_upgrade_post_with_http_info(project_id, api_v2_workspace_project_id_upgrade_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param api_v2_workspace_project_id_upgrade_post_request: (required)
        :type api_v2_workspace_project_id_upgrade_post_request: ApiV2WorkspaceProjectIdUpgradePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'api_v2_workspace_project_id_upgrade_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_upgrade_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_id_upgrade_post_request'] is not None:
            _body_params = _params['api_v2_workspace_project_id_upgrade_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/upgrade', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_id_upgrade_status_get(self, project_id : StrictStr, **kwargs) -> ApiV2WorkspaceProjectIdUpgradeStatusGet200Response:  # noqa: E501
        """api_v2_workspace_project_id_upgrade_status_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_upgrade_status_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectIdUpgradeStatusGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_id_upgrade_status_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_id_upgrade_status_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_id_upgrade_status_get_with_http_info(self, project_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_id_upgrade_status_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_id_upgrade_status_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectIdUpgradeStatusGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_id_upgrade_status_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectIdUpgradeStatusGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectId}/upgrade/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_slug_groups_get(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to list groups for.")], **kwargs) -> ApiV2WorkspaceProjectSlugGroupsGet200Response:  # noqa: E501
        """api_v2_workspace_project_slug_groups_get  # noqa: E501

        Return list of groups in project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_get(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to list groups for. (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectSlugGroupsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_slug_groups_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_slug_groups_get_with_http_info(project_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_slug_groups_get_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to list groups for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_slug_groups_get  # noqa: E501

        Return list of groups in project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_get_with_http_info(project_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to list groups for. (required)
        :type project_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectSlugGroupsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_slug_groups_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectSlugGroupsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectSlug}/groups', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_slug_groups_group_slug_delete(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to delete the group from.")], group_slug : Annotated[StrictStr, Field(..., description="The slug of the group to delete from the project.")], **kwargs) -> ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response:  # noqa: E501
        """api_v2_workspace_project_slug_groups_group_slug_delete  # noqa: E501

        Remove group from project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_group_slug_delete(project_slug, group_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to delete the group from. (required)
        :type project_slug: str
        :param group_slug: The slug of the group to delete from the project. (required)
        :type group_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_slug_groups_group_slug_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_slug_groups_group_slug_delete_with_http_info(project_slug, group_slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_slug_groups_group_slug_delete_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to delete the group from.")], group_slug : Annotated[StrictStr, Field(..., description="The slug of the group to delete from the project.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_slug_groups_group_slug_delete  # noqa: E501

        Remove group from project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_group_slug_delete_with_http_info(project_slug, group_slug, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to delete the group from. (required)
        :type project_slug: str
        :param group_slug: The slug of the group to delete from the project. (required)
        :type group_slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'group_slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_slug_groups_group_slug_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']

        if _params['group_slug'] is not None:
            _path_params['groupSlug'] = _params['group_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectSlug}/groups/{groupSlug}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_slug_groups_group_slug_patch(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to update the group in.")], group_slug : Annotated[StrictStr, Field(..., description="The slug of the group to update in the project.")], api_v2_workspace_project_slug_groups_group_slug_patch_request : ApiV2WorkspaceProjectSlugGroupsGroupSlugPatchRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response:  # noqa: E501
        """api_v2_workspace_project_slug_groups_group_slug_patch  # noqa: E501

        Update group in project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_group_slug_patch(project_slug, group_slug, api_v2_workspace_project_slug_groups_group_slug_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to update the group in. (required)
        :type project_slug: str
        :param group_slug: The slug of the group to update in the project. (required)
        :type group_slug: str
        :param api_v2_workspace_project_slug_groups_group_slug_patch_request: (required)
        :type api_v2_workspace_project_slug_groups_group_slug_patch_request: ApiV2WorkspaceProjectSlugGroupsGroupSlugPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_slug_groups_group_slug_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_slug_groups_group_slug_patch_with_http_info(project_slug, group_slug, api_v2_workspace_project_slug_groups_group_slug_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_slug_groups_group_slug_patch_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to update the group in.")], group_slug : Annotated[StrictStr, Field(..., description="The slug of the group to update in the project.")], api_v2_workspace_project_slug_groups_group_slug_patch_request : ApiV2WorkspaceProjectSlugGroupsGroupSlugPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_slug_groups_group_slug_patch  # noqa: E501

        Update group in project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_group_slug_patch_with_http_info(project_slug, group_slug, api_v2_workspace_project_slug_groups_group_slug_patch_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to update the group in. (required)
        :type project_slug: str
        :param group_slug: The slug of the group to update in the project. (required)
        :type group_slug: str
        :param api_v2_workspace_project_slug_groups_group_slug_patch_request: (required)
        :type api_v2_workspace_project_slug_groups_group_slug_patch_request: ApiV2WorkspaceProjectSlugGroupsGroupSlugPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'group_slug',
            'api_v2_workspace_project_slug_groups_group_slug_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_slug_groups_group_slug_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']

        if _params['group_slug'] is not None:
            _path_params['groupSlug'] = _params['group_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_slug_groups_group_slug_patch_request'] is not None:
            _body_params = _params['api_v2_workspace_project_slug_groups_group_slug_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMembershipsMembershipIdPatch200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectSlug}/groups/{groupSlug}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_project_slug_groups_group_slug_post(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to add the group to.")], group_slug : Annotated[StrictStr, Field(..., description="The slug of the group to add to the project.")], api_v2_workspace_project_slug_groups_group_slug_post_request : Optional[ApiV2WorkspaceProjectSlugGroupsGroupSlugPostRequest] = None, **kwargs) -> ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response:  # noqa: E501
        """api_v2_workspace_project_slug_groups_group_slug_post  # noqa: E501

        Add group to project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_group_slug_post(project_slug, group_slug, api_v2_workspace_project_slug_groups_group_slug_post_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to add the group to. (required)
        :type project_slug: str
        :param group_slug: The slug of the group to add to the project. (required)
        :type group_slug: str
        :param api_v2_workspace_project_slug_groups_group_slug_post_request:
        :type api_v2_workspace_project_slug_groups_group_slug_post_request: ApiV2WorkspaceProjectSlugGroupsGroupSlugPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_project_slug_groups_group_slug_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_project_slug_groups_group_slug_post_with_http_info(project_slug, group_slug, api_v2_workspace_project_slug_groups_group_slug_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_project_slug_groups_group_slug_post_with_http_info(self, project_slug : Annotated[StrictStr, Field(..., description="The slug of the project to add the group to.")], group_slug : Annotated[StrictStr, Field(..., description="The slug of the group to add to the project.")], api_v2_workspace_project_slug_groups_group_slug_post_request : Optional[ApiV2WorkspaceProjectSlugGroupsGroupSlugPostRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_project_slug_groups_group_slug_post  # noqa: E501

        Add group to project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_project_slug_groups_group_slug_post_with_http_info(project_slug, group_slug, api_v2_workspace_project_slug_groups_group_slug_post_request, async_req=True)
        >>> result = thread.get()

        :param project_slug: The slug of the project to add the group to. (required)
        :type project_slug: str
        :param group_slug: The slug of the group to add to the project. (required)
        :type group_slug: str
        :param api_v2_workspace_project_slug_groups_group_slug_post_request:
        :type api_v2_workspace_project_slug_groups_group_slug_post_request: ApiV2WorkspaceProjectSlugGroupsGroupSlugPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_slug',
            'group_slug',
            'api_v2_workspace_project_slug_groups_group_slug_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_project_slug_groups_group_slug_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_slug'] is not None:
            _path_params['projectSlug'] = _params['project_slug']

        if _params['group_slug'] is not None:
            _path_params['groupSlug'] = _params['group_slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_project_slug_groups_group_slug_post_request'] is not None:
            _body_params = _params['api_v2_workspace_project_slug_groups_group_slug_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceProjectSlugGroupsGroupSlugPost200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{projectSlug}/groups/{groupSlug}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_slug_cas_get(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to list CAs for.")], status : Annotated[Optional[StrictStr], Field(description="The status of the CA to filter by.")] = None, friendly_name : Annotated[Optional[StrictStr], Field(description="The friendly name of the CA to filter by.")] = None, common_name : Annotated[Optional[StrictStr], Field(description="The common name of the CA to filter by.")] = None, offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th CA.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of CAs to return.")] = None, **kwargs) -> ApiV2WorkspaceSlugCasGet200Response:  # noqa: E501
        """api_v2_workspace_slug_cas_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_cas_get(slug, status, friendly_name, common_name, offset, limit, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to list CAs for. (required)
        :type slug: str
        :param status: The status of the CA to filter by.
        :type status: str
        :param friendly_name: The friendly name of the CA to filter by.
        :type friendly_name: str
        :param common_name: The common name of the CA to filter by.
        :type common_name: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th CA.
        :type offset: float
        :param limit: The number of CAs to return.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceSlugCasGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_slug_cas_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_slug_cas_get_with_http_info(slug, status, friendly_name, common_name, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_slug_cas_get_with_http_info(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to list CAs for.")], status : Annotated[Optional[StrictStr], Field(description="The status of the CA to filter by.")] = None, friendly_name : Annotated[Optional[StrictStr], Field(description="The friendly name of the CA to filter by.")] = None, common_name : Annotated[Optional[StrictStr], Field(description="The common name of the CA to filter by.")] = None, offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th CA.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of CAs to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_slug_cas_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_cas_get_with_http_info(slug, status, friendly_name, common_name, offset, limit, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to list CAs for. (required)
        :type slug: str
        :param status: The status of the CA to filter by.
        :type status: str
        :param friendly_name: The friendly name of the CA to filter by.
        :type friendly_name: str
        :param common_name: The common name of the CA to filter by.
        :type common_name: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th CA.
        :type offset: float
        :param limit: The number of CAs to return.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceSlugCasGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'status',
            'friendly_name',
            'common_name',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_slug_cas_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('friendly_name') is not None:  # noqa: E501
            _query_params.append(('friendlyName', _params['friendly_name']))

        if _params.get('common_name') is not None:  # noqa: E501
            _query_params.append(('commonName', _params['common_name']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceSlugCasGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{slug}/cas', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_slug_certificates_get(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to list certificates for.")], friendly_name : Annotated[Optional[StrictStr], Field(description="The friendly name of the certificate to filter by.")] = None, common_name : Annotated[Optional[StrictStr], Field(description="The common name of the certificate to filter by.")] = None, offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th certificate.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of certificates to return.")] = None, **kwargs) -> ApiV2WorkspaceSlugCertificatesGet200Response:  # noqa: E501
        """api_v2_workspace_slug_certificates_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_certificates_get(slug, friendly_name, common_name, offset, limit, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to list certificates for. (required)
        :type slug: str
        :param friendly_name: The friendly name of the certificate to filter by.
        :type friendly_name: str
        :param common_name: The common name of the certificate to filter by.
        :type common_name: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th certificate.
        :type offset: float
        :param limit: The number of certificates to return.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceSlugCertificatesGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_slug_certificates_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_slug_certificates_get_with_http_info(slug, friendly_name, common_name, offset, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_slug_certificates_get_with_http_info(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to list certificates for.")], friendly_name : Annotated[Optional[StrictStr], Field(description="The friendly name of the certificate to filter by.")] = None, common_name : Annotated[Optional[StrictStr], Field(description="The common name of the certificate to filter by.")] = None, offset : Annotated[Optional[Union[confloat(le=100, ge=0, strict=True), conint(le=100.0, ge=0.0, strict=True)]], Field(description="The offset to start from. If you enter 10, it will start from the 10th certificate.")] = None, limit : Annotated[Optional[Union[confloat(le=100, ge=1, strict=True), conint(le=100.0, ge=1.0, strict=True)]], Field(description="The number of certificates to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_slug_certificates_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_certificates_get_with_http_info(slug, friendly_name, common_name, offset, limit, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to list certificates for. (required)
        :type slug: str
        :param friendly_name: The friendly name of the certificate to filter by.
        :type friendly_name: str
        :param common_name: The common name of the certificate to filter by.
        :type common_name: str
        :param offset: The offset to start from. If you enter 10, it will start from the 10th certificate.
        :type offset: float
        :param limit: The number of certificates to return.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceSlugCertificatesGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'friendly_name',
            'common_name',
            'offset',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_slug_certificates_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        if _params.get('friendly_name') is not None:  # noqa: E501
            _query_params.append(('friendlyName', _params['friendly_name']))

        if _params.get('common_name') is not None:  # noqa: E501
            _query_params.append(('commonName', _params['common_name']))

        if _params.get('offset') is not None:  # noqa: E501
            _query_params.append(('offset', _params['offset']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceSlugCertificatesGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{slug}/certificates', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_slug_delete(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to delete.")], **kwargs) -> ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner:  # noqa: E501
        """api_v2_workspace_slug_delete  # noqa: E501

        Delete project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_delete(slug, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to delete. (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_slug_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_slug_delete_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_slug_delete_with_http_info(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to delete.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_slug_delete  # noqa: E501

        Delete project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_delete_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to delete. (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_slug_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{slug}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_slug_get(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to get.")], **kwargs) -> ApiV1WorkspaceGet200ResponseWorkspacesInner:  # noqa: E501
        """api_v2_workspace_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_get(slug, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to get. (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceGet200ResponseWorkspacesInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_slug_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_slug_get_with_http_info(slug, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_slug_get_with_http_info(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to get.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_slug_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_get_with_http_info(slug, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to get. (required)
        :type slug: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceGet200ResponseWorkspacesInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_slug_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceGet200ResponseWorkspacesInner",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{slug}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_slug_patch(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to update.")], api_v2_workspace_slug_patch_request : Optional[ApiV2WorkspaceSlugPatchRequest] = None, **kwargs) -> ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner:  # noqa: E501
        """api_v2_workspace_slug_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_patch(slug, api_v2_workspace_slug_patch_request, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to update. (required)
        :type slug: str
        :param api_v2_workspace_slug_patch_request:
        :type api_v2_workspace_slug_patch_request: ApiV2WorkspaceSlugPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_slug_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_slug_patch_with_http_info(slug, api_v2_workspace_slug_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_slug_patch_with_http_info(self, slug : Annotated[constr(strict=True, max_length=36, min_length=5), Field(..., description="The slug of the project to update.")], api_v2_workspace_slug_patch_request : Optional[ApiV2WorkspaceSlugPatchRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_slug_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_slug_patch_with_http_info(slug, api_v2_workspace_slug_patch_request, async_req=True)
        >>> result = thread.get()

        :param slug: The slug of the project to update. (required)
        :type slug: str
        :param api_v2_workspace_slug_patch_request:
        :type api_v2_workspace_slug_patch_request: ApiV2WorkspaceSlugPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'slug',
            'api_v2_workspace_slug_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_slug_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['slug'] is not None:
            _path_params['slug'] = _params['slug']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v2_workspace_slug_patch_request'] is not None:
            _body_params = _params['api_v2_workspace_slug_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1OrganizationAdminProjectsGet200ResponseProjectsInner",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{slug}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v2_workspace_workspace_id_encrypted_key_get(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to get the key from.")], **kwargs) -> ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response:  # noqa: E501
        """api_v2_workspace_workspace_id_encrypted_key_get  # noqa: E501

        Return encrypted project key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_workspace_id_encrypted_key_get(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to get the key from. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v2_workspace_workspace_id_encrypted_key_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v2_workspace_workspace_id_encrypted_key_get_with_http_info(workspace_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v2_workspace_workspace_id_encrypted_key_get_with_http_info(self, workspace_id : Annotated[StrictStr, Field(..., description="The ID of the project to get the key from.")], **kwargs) -> ApiResponse:  # noqa: E501
        """api_v2_workspace_workspace_id_encrypted_key_get  # noqa: E501

        Return encrypted project key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v2_workspace_workspace_id_encrypted_key_get_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to get the key from. (required)
        :type workspace_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v2_workspace_workspace_id_encrypted_key_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['workspace_id'] is not None:
            _path_params['workspaceId'] = _params['workspace_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV2WorkspaceWorkspaceIdEncryptedKeyGet200Response",
        }

        return self.api_client.call_api(
            '/api/v2/workspace/{workspaceId}/encrypted-key', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_auth_login1_post(self, api_v3_auth_login1_post_request : ApiV3AuthLogin1PostRequest, **kwargs) -> ApiV1PasswordSrp1Post200Response:  # noqa: E501
        """api_v3_auth_login1_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_auth_login1_post(api_v3_auth_login1_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_auth_login1_post_request: (required)
        :type api_v3_auth_login1_post_request: ApiV3AuthLogin1PostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PasswordSrp1Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_auth_login1_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_auth_login1_post_with_http_info(api_v3_auth_login1_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_auth_login1_post_with_http_info(self, api_v3_auth_login1_post_request : ApiV3AuthLogin1PostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_auth_login1_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_auth_login1_post_with_http_info(api_v3_auth_login1_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_auth_login1_post_request: (required)
        :type api_v3_auth_login1_post_request: ApiV3AuthLogin1PostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PasswordSrp1Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_auth_login1_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_auth_login1_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_auth_login1_post_request'] is not None:
            _body_params = _params['api_v3_auth_login1_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PasswordSrp1Post200Response",
        }

        return self.api_client.call_api(
            '/api/v3/auth/login1', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_auth_login2_post(self, api_v3_auth_login2_post_request : ApiV3AuthLogin2PostRequest, **kwargs) -> ApiV3AuthLogin2Post200Response:  # noqa: E501
        """api_v3_auth_login2_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_auth_login2_post(api_v3_auth_login2_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_auth_login2_post_request: (required)
        :type api_v3_auth_login2_post_request: ApiV3AuthLogin2PostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3AuthLogin2Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_auth_login2_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_auth_login2_post_with_http_info(api_v3_auth_login2_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_auth_login2_post_with_http_info(self, api_v3_auth_login2_post_request : ApiV3AuthLogin2PostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_auth_login2_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_auth_login2_post_with_http_info(api_v3_auth_login2_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_auth_login2_post_request: (required)
        :type api_v3_auth_login2_post_request: ApiV3AuthLogin2PostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3AuthLogin2Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_auth_login2_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_auth_login2_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_auth_login2_post_request'] is not None:
            _body_params = _params['api_v3_auth_login2_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3AuthLogin2Post200Response",
        }

        return self.api_client.call_api(
            '/api/v3/auth/login2', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_auth_select_organization_post(self, api_v1_secret_scanning_create_installation_session_organization_post_request : ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, **kwargs) -> ApiV1AuthTokenPost200Response:  # noqa: E501
        """api_v3_auth_select_organization_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_auth_select_organization_post(api_v1_secret_scanning_create_installation_session_organization_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_scanning_create_installation_session_organization_post_request: (required)
        :type api_v1_secret_scanning_create_installation_session_organization_post_request: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1AuthTokenPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_auth_select_organization_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_auth_select_organization_post_with_http_info(api_v1_secret_scanning_create_installation_session_organization_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_auth_select_organization_post_with_http_info(self, api_v1_secret_scanning_create_installation_session_organization_post_request : ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_auth_select_organization_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_auth_select_organization_post_with_http_info(api_v1_secret_scanning_create_installation_session_organization_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_secret_scanning_create_installation_session_organization_post_request: (required)
        :type api_v1_secret_scanning_create_installation_session_organization_post_request: ApiV1SecretScanningCreateInstallationSessionOrganizationPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1AuthTokenPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_secret_scanning_create_installation_session_organization_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_auth_select_organization_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_secret_scanning_create_installation_session_organization_post_request'] is not None:
            _body_params = _params['api_v1_secret_scanning_create_installation_session_organization_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1AuthTokenPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/auth/select-organization', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_backfill_secret_references_post(self, api_v3_secrets_backfill_secret_references_post_request : ApiV3SecretsBackfillSecretReferencesPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v3_secrets_backfill_secret_references_post  # noqa: E501

        Backfill secret references  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_backfill_secret_references_post(api_v3_secrets_backfill_secret_references_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_backfill_secret_references_post_request: (required)
        :type api_v3_secrets_backfill_secret_references_post_request: ApiV3SecretsBackfillSecretReferencesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_backfill_secret_references_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_backfill_secret_references_post_with_http_info(api_v3_secrets_backfill_secret_references_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_backfill_secret_references_post_with_http_info(self, api_v3_secrets_backfill_secret_references_post_request : ApiV3SecretsBackfillSecretReferencesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_backfill_secret_references_post  # noqa: E501

        Backfill secret references  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_backfill_secret_references_post_with_http_info(api_v3_secrets_backfill_secret_references_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_backfill_secret_references_post_request: (required)
        :type api_v3_secrets_backfill_secret_references_post_request: ApiV3SecretsBackfillSecretReferencesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_backfill_secret_references_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_backfill_secret_references_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_backfill_secret_references_post_request'] is not None:
            _body_params = _params['api_v3_secrets_backfill_secret_references_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/backfill-secret-references', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_batch_delete(self, api_v3_secrets_batch_delete_request : ApiV3SecretsBatchDeleteRequest, **kwargs) -> ApiV3SecretsBatchPost200Response:  # noqa: E501
        """api_v3_secrets_batch_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_delete(api_v3_secrets_batch_delete_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_delete_request: (required)
        :type api_v3_secrets_batch_delete_request: ApiV3SecretsBatchDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsBatchPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_batch_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_batch_delete_with_http_info(api_v3_secrets_batch_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_batch_delete_with_http_info(self, api_v3_secrets_batch_delete_request : ApiV3SecretsBatchDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_batch_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_delete_with_http_info(api_v3_secrets_batch_delete_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_delete_request: (required)
        :type api_v3_secrets_batch_delete_request: ApiV3SecretsBatchDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsBatchPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_batch_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_batch_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_batch_delete_request'] is not None:
            _body_params = _params['api_v3_secrets_batch_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsBatchPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/batch', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_batch_patch(self, api_v3_secrets_batch_patch_request : ApiV3SecretsBatchPatchRequest, **kwargs) -> ApiV3SecretsBatchPost200Response:  # noqa: E501
        """api_v3_secrets_batch_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_patch(api_v3_secrets_batch_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_patch_request: (required)
        :type api_v3_secrets_batch_patch_request: ApiV3SecretsBatchPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsBatchPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_batch_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_batch_patch_with_http_info(api_v3_secrets_batch_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_batch_patch_with_http_info(self, api_v3_secrets_batch_patch_request : ApiV3SecretsBatchPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_batch_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_patch_with_http_info(api_v3_secrets_batch_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_patch_request: (required)
        :type api_v3_secrets_batch_patch_request: ApiV3SecretsBatchPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsBatchPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_batch_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_batch_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_batch_patch_request'] is not None:
            _body_params = _params['api_v3_secrets_batch_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsBatchPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/batch', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_batch_post(self, api_v3_secrets_batch_post_request : ApiV3SecretsBatchPostRequest, **kwargs) -> ApiV3SecretsBatchPost200Response:  # noqa: E501
        """api_v3_secrets_batch_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_post(api_v3_secrets_batch_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_post_request: (required)
        :type api_v3_secrets_batch_post_request: ApiV3SecretsBatchPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsBatchPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_batch_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_batch_post_with_http_info(api_v3_secrets_batch_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_batch_post_with_http_info(self, api_v3_secrets_batch_post_request : ApiV3SecretsBatchPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_batch_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_post_with_http_info(api_v3_secrets_batch_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_post_request: (required)
        :type api_v3_secrets_batch_post_request: ApiV3SecretsBatchPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsBatchPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_batch_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_batch_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_batch_post_request'] is not None:
            _body_params = _params['api_v3_secrets_batch_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsBatchPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/batch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_batch_raw_delete(self, api_v3_secrets_batch_raw_delete_request : ApiV3SecretsBatchRawDeleteRequest, **kwargs) -> ApiV3SecretsBatchRawPost200Response:  # noqa: E501
        """api_v3_secrets_batch_raw_delete  # noqa: E501

        Delete many secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_raw_delete(api_v3_secrets_batch_raw_delete_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_raw_delete_request: (required)
        :type api_v3_secrets_batch_raw_delete_request: ApiV3SecretsBatchRawDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsBatchRawPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_batch_raw_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_batch_raw_delete_with_http_info(api_v3_secrets_batch_raw_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_batch_raw_delete_with_http_info(self, api_v3_secrets_batch_raw_delete_request : ApiV3SecretsBatchRawDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_batch_raw_delete  # noqa: E501

        Delete many secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_raw_delete_with_http_info(api_v3_secrets_batch_raw_delete_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_raw_delete_request: (required)
        :type api_v3_secrets_batch_raw_delete_request: ApiV3SecretsBatchRawDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsBatchRawPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_batch_raw_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_batch_raw_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_batch_raw_delete_request'] is not None:
            _body_params = _params['api_v3_secrets_batch_raw_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsBatchRawPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/batch/raw', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_batch_raw_patch(self, api_v3_secrets_batch_raw_patch_request : ApiV3SecretsBatchRawPatchRequest, **kwargs) -> ApiV3SecretsBatchRawPost200Response:  # noqa: E501
        """api_v3_secrets_batch_raw_patch  # noqa: E501

        Update many secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_raw_patch(api_v3_secrets_batch_raw_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_raw_patch_request: (required)
        :type api_v3_secrets_batch_raw_patch_request: ApiV3SecretsBatchRawPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsBatchRawPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_batch_raw_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_batch_raw_patch_with_http_info(api_v3_secrets_batch_raw_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_batch_raw_patch_with_http_info(self, api_v3_secrets_batch_raw_patch_request : ApiV3SecretsBatchRawPatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_batch_raw_patch  # noqa: E501

        Update many secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_raw_patch_with_http_info(api_v3_secrets_batch_raw_patch_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_raw_patch_request: (required)
        :type api_v3_secrets_batch_raw_patch_request: ApiV3SecretsBatchRawPatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsBatchRawPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_batch_raw_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_batch_raw_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_batch_raw_patch_request'] is not None:
            _body_params = _params['api_v3_secrets_batch_raw_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsBatchRawPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/batch/raw', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_batch_raw_post(self, api_v3_secrets_batch_raw_post_request : ApiV3SecretsBatchRawPostRequest, **kwargs) -> ApiV3SecretsBatchRawPost200Response:  # noqa: E501
        """api_v3_secrets_batch_raw_post  # noqa: E501

        Create many secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_raw_post(api_v3_secrets_batch_raw_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_raw_post_request: (required)
        :type api_v3_secrets_batch_raw_post_request: ApiV3SecretsBatchRawPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsBatchRawPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_batch_raw_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_batch_raw_post_with_http_info(api_v3_secrets_batch_raw_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_batch_raw_post_with_http_info(self, api_v3_secrets_batch_raw_post_request : ApiV3SecretsBatchRawPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_batch_raw_post  # noqa: E501

        Create many secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_batch_raw_post_with_http_info(api_v3_secrets_batch_raw_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_batch_raw_post_request: (required)
        :type api_v3_secrets_batch_raw_post_request: ApiV3SecretsBatchRawPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsBatchRawPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_batch_raw_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_batch_raw_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_batch_raw_post_request'] is not None:
            _body_params = _params['api_v3_secrets_batch_raw_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsBatchRawPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/batch/raw', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_get(self, workspace_id : StrictStr, environment : StrictStr, secret_path : Optional[StrictStr] = None, recursive : Optional[StrictStr] = None, include_imports : Optional[StrictStr] = None, **kwargs) -> ApiV3SecretsGet200Response:  # noqa: E501
        """api_v3_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_get(workspace_id, environment, secret_path, recursive, include_imports, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param secret_path:
        :type secret_path: str
        :param recursive:
        :type recursive: str
        :param include_imports:
        :type include_imports: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_get_with_http_info(workspace_id, environment, secret_path, recursive, include_imports, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_get_with_http_info(self, workspace_id : StrictStr, environment : StrictStr, secret_path : Optional[StrictStr] = None, recursive : Optional[StrictStr] = None, include_imports : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_get_with_http_info(workspace_id, environment, secret_path, recursive, include_imports, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param secret_path:
        :type secret_path: str
        :param recursive:
        :type recursive: str
        :param include_imports:
        :type include_imports: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'secret_path',
            'recursive',
            'include_imports'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('secret_path') is not None:  # noqa: E501
            _query_params.append(('secretPath', _params['secret_path']))

        if _params.get('recursive') is not None:  # noqa: E501
            _query_params.append(('recursive', _params['recursive']))

        if _params.get('include_imports') is not None:  # noqa: E501
            _query_params.append(('include_imports', _params['include_imports']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_move_post(self, api_v3_secrets_move_post_request : ApiV3SecretsMovePostRequest, **kwargs) -> ApiV3SecretsMovePost200Response:  # noqa: E501
        """api_v3_secrets_move_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_move_post(api_v3_secrets_move_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_move_post_request: (required)
        :type api_v3_secrets_move_post_request: ApiV3SecretsMovePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsMovePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_move_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_move_post_with_http_info(api_v3_secrets_move_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_move_post_with_http_info(self, api_v3_secrets_move_post_request : ApiV3SecretsMovePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_move_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_move_post_with_http_info(api_v3_secrets_move_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_secrets_move_post_request: (required)
        :type api_v3_secrets_move_post_request: ApiV3SecretsMovePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsMovePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_secrets_move_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_move_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_move_post_request'] is not None:
            _body_params = _params['api_v3_secrets_move_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsMovePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/move', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_raw_get(self, workspace_id : Annotated[Optional[StrictStr], Field(description="The ID of the project to list secrets from.")] = None, workspace_slug : Annotated[Optional[StrictStr], Field(description="The slug of the project to list secrets from. This parameter is only applicable by machine identities.")] = None, environment : Annotated[Optional[StrictStr], Field(description="The slug of the environment to list secrets from.")] = None, secret_path : Annotated[Optional[StrictStr], Field(description="The secret path to list secrets from.")] = None, expand_secret_references : Annotated[Optional[StrictStr], Field(description="Whether or not to expand secret references")] = None, recursive : Annotated[Optional[StrictStr], Field(description="Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.")] = None, include_imports : Annotated[Optional[StrictStr], Field(description="Weather to include imported secrets or not.")] = None, tag_slugs : Annotated[Optional[StrictStr], Field(description="The comma separated tag slugs to filter secrets")] = None, **kwargs) -> ApiV3SecretsRawGet200Response:  # noqa: E501
        """api_v3_secrets_raw_get  # noqa: E501

        List secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_get(workspace_id, workspace_slug, environment, secret_path, expand_secret_references, recursive, include_imports, tag_slugs, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list secrets from.
        :type workspace_id: str
        :param workspace_slug: The slug of the project to list secrets from. This parameter is only applicable by machine identities.
        :type workspace_slug: str
        :param environment: The slug of the environment to list secrets from.
        :type environment: str
        :param secret_path: The secret path to list secrets from.
        :type secret_path: str
        :param expand_secret_references: Whether or not to expand secret references
        :type expand_secret_references: str
        :param recursive: Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.
        :type recursive: str
        :param include_imports: Weather to include imported secrets or not.
        :type include_imports: str
        :param tag_slugs: The comma separated tag slugs to filter secrets
        :type tag_slugs: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsRawGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_raw_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_raw_get_with_http_info(workspace_id, workspace_slug, environment, secret_path, expand_secret_references, recursive, include_imports, tag_slugs, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_raw_get_with_http_info(self, workspace_id : Annotated[Optional[StrictStr], Field(description="The ID of the project to list secrets from.")] = None, workspace_slug : Annotated[Optional[StrictStr], Field(description="The slug of the project to list secrets from. This parameter is only applicable by machine identities.")] = None, environment : Annotated[Optional[StrictStr], Field(description="The slug of the environment to list secrets from.")] = None, secret_path : Annotated[Optional[StrictStr], Field(description="The secret path to list secrets from.")] = None, expand_secret_references : Annotated[Optional[StrictStr], Field(description="Whether or not to expand secret references")] = None, recursive : Annotated[Optional[StrictStr], Field(description="Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.")] = None, include_imports : Annotated[Optional[StrictStr], Field(description="Weather to include imported secrets or not.")] = None, tag_slugs : Annotated[Optional[StrictStr], Field(description="The comma separated tag slugs to filter secrets")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_raw_get  # noqa: E501

        List secrets  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_get_with_http_info(workspace_id, workspace_slug, environment, secret_path, expand_secret_references, recursive, include_imports, tag_slugs, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The ID of the project to list secrets from.
        :type workspace_id: str
        :param workspace_slug: The slug of the project to list secrets from. This parameter is only applicable by machine identities.
        :type workspace_slug: str
        :param environment: The slug of the environment to list secrets from.
        :type environment: str
        :param secret_path: The secret path to list secrets from.
        :type secret_path: str
        :param expand_secret_references: Whether or not to expand secret references
        :type expand_secret_references: str
        :param recursive: Whether or not to fetch all secrets from the specified base path, and all of its subdirectories. Note, the max depth is 20 deep.
        :type recursive: str
        :param include_imports: Weather to include imported secrets or not.
        :type include_imports: str
        :param tag_slugs: The comma separated tag slugs to filter secrets
        :type tag_slugs: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsRawGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'workspace_slug',
            'environment',
            'secret_path',
            'expand_secret_references',
            'recursive',
            'include_imports',
            'tag_slugs'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_raw_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('workspace_slug') is not None:  # noqa: E501
            _query_params.append(('workspaceSlug', _params['workspace_slug']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('secret_path') is not None:  # noqa: E501
            _query_params.append(('secretPath', _params['secret_path']))

        if _params.get('expand_secret_references') is not None:  # noqa: E501
            _query_params.append(('expandSecretReferences', _params['expand_secret_references']))

        if _params.get('recursive') is not None:  # noqa: E501
            _query_params.append(('recursive', _params['recursive']))

        if _params.get('include_imports') is not None:  # noqa: E501
            _query_params.append(('include_imports', _params['include_imports']))

        if _params.get('tag_slugs') is not None:  # noqa: E501
            _query_params.append(('tagSlugs', _params['tag_slugs']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsRawGet200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/raw', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_raw_secret_name_delete(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to delete.")], api_v3_secrets_raw_secret_name_delete_request : ApiV3SecretsRawSecretNameDeleteRequest, **kwargs) -> ApiV3SecretsRawSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_raw_secret_name_delete  # noqa: E501

        Delete secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_delete(secret_name, api_v3_secrets_raw_secret_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to delete. (required)
        :type secret_name: str
        :param api_v3_secrets_raw_secret_name_delete_request: (required)
        :type api_v3_secrets_raw_secret_name_delete_request: ApiV3SecretsRawSecretNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsRawSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_raw_secret_name_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_raw_secret_name_delete_with_http_info(secret_name, api_v3_secrets_raw_secret_name_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_raw_secret_name_delete_with_http_info(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to delete.")], api_v3_secrets_raw_secret_name_delete_request : ApiV3SecretsRawSecretNameDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_raw_secret_name_delete  # noqa: E501

        Delete secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_delete_with_http_info(secret_name, api_v3_secrets_raw_secret_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to delete. (required)
        :type secret_name: str
        :param api_v3_secrets_raw_secret_name_delete_request: (required)
        :type api_v3_secrets_raw_secret_name_delete_request: ApiV3SecretsRawSecretNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsRawSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_raw_secret_name_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_raw_secret_name_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_raw_secret_name_delete_request'] is not None:
            _body_params = _params['api_v3_secrets_raw_secret_name_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsRawSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/raw/{secretName}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_raw_secret_name_get(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to get.")], workspace_id : Annotated[Optional[StrictStr], Field(description="The ID of the project to get the secret from.")] = None, workspace_slug : Annotated[Optional[StrictStr], Field(description="The slug of the project to get the secret from.")] = None, environment : Annotated[Optional[StrictStr], Field(description="The slug of the environment to get the secret from.")] = None, secret_path : Annotated[Optional[StrictStr], Field(description="The path of the secret to get.")] = None, version : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The version of the secret to get.")] = None, type : Annotated[Optional[StrictStr], Field(description="The type of the secret to get.")] = None, expand_secret_references : Annotated[Optional[StrictStr], Field(description="Whether or not to expand secret references")] = None, include_imports : Annotated[Optional[StrictStr], Field(description="Weather to include imported secrets or not.")] = None, **kwargs) -> ApiV3SecretsRawSecretNameGet200Response:  # noqa: E501
        """api_v3_secrets_raw_secret_name_get  # noqa: E501

        Get a secret by name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_get(secret_name, workspace_id, workspace_slug, environment, secret_path, version, type, expand_secret_references, include_imports, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to get. (required)
        :type secret_name: str
        :param workspace_id: The ID of the project to get the secret from.
        :type workspace_id: str
        :param workspace_slug: The slug of the project to get the secret from.
        :type workspace_slug: str
        :param environment: The slug of the environment to get the secret from.
        :type environment: str
        :param secret_path: The path of the secret to get.
        :type secret_path: str
        :param version: The version of the secret to get.
        :type version: float
        :param type: The type of the secret to get.
        :type type: str
        :param expand_secret_references: Whether or not to expand secret references
        :type expand_secret_references: str
        :param include_imports: Weather to include imported secrets or not.
        :type include_imports: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsRawSecretNameGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_raw_secret_name_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_raw_secret_name_get_with_http_info(secret_name, workspace_id, workspace_slug, environment, secret_path, version, type, expand_secret_references, include_imports, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_raw_secret_name_get_with_http_info(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to get.")], workspace_id : Annotated[Optional[StrictStr], Field(description="The ID of the project to get the secret from.")] = None, workspace_slug : Annotated[Optional[StrictStr], Field(description="The slug of the project to get the secret from.")] = None, environment : Annotated[Optional[StrictStr], Field(description="The slug of the environment to get the secret from.")] = None, secret_path : Annotated[Optional[StrictStr], Field(description="The path of the secret to get.")] = None, version : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The version of the secret to get.")] = None, type : Annotated[Optional[StrictStr], Field(description="The type of the secret to get.")] = None, expand_secret_references : Annotated[Optional[StrictStr], Field(description="Whether or not to expand secret references")] = None, include_imports : Annotated[Optional[StrictStr], Field(description="Weather to include imported secrets or not.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_raw_secret_name_get  # noqa: E501

        Get a secret by name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_get_with_http_info(secret_name, workspace_id, workspace_slug, environment, secret_path, version, type, expand_secret_references, include_imports, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to get. (required)
        :type secret_name: str
        :param workspace_id: The ID of the project to get the secret from.
        :type workspace_id: str
        :param workspace_slug: The slug of the project to get the secret from.
        :type workspace_slug: str
        :param environment: The slug of the environment to get the secret from.
        :type environment: str
        :param secret_path: The path of the secret to get.
        :type secret_path: str
        :param version: The version of the secret to get.
        :type version: float
        :param type: The type of the secret to get.
        :type type: str
        :param expand_secret_references: Whether or not to expand secret references
        :type expand_secret_references: str
        :param include_imports: Weather to include imported secrets or not.
        :type include_imports: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsRawSecretNameGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'workspace_id',
            'workspace_slug',
            'environment',
            'secret_path',
            'version',
            'type',
            'expand_secret_references',
            'include_imports'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_raw_secret_name_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('workspace_slug') is not None:  # noqa: E501
            _query_params.append(('workspaceSlug', _params['workspace_slug']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('secret_path') is not None:  # noqa: E501
            _query_params.append(('secretPath', _params['secret_path']))

        if _params.get('version') is not None:  # noqa: E501
            _query_params.append(('version', _params['version']))

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        if _params.get('expand_secret_references') is not None:  # noqa: E501
            _query_params.append(('expandSecretReferences', _params['expand_secret_references']))

        if _params.get('include_imports') is not None:  # noqa: E501
            _query_params.append(('include_imports', _params['include_imports']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsRawSecretNameGet200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/raw/{secretName}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_raw_secret_name_patch(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to update.")], api_v3_secrets_raw_secret_name_patch_request : ApiV3SecretsRawSecretNamePatchRequest, **kwargs) -> ApiV3SecretsRawSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_raw_secret_name_patch  # noqa: E501

        Update secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_patch(secret_name, api_v3_secrets_raw_secret_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to update. (required)
        :type secret_name: str
        :param api_v3_secrets_raw_secret_name_patch_request: (required)
        :type api_v3_secrets_raw_secret_name_patch_request: ApiV3SecretsRawSecretNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsRawSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_raw_secret_name_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_raw_secret_name_patch_with_http_info(secret_name, api_v3_secrets_raw_secret_name_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_raw_secret_name_patch_with_http_info(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to update.")], api_v3_secrets_raw_secret_name_patch_request : ApiV3SecretsRawSecretNamePatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_raw_secret_name_patch  # noqa: E501

        Update secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_patch_with_http_info(secret_name, api_v3_secrets_raw_secret_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to update. (required)
        :type secret_name: str
        :param api_v3_secrets_raw_secret_name_patch_request: (required)
        :type api_v3_secrets_raw_secret_name_patch_request: ApiV3SecretsRawSecretNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsRawSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_raw_secret_name_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_raw_secret_name_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_raw_secret_name_patch_request'] is not None:
            _body_params = _params['api_v3_secrets_raw_secret_name_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsRawSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/raw/{secretName}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_raw_secret_name_post(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to create.")], api_v3_secrets_raw_secret_name_post_request : ApiV3SecretsRawSecretNamePostRequest, **kwargs) -> ApiV3SecretsRawSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_raw_secret_name_post  # noqa: E501

        Create secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_post(secret_name, api_v3_secrets_raw_secret_name_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to create. (required)
        :type secret_name: str
        :param api_v3_secrets_raw_secret_name_post_request: (required)
        :type api_v3_secrets_raw_secret_name_post_request: ApiV3SecretsRawSecretNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsRawSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_raw_secret_name_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_raw_secret_name_post_with_http_info(secret_name, api_v3_secrets_raw_secret_name_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_raw_secret_name_post_with_http_info(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to create.")], api_v3_secrets_raw_secret_name_post_request : ApiV3SecretsRawSecretNamePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_raw_secret_name_post  # noqa: E501

        Create secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_raw_secret_name_post_with_http_info(secret_name, api_v3_secrets_raw_secret_name_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to create. (required)
        :type secret_name: str
        :param api_v3_secrets_raw_secret_name_post_request: (required)
        :type api_v3_secrets_raw_secret_name_post_request: ApiV3SecretsRawSecretNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsRawSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_raw_secret_name_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_raw_secret_name_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_raw_secret_name_post_request'] is not None:
            _body_params = _params['api_v3_secrets_raw_secret_name_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsRawSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/raw/{secretName}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_secret_name_delete(self, secret_name : StrictStr, api_v3_secrets_secret_name_delete_request : ApiV3SecretsSecretNameDeleteRequest, **kwargs) -> ApiV3SecretsSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_secret_name_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_delete(secret_name, api_v3_secrets_secret_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: (required)
        :type secret_name: str
        :param api_v3_secrets_secret_name_delete_request: (required)
        :type api_v3_secrets_secret_name_delete_request: ApiV3SecretsSecretNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_secret_name_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_secret_name_delete_with_http_info(secret_name, api_v3_secrets_secret_name_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_secret_name_delete_with_http_info(self, secret_name : StrictStr, api_v3_secrets_secret_name_delete_request : ApiV3SecretsSecretNameDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_secret_name_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_delete_with_http_info(secret_name, api_v3_secrets_secret_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: (required)
        :type secret_name: str
        :param api_v3_secrets_secret_name_delete_request: (required)
        :type api_v3_secrets_secret_name_delete_request: ApiV3SecretsSecretNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_secret_name_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_secret_name_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_secret_name_delete_request'] is not None:
            _body_params = _params['api_v3_secrets_secret_name_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/{secretName}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_secret_name_get(self, workspace_id : StrictStr, environment : StrictStr, secret_name : StrictStr, secret_path : Optional[StrictStr] = None, type : Optional[StrictStr] = None, version : Optional[Union[StrictFloat, StrictInt]] = None, include_imports : Optional[StrictStr] = None, **kwargs) -> ApiV3SecretsSecretNameGet200Response:  # noqa: E501
        """api_v3_secrets_secret_name_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_get(workspace_id, environment, secret_name, secret_path, type, version, include_imports, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param secret_name: (required)
        :type secret_name: str
        :param secret_path:
        :type secret_path: str
        :param type:
        :type type: str
        :param version:
        :type version: float
        :param include_imports:
        :type include_imports: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsSecretNameGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_secret_name_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_secret_name_get_with_http_info(workspace_id, environment, secret_name, secret_path, type, version, include_imports, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_secret_name_get_with_http_info(self, workspace_id : StrictStr, environment : StrictStr, secret_name : StrictStr, secret_path : Optional[StrictStr] = None, type : Optional[StrictStr] = None, version : Optional[Union[StrictFloat, StrictInt]] = None, include_imports : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_secret_name_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_get_with_http_info(workspace_id, environment, secret_name, secret_path, type, version, include_imports, async_req=True)
        >>> result = thread.get()

        :param workspace_id: (required)
        :type workspace_id: str
        :param environment: (required)
        :type environment: str
        :param secret_name: (required)
        :type secret_name: str
        :param secret_path:
        :type secret_path: str
        :param type:
        :type type: str
        :param version:
        :type version: float
        :param include_imports:
        :type include_imports: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsSecretNameGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'environment',
            'secret_name',
            'secret_path',
            'type',
            'version',
            'include_imports'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_secret_name_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        if _params.get('workspace_id') is not None:  # noqa: E501
            _query_params.append(('workspaceId', _params['workspace_id']))

        if _params.get('environment') is not None:  # noqa: E501
            _query_params.append(('environment', _params['environment']))

        if _params.get('secret_path') is not None:  # noqa: E501
            _query_params.append(('secretPath', _params['secret_path']))

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        if _params.get('version') is not None:  # noqa: E501
            _query_params.append(('version', _params['version']))

        if _params.get('include_imports') is not None:  # noqa: E501
            _query_params.append(('include_imports', _params['include_imports']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsSecretNameGet200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/{secretName}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_secret_name_patch(self, secret_name : StrictStr, api_v3_secrets_secret_name_patch_request : ApiV3SecretsSecretNamePatchRequest, **kwargs) -> ApiV3SecretsSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_secret_name_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_patch(secret_name, api_v3_secrets_secret_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: (required)
        :type secret_name: str
        :param api_v3_secrets_secret_name_patch_request: (required)
        :type api_v3_secrets_secret_name_patch_request: ApiV3SecretsSecretNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_secret_name_patch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_secret_name_patch_with_http_info(secret_name, api_v3_secrets_secret_name_patch_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_secret_name_patch_with_http_info(self, secret_name : StrictStr, api_v3_secrets_secret_name_patch_request : ApiV3SecretsSecretNamePatchRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_secret_name_patch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_patch_with_http_info(secret_name, api_v3_secrets_secret_name_patch_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: (required)
        :type secret_name: str
        :param api_v3_secrets_secret_name_patch_request: (required)
        :type api_v3_secrets_secret_name_patch_request: ApiV3SecretsSecretNamePatchRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_secret_name_patch_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_secret_name_patch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_secret_name_patch_request'] is not None:
            _body_params = _params['api_v3_secrets_secret_name_patch_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/{secretName}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_secret_name_post(self, secret_name : StrictStr, api_v3_secrets_secret_name_post_request : ApiV3SecretsSecretNamePostRequest, **kwargs) -> ApiV3SecretsSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_secret_name_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_post(secret_name, api_v3_secrets_secret_name_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: (required)
        :type secret_name: str
        :param api_v3_secrets_secret_name_post_request: (required)
        :type api_v3_secrets_secret_name_post_request: ApiV3SecretsSecretNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_secret_name_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_secret_name_post_with_http_info(secret_name, api_v3_secrets_secret_name_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_secret_name_post_with_http_info(self, secret_name : StrictStr, api_v3_secrets_secret_name_post_request : ApiV3SecretsSecretNamePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_secret_name_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_secret_name_post_with_http_info(secret_name, api_v3_secrets_secret_name_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: (required)
        :type secret_name: str
        :param api_v3_secrets_secret_name_post_request: (required)
        :type api_v3_secrets_secret_name_post_request: ApiV3SecretsSecretNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_secret_name_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_secret_name_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_secret_name_post_request'] is not None:
            _body_params = _params['api_v3_secrets_secret_name_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/{secretName}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_tags_secret_name_delete(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to detach tags from.")], api_v3_secrets_tags_secret_name_delete_request : ApiV3SecretsTagsSecretNameDeleteRequest, **kwargs) -> ApiV3SecretsTagsSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_tags_secret_name_delete  # noqa: E501

        Detach tags from a secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_tags_secret_name_delete(secret_name, api_v3_secrets_tags_secret_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to detach tags from. (required)
        :type secret_name: str
        :param api_v3_secrets_tags_secret_name_delete_request: (required)
        :type api_v3_secrets_tags_secret_name_delete_request: ApiV3SecretsTagsSecretNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsTagsSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_tags_secret_name_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_tags_secret_name_delete_with_http_info(secret_name, api_v3_secrets_tags_secret_name_delete_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_tags_secret_name_delete_with_http_info(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to detach tags from.")], api_v3_secrets_tags_secret_name_delete_request : ApiV3SecretsTagsSecretNameDeleteRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_tags_secret_name_delete  # noqa: E501

        Detach tags from a secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_tags_secret_name_delete_with_http_info(secret_name, api_v3_secrets_tags_secret_name_delete_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to detach tags from. (required)
        :type secret_name: str
        :param api_v3_secrets_tags_secret_name_delete_request: (required)
        :type api_v3_secrets_tags_secret_name_delete_request: ApiV3SecretsTagsSecretNameDeleteRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsTagsSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_tags_secret_name_delete_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_tags_secret_name_delete" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_tags_secret_name_delete_request'] is not None:
            _body_params = _params['api_v3_secrets_tags_secret_name_delete_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsTagsSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/tags/{secretName}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_secrets_tags_secret_name_post(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to attach tags to.")], api_v3_secrets_tags_secret_name_post_request : ApiV3SecretsTagsSecretNamePostRequest, **kwargs) -> ApiV3SecretsTagsSecretNamePost200Response:  # noqa: E501
        """api_v3_secrets_tags_secret_name_post  # noqa: E501

        Attach tags to a secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_tags_secret_name_post(secret_name, api_v3_secrets_tags_secret_name_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to attach tags to. (required)
        :type secret_name: str
        :param api_v3_secrets_tags_secret_name_post_request: (required)
        :type api_v3_secrets_tags_secret_name_post_request: ApiV3SecretsTagsSecretNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SecretsTagsSecretNamePost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_secrets_tags_secret_name_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_secrets_tags_secret_name_post_with_http_info(secret_name, api_v3_secrets_tags_secret_name_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_secrets_tags_secret_name_post_with_http_info(self, secret_name : Annotated[StrictStr, Field(..., description="The name of the secret to attach tags to.")], api_v3_secrets_tags_secret_name_post_request : ApiV3SecretsTagsSecretNamePostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_secrets_tags_secret_name_post  # noqa: E501

        Attach tags to a secret  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_secrets_tags_secret_name_post_with_http_info(secret_name, api_v3_secrets_tags_secret_name_post_request, async_req=True)
        >>> result = thread.get()

        :param secret_name: The name of the secret to attach tags to. (required)
        :type secret_name: str
        :param api_v3_secrets_tags_secret_name_post_request: (required)
        :type api_v3_secrets_tags_secret_name_post_request: ApiV3SecretsTagsSecretNamePostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SecretsTagsSecretNamePost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'secret_name',
            'api_v3_secrets_tags_secret_name_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_secrets_tags_secret_name_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['secret_name'] is not None:
            _path_params['secretName'] = _params['secret_name']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_secrets_tags_secret_name_post_request'] is not None:
            _body_params = _params['api_v3_secrets_tags_secret_name_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SecretsTagsSecretNamePost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/secrets/tags/{secretName}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_signup_complete_account_invite_post(self, api_v1_admin_signup_post_request : ApiV1AdminSignupPostRequest, **kwargs) -> ApiV1PasswordEmailPasswordResetVerifyPost200Response:  # noqa: E501
        """api_v3_signup_complete_account_invite_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_complete_account_invite_post(api_v1_admin_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_admin_signup_post_request: (required)
        :type api_v1_admin_signup_post_request: ApiV1AdminSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1PasswordEmailPasswordResetVerifyPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_signup_complete_account_invite_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_signup_complete_account_invite_post_with_http_info(api_v1_admin_signup_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_signup_complete_account_invite_post_with_http_info(self, api_v1_admin_signup_post_request : ApiV1AdminSignupPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_signup_complete_account_invite_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_complete_account_invite_post_with_http_info(api_v1_admin_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_admin_signup_post_request: (required)
        :type api_v1_admin_signup_post_request: ApiV1AdminSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1PasswordEmailPasswordResetVerifyPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_admin_signup_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_signup_complete_account_invite_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_admin_signup_post_request'] is not None:
            _body_params = _params['api_v1_admin_signup_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1PasswordEmailPasswordResetVerifyPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/signup/complete-account/invite', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_signup_complete_account_signup_post(self, api_v3_signup_complete_account_signup_post_request : ApiV3SignupCompleteAccountSignupPostRequest, **kwargs) -> ApiV3SignupCompleteAccountSignupPost200Response:  # noqa: E501
        """api_v3_signup_complete_account_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_complete_account_signup_post(api_v3_signup_complete_account_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_signup_complete_account_signup_post_request: (required)
        :type api_v3_signup_complete_account_signup_post_request: ApiV3SignupCompleteAccountSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SignupCompleteAccountSignupPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_signup_complete_account_signup_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_signup_complete_account_signup_post_with_http_info(api_v3_signup_complete_account_signup_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_signup_complete_account_signup_post_with_http_info(self, api_v3_signup_complete_account_signup_post_request : ApiV3SignupCompleteAccountSignupPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_signup_complete_account_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_complete_account_signup_post_with_http_info(api_v3_signup_complete_account_signup_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v3_signup_complete_account_signup_post_request: (required)
        :type api_v3_signup_complete_account_signup_post_request: ApiV3SignupCompleteAccountSignupPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SignupCompleteAccountSignupPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v3_signup_complete_account_signup_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_signup_complete_account_signup_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_signup_complete_account_signup_post_request'] is not None:
            _body_params = _params['api_v3_signup_complete_account_signup_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SignupCompleteAccountSignupPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/signup/complete-account/signup', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_signup_email_signup_post(self, api_v1_password_email_password_reset_post_request : ApiV1PasswordEmailPasswordResetPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v3_signup_email_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_email_signup_post(api_v1_password_email_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_post_request: (required)
        :type api_v1_password_email_password_reset_post_request: ApiV1PasswordEmailPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_signup_email_signup_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_signup_email_signup_post_with_http_info(api_v1_password_email_password_reset_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_signup_email_signup_post_with_http_info(self, api_v1_password_email_password_reset_post_request : ApiV1PasswordEmailPasswordResetPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_signup_email_signup_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_email_signup_post_with_http_info(api_v1_password_email_password_reset_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_post_request: (required)
        :type api_v1_password_email_password_reset_post_request: ApiV1PasswordEmailPasswordResetPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_email_password_reset_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_signup_email_signup_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_email_password_reset_post_request'] is not None:
            _body_params = _params['api_v1_password_email_password_reset_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v3/signup/email/signup', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_signup_email_verify_post(self, api_v1_password_email_password_reset_verify_post_request : ApiV1PasswordEmailPasswordResetVerifyPostRequest, **kwargs) -> ApiV3SignupEmailVerifyPost200Response:  # noqa: E501
        """api_v3_signup_email_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_email_verify_post(api_v1_password_email_password_reset_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_verify_post_request: (required)
        :type api_v1_password_email_password_reset_verify_post_request: ApiV1PasswordEmailPasswordResetVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3SignupEmailVerifyPost200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_signup_email_verify_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_signup_email_verify_post_with_http_info(api_v1_password_email_password_reset_verify_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_signup_email_verify_post_with_http_info(self, api_v1_password_email_password_reset_verify_post_request : ApiV1PasswordEmailPasswordResetVerifyPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_signup_email_verify_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_signup_email_verify_post_with_http_info(api_v1_password_email_password_reset_verify_post_request, async_req=True)
        >>> result = thread.get()

        :param api_v1_password_email_password_reset_verify_post_request: (required)
        :type api_v1_password_email_password_reset_verify_post_request: ApiV1PasswordEmailPasswordResetVerifyPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3SignupEmailVerifyPost200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'api_v1_password_email_password_reset_verify_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_signup_email_verify_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v1_password_email_password_reset_verify_post_request'] is not None:
            _body_params = _params['api_v1_password_email_password_reset_verify_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3SignupEmailVerifyPost200Response",
        }

        return self.api_client.call_api(
            '/api/v3/signup/email/verify', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_users_me_api_keys_get(self, **kwargs) -> ApiV3UsersMeApiKeysGet200Response:  # noqa: E501
        """api_v3_users_me_api_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_users_me_api_keys_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3UsersMeApiKeysGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_users_me_api_keys_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_users_me_api_keys_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_users_me_api_keys_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_users_me_api_keys_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_users_me_api_keys_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3UsersMeApiKeysGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_users_me_api_keys_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3UsersMeApiKeysGet200Response",
        }

        return self.api_client.call_api(
            '/api/v3/users/me/api-keys', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_workspaces_project_id_secrets_blind_index_status_get(self, project_id : StrictStr, **kwargs) -> bool:  # noqa: E501
        """api_v3_workspaces_project_id_secrets_blind_index_status_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_workspaces_project_id_secrets_blind_index_status_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bool
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_workspaces_project_id_secrets_blind_index_status_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_workspaces_project_id_secrets_blind_index_status_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_workspaces_project_id_secrets_blind_index_status_get_with_http_info(self, project_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_workspaces_project_id_secrets_blind_index_status_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_workspaces_project_id_secrets_blind_index_status_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bool, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_workspaces_project_id_secrets_blind_index_status_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "bool",
        }

        return self.api_client.call_api(
            '/api/v3/workspaces/{projectId}/secrets/blind-index-status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_workspaces_project_id_secrets_get(self, project_id : StrictStr, **kwargs) -> ApiV3WorkspacesProjectIdSecretsGet200Response:  # noqa: E501
        """api_v3_workspaces_project_id_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_workspaces_project_id_secrets_get(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV3WorkspacesProjectIdSecretsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_workspaces_project_id_secrets_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_workspaces_project_id_secrets_get_with_http_info(project_id, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_workspaces_project_id_secrets_get_with_http_info(self, project_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_workspaces_project_id_secrets_get  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_workspaces_project_id_secrets_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV3WorkspacesProjectIdSecretsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_workspaces_project_id_secrets_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV3WorkspacesProjectIdSecretsGet200Response",
        }

        return self.api_client.call_api(
            '/api/v3/workspaces/{projectId}/secrets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def api_v3_workspaces_project_id_secrets_names_post(self, project_id : StrictStr, api_v3_workspaces_project_id_secrets_names_post_request : ApiV3WorkspacesProjectIdSecretsNamesPostRequest, **kwargs) -> ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response:  # noqa: E501
        """api_v3_workspaces_project_id_secrets_names_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_workspaces_project_id_secrets_names_post(project_id, api_v3_workspaces_project_id_secrets_names_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param api_v3_workspaces_project_id_secrets_names_post_request: (required)
        :type api_v3_workspaces_project_id_secrets_names_post_request: ApiV3WorkspacesProjectIdSecretsNamesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the api_v3_workspaces_project_id_secrets_names_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.api_v3_workspaces_project_id_secrets_names_post_with_http_info(project_id, api_v3_workspaces_project_id_secrets_names_post_request, **kwargs)  # noqa: E501

    @validate_arguments
    def api_v3_workspaces_project_id_secrets_names_post_with_http_info(self, project_id : StrictStr, api_v3_workspaces_project_id_secrets_names_post_request : ApiV3WorkspacesProjectIdSecretsNamesPostRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """api_v3_workspaces_project_id_secrets_names_post  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.api_v3_workspaces_project_id_secrets_names_post_with_http_info(project_id, api_v3_workspaces_project_id_secrets_names_post_request, async_req=True)
        >>> result = thread.get()

        :param project_id: (required)
        :type project_id: str
        :param api_v3_workspaces_project_id_secrets_names_post_request: (required)
        :type api_v3_workspaces_project_id_secrets_names_post_request: ApiV3WorkspacesProjectIdSecretsNamesPostRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'project_id',
            'api_v3_workspaces_project_id_secrets_names_post_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_workspaces_project_id_secrets_names_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['project_id'] is not None:
            _path_params['projectId'] = _params['project_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['api_v3_workspaces_project_id_secrets_names_post_request'] is not None:
            _body_params = _params['api_v3_workspaces_project_id_secrets_names_post_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ApiV1WorkspaceWorkspaceIdMigrateV3Post200Response",
        }

        return self.api_client.call_api(
            '/api/v3/workspaces/{projectId}/secrets/names', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
